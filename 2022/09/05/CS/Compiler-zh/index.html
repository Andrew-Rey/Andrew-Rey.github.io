<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Compiler-zh"/><meta name="keywords" content="CS, Compiler, Andrew-Rey" /><link rel="alternate" href="/disable" title="Andrew-Rey" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.1" />
<link rel="canonical" href="https://Andrew-Rey.github.io/2022/09/05/CS/Compiler-zh/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.1" />

<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>Compiler-zh - Andrew-Rey</title>
  <meta name="generator" content="Hexo 6.1.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Andrew-Rey</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Andrew-Rey</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Compiler-zh
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2022-09-05
        </span><span class="post-author">
          / Andrew-Rey
        </span>
        <span class="post-category">
            <a href="/categories/CS/">CS</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA"><span class="toc-text">引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-lexical-analysis"><span class="toc-text">词法分析 Lexical Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-syntax-analysis"><span class="toc-text">语法分析 Syntax Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-semmantic-ananlysis"><span class="toc-text">语义分析 Semmantic Ananlysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-intermediate-code-generation"><span class="toc-text">中间代码生成
Intermediate Code Generation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-optimization"><span class="toc-text">优化 Optimization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-code-generation"><span class="toc-text">目标代码生成 Code Generation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E7%AE%A1%E7%90%86-symbol-table-management"><span class="toc-text">表格管理 Symbol Table
Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-error-handler"><span class="toc-text">错误处理 Error Handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A6%82%E5%BF%B5"><span class="toc-text">其他概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80"><span class="toc-text">编译基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-text">一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-text">运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E4%B8%8E%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">文法与语言的形式定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E7%AE%80%E5%8C%96"><span class="toc-text">文法的构造与简化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96"><span class="toc-text">简化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-text">构造</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-text">语义分析与中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5-%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F%E6%97%A0%E6%95%B0%E7%BB%84-%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-text">赋值语句 (简单变量无数组)
的翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-text">布尔表达式的翻译</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><p>"编译原理网课"</p>
<p>"B站大学不用交学费!!!"</p>
<span id="more"></span>
<h1 id="引论">引论</h1>
<p><strong>编译</strong>: 由高级语言转化为低级语言</p>
<p><strong>解释</strong>: 接受高级语言的 <strong>一个语句输入</strong>,
进行解释并执行, 立刻得到执行结果, 然后再接受下一句.</p>
<ul>
<li>不产生目标文件, 直观易懂, 结构简单, 易于人机对话</li>
<li>但效率低: 没有目标文件, 每次运行相当于要重新解释</li>
</ul>
<p><strong>编译的两个转换形式</strong></p>
<ul>
<li>编译 - 运行
<ul>
<li>先编译产生机器语言, 生成目标文件(.exe), 在运行时添加参数</li>
</ul></li>
<li>编译 - 汇编 - 运行
<ul>
<li>编译后产生汇编语言, 生成目标文件(.obj),
汇编语言汇编后产生机器语言</li>
</ul></li>
</ul>
<p><strong>编译过程</strong></p>
<p>源程序 -&gt; Lexical analyzer -&gt; Syntax analyzer -&gt; Semmantic
Analyzer -&gt; Intermediate code generation -&gt; Optimization -&gt;
Code generation -&gt; Target</p>
<p>symbol table management, error handler</p>
<h2 id="词法分析-lexical-analysis">词法分析 Lexical Analysis</h2>
<p>扫描源程序, 识别一个个 <strong>单词lexeme</strong>, 并进行
<strong>分类token</strong> (包括: keyword, constant, identifier,
operator, separator). 转化后的格式为 &lt;token-name, attr-value&gt;,
前者为token, 后者为 <strong>指向符号表的指针</strong>.</p>
<p>描述词法规则的有效工具是
<strong>正规式</strong>和<strong>有限自动机</strong></p>
<h2 id="语法分析-syntax-analysis">语法分析 Syntax Analysis</h2>
<p>把单词符号组成各类各类的语法单位, 如短语, 句子, 过程, 程序等</p>
<p>方法:</p>
<ul>
<li>derive:
<ul>
<li>最右推导: 每次将最右的部分按照规则进行转化</li>
<li>最左推导:</li>
</ul></li>
<li>reduce: 推导的逆过程
<ul>
<li>最左归约: 最右推导的逆过程</li>
<li>最右归约: 最左推导的逆过程</li>
</ul></li>
</ul>
<p>计算机处理方法: <strong>语法树</strong></p>
<h2 id="语义分析-semmantic-ananlysis">语义分析 Semmantic Ananlysis</h2>
<p>审查源程序有无语义错误, 为代码生成阶段收集类型信息. 重要的一步是
<strong>类型检查</strong></p>
<h2 id="中间代码生成-intermediate-code-generation">中间代码生成
Intermediate Code Generation</h2>
<p>中间代码设计原则</p>
<ul>
<li>容易生成</li>
<li>容易翻译为目标代码</li>
</ul>
<p>中间代码形式: 四元式, 三元式, 逆波兰式</p>
<ul>
<li>四元式: &lt;运算符, 操作数1, 操作数2, 结果&gt;</li>
</ul>
<h2 id="优化-optimization">优化 Optimization</h2>
<p>原则: <strong>等价变换</strong></p>
<p>主要方面: 公共子表达式的提取, 合并已知量, 删除无用语句, 循环优化</p>
<h2 id="目标代码生成-code-generation">目标代码生成 Code Generation</h2>
<p>将经过优化的中间代码转化为特定机器上的低级语言</p>
<p>目标代码的形式:</p>
<ul>
<li>绝对指令代码: 可立即执行的目标代码, 纯粹的0-1代码.</li>
<li>汇编指令代码: 汇编语言程序, 需要通过汇编程序汇编后才能运行,
能和物理机隔离.</li>
<li>可重定位指令代码: 先将各目标模块连接起来, 确定变量,
常数在主存中的位置, 装入主存后才能成为可以运行的绝对指令代码,
而后还需要进行 <strong>链接</strong>.</li>
</ul>
<h2 id="表格管理-symbol-table-management">表格管理 Symbol Table
Management</h2>
<p>用来记录源程序的各种信息和编译过程中的各种状况.</p>
<p>与编译前三段有关的表格有: 符号表, 常数表, 标号表, 分程序入口表,
中间代码表 <!-- 
### 符号表

| name | information |
|------|-------------|
| m | 整型, 变量地址 |
| n | 整型, 变量地址 |

### 常数表

|value|
|-----|
|1|
|4|

### 标号表

|name|information|
|----|-----------|
|xx|某句话|

*某句话是在 --></p>
<h2 id="错误处理-error-handler">错误处理 Error Handler</h2>
<p>如果源程序出错, 编译程序应该设法发现错误, 并报告给用户.</p>
<h2 id="其他概念">其他概念</h2>
<p><strong>趟/遍 pass</strong>: 将源程序从头到尾扫描一遍,
做相应的加工处理, 并生成相应的中间代码和目标代码.
多遍扫描可以节省内存空间, 提高目标代码质量, 使编译的逻辑结构更清楚,
但编译时间长, 因此 no free launch.</p>
<p>因此在一遍编译中:</p>
<p>源程序 -&gt; 编译程序 -&gt; 目标代码</p>
<p><strong>编译程序的编写</strong></p>
<ul>
<li>直接用机器语言</li>
<li>用汇编语言编写, 编译程序的核心部分常用汇编语言编写
<ul>
<li>编译程序怎么生成? 编译程序是用汇编语言编写的,
汇编语言经过汇编后即可生成编译程序(可执行),
再利用这个编译程序将自己的源代码变为目标代码.</li>
</ul></li>
<li>用高级语言编写, 普遍采用的方法.
<ul>
<li>例如用C语言写成的编译程序, 则先用C语言的编译器将C源程序编译为exe,
再用于分析其他语言, 也可以是C语言.</li>
</ul></li>
<li>自编译
<ul>
<li>先编写一个很小的编译程序的核心, 再由这个核心逐渐去分析,
编译其他代码.</li>
</ul></li>
<li>编译工具: LEX(词法分析), YACC(语法分析)</li>
<li>移植: 同种语言的编译程序在不同类型的机器之间移植</li>
</ul>
<h1 id="编译基础">编译基础</h1>
<p>高级语言是一个记号系统.</p>
<ul>
<li>语法</li>
<li>语义</li>
</ul>
<p><strong>语法</strong> 包括 <strong>词法规则</strong> 和
<strong>语法规则</strong></p>
<ul>
<li>词法规则: 判断每一个"单词"是否正确,
规定了哪些符号是是单词符号(最基本结构; 常数, 标识符, 基本字, 算符,
界限符等); 用正规式和有限自动机描述和分析</li>
<li>语法规则: 结合单词是否是语言中的语法单位(表达式),
规定如何用单词形成语法单位, 包括表达式, 子句, 语句, 函数, 过程,
程序等.</li>
</ul>
<p><strong>语义</strong> 给出单词符号和语法符号的意义,
大多数编译程序使用基于属性文法的语法制导翻译方法来分析语义.</p>
<p>重点是正规文法, 上下文无关文法及其对应的有限自动机和下推自动机.</p>
<h2 id="一些概念">一些概念</h2>
<p><strong>字母表</strong>: 符号的非空有穷集合, 用<span
class="math inline">\(V, \Sigma\)</span>表示.
所使用的符号均出自字符表.</p>
<p><strong>符号</strong>: 语言中最基本的不可再分的单位.</p>
<p><strong>符号串</strong>: 字符表中符号组成的有穷序列.
<strong>空串</strong> 用<span
class="math inline">\(\epsilon\)</span>表示.</p>
<p><strong>句子</strong>: 字母表上符合某种规则构成的串</p>
<p><strong>语言</strong>: 字母表上句子的集合</p>
<p>*小写字母表示符号, 大写字母表示集合, 希腊字母表示符号串.</p>
<h3 id="运算">运算</h3>
<p><strong>连接(乘积)运算</strong></p>
<p><span class="math display">\[
\begin{aligned}
  A &amp;= \{\alpha_1, \alpha_2, \cdots\} \\
  B &amp;= \{\beta_1, \beta_2, \cdots\} \\
  def:\quad AB &amp;= \{\alpha \beta | \alpha\in A\ and\ \beta\in B\}
\end{aligned}
\]</span> 其中<span class="math inline">\(A,B\)</span>是串集. 规定:
<span class="math inline">\(A^0=\{\epsilon\}\)</span>. 注意该运算
<strong>非可交换</strong>. 例子: <span
class="math inline">\(\alpha\)</span>表示<code>if ()</code>, <span
class="math inline">\(\beta\)</span>表示<code>then()</code>.</p>
<p><strong>闭包</strong></p>
<p><span class="math display">\[
A^\star=A^0\cup A^1 \cup A^2 \cup \cdots
\]</span></p>
<p>由A上所有符号组成的所有串的集合.</p>
<p><strong>正闭包</strong></p>
<p><span class="math display">\[
A^{+} = A^1 \cup A^2 \cup A^3 \cup \cdots = A^\star - {\epsilon}
\]</span></p>
<p><strong>文法</strong></p>
<p>描述语言的语法结构规则</p>
<ul>
<li><strong>非终结符</strong>: 出现在规则的左部,
用"&lt;&gt;"括起来或用大写字母表示, 表示一定语法概念的词, 用<span
class="math inline">\(V_N\)</span>表示</li>
<li><strong>终结符</strong>: 语言中不可以再分割的字符串, 用<span
class="math inline">\(V_T\)</span>表示</li>
<li><strong>开始符号</strong>: 表示所定义的语法范畴的非终结符,
表示该文法中最大的一个语法成分 (?比如说一个句子)</li>
<li><strong>产生式</strong>: 是用来定义符号串之间关系的一组语法规则,
<span class="math inline">\(A\rightarrow \alpha\)</span></li>
<li><strong>推导</strong>: 推导是从开始符号开始,
通过产生式的右部取代左部, 最终产生语言的一个句子的过程.
<ul>
<li><strong>最左推导</strong>: 每次使用一个规则,
以其右部取代符号串最左的非终结符.</li>
</ul></li>
<li><strong>归约</strong>: 推导的逆过程, 从给定的源语言的一个句子开始,
通过规则的左部取代右部, 最终达到开始符号的过程.
<ul>
<li><strong>最左归约</strong>: 最常采用</li>
</ul></li>
<li><strong>句型</strong>: 从文法的开始符号<span
class="math inline">\(S\)</span>开始,
每步推导(包括0步推导)所得到的字符串<span
class="math inline">\(\alpha\)</span>. 记作<span
class="math inline">\(S\rightarrow^\star \alpha, where\ \alpha\in (V_N
\cup V_T)^\star\)</span>
<ul>
<li><strong>句子</strong>: 仅含终结符的句型, 若能归约为开始符号,
则该句子是正确的</li>
</ul></li>
<li><strong>语言</strong>: 语言是由开始符号<span
class="math inline">\(S\)</span>通过1步或1步以上推导所得的句子的集合,
记为<span
class="math inline">\(L(G)=\{\alpha|S\rightarrow^+\alpha,\alpha\in
V_T^*\}\)</span></li>
<li><strong>文法规则的递归定义</strong>:
非终结符的定义中包含了非终结符自身</li>
</ul>
<h2 id="文法与语言的形式定义">文法与语言的形式定义</h2>
<p>Chomsky对文法的定义: 文法G是一个四元组<span
class="math inline">\((V_N, V_T, P, S)\)</span>, 其中<span
class="math inline">\(P\)</span>是文法规则的集合, <span
class="math inline">\(S\)</span>是开始符号</p>
<p><strong>0型文法</strong></p>
<p>又称短语文法或者无限制文法. <span
class="math inline">\(P\)</span>中产生式<span
class="math inline">\(\alpha\rightarrow\beta,\alpha\in V^+=(V_N\cup
V_T)^+\)</span>, <span
class="math inline">\(\alpha\)</span>至少含有一个非终结符,<span
class="math inline">\(\beta\in V^\star\)</span>.</p>
<ul>
<li>对产生式限制最少</li>
<li>图灵机</li>
<li>可递归可枚举</li>
</ul>
<p><strong>1型文法</strong></p>
<p><span class="math inline">\(P\)</span>中产生式<span
class="math inline">\(\alpha\rightarrow\beta\)</span>, 除可能有<span
class="math inline">\(S\rightarrow \epsilon\)</span>外均有<span
class="math inline">\(|\beta|\geq|\alpha|\)</span>, 若有<span
class="math inline">\(S\rightarrow\epsilon\)</span>, 规定<span
class="math inline">\(S\)</span>不能出现在产生式的右部.</p>
<p>等价定义: <span class="math inline">\(P\)</span>中产生式<span
class="math inline">\(\alpha\rightarrow\beta\)</span>除了可能有<span
class="math inline">\(S\rightarrow\epsilon\)</span>外均有<span
class="math inline">\(\alpha S \beta \rightarrow \alpha \gamma \beta,
\alpha, \beta \in V^\star, A\in V^n, \gamma\in V^+\)</span>.</p>
<hr />
<p>对非终结符进行替换时, 必须考虑上下文, 并且一般不允许替换为<span
class="math inline">\(\epsilon\)</span>, 除非是开始符号产生<span
class="math inline">\(\epsilon\)</span>.</p>
<hr />
<p><strong>2型文法</strong></p>
<p><span class="math inline">\(P\)</span>中产生式具有形式<span
class="math inline">\(A\rightarrow\beta, A\in V_N, \beta\in
V^\star\)</span>. 要求产生式左边只有一个非终结符.</p>
<p>不必考虑上下文, 上下文无关文法.</p>
<p>识别2型文法的自动机称为下推自动机</p>
<p><strong>3型文法</strong></p>
<p><span class="math inline">\(P\)</span>中产生式具有形式<span
class="math inline">\(A\rightarrow \alpha B, A\rightarrow
\alpha\)</span>或者<span class="math inline">\(A \rightarrow B\alpha,
A\rightarrow \alpha, A,B\in V_N, \alpha\in V_T^\star\)</span>.
也称为正规文法, (左|右)线性文法, 识别3型文法的自动机称为有限自动机.</p>
<hr />
<p>词法分析和语法分析中对产生式的限制: 1)不产生<span
class="math inline">\(P\rightarrow P\)</span>,
2)产生式中出现的任何非终结符必须有用, 能经过若干步推导出终结符</p>
<hr />
<p><strong>一些例子</strong></p>
<p><strong>例1</strong> 语言<span
class="math inline">\(L=\{\omega|\omega\in(a,b)^\star\)</span>且<span
class="math inline">\(\omega\)</span>中含有个数相同的<span
class="math inline">\(a,b\}\)</span>, 构造生成该语言的文法:</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow\epsilon \\
  S&amp;\rightarrow aA\\
  S&amp;\rightarrow bB\\
  A&amp;\rightarrow aAA | bS\\
  B&amp;\rightarrow aS | bBB
\end{align*}
\]</span></p>
<p>解释: 要么以<span class="math inline">\(a\)</span>开头, 要么以<span
class="math inline">\(b\)</span>开头, 后面跟着符号串. 对于符号串<span
class="math inline">\(A\)</span>, 如果以<span
class="math inline">\(b\)</span>开头, 则后面跟着<span
class="math inline">\(ab\)</span>个数相等的符号串, 如果仍然以<span
class="math inline">\(a\)</span>开头, 此时后面必须还要至少出现两次<span
class="math inline">\(b\)</span>.</p>
<p>或者</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow\epsilon\\
  S&amp;\rightarrow aSbS\\
  S&amp;\rightarrow bSaS
\end{align*}
\]</span></p>
<p>解释: 若以<span class="math inline">\(a\)</span>开头,
则在字符串的某个位置必然出现一个<span class="math inline">\(b\)</span>,
而这两个<span class="math inline">\(a,b\)</span>中间是<span
class="math inline">\(ab\)</span>个数相等的的字符串, b后面也是<span
class="math inline">\(ab\)</span>个数相等的符号串.</p>
<p><strong>例2</strong> 设<span class="math inline">\(L=\{\omega |
\omega\in(0,1)^\star\)</span>且<span
class="math inline">\(1\)</span>的个数为偶数个<span
class="math inline">\(\}\)</span>, 构造生成该语言的文法:</p>
<p>可以先列出看一下:</p>
<p><span class="math display">\[
\omega\in\{\epsilon, 0, 11, 011, 101, 110,\cdots\}
\]</span></p>
<p>然后:</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow\epsilon\\
  S&amp;\rightarrow 0S\\
  S&amp;\rightarrow 1A\\
  A&amp;\rightarrow 1S | 0A
\end{align*}
\]</span></p>
<h2 id="文法的构造与简化">文法的构造与简化</h2>
<h3 id="简化">简化</h3>
<p>同一语言可以产生不同的文法, 选择产生式最少,
最符合语言特征的文法来描述; 有些产生式对推导不起作用, 包括:
<strong>推导中永远用不到, 永远导不出终结符的, 形如<span
class="math inline">\(P\rightarrow P\)</span>的...</strong></p>
<p><strong>一些例子</strong></p>
<p><strong>例1</strong> 简化文法:</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow Be\\
  S&amp;\rightarrow Ee\\
  A&amp;\rightarrow Ae\\
  A&amp;\rightarrow e\\
  A&amp;\rightarrow A\\
  B&amp;\rightarrow Ce\\
  B&amp;\rightarrow Af\\
  C&amp;\rightarrow Cf\\
  D&amp;\rightarrow f
\end{align*}
\]</span></p>
<p>显然应该保留0236.</p>
<h3 id="构造">构造</h3>
<p><strong>构造无<span
class="math inline">\(\epsilon\)</span>产生式的上下文无关文法</strong></p>
<p>满足: <span class="math inline">\(P\)</span>中要么不含有<span
class="math inline">\(\epsilon\)</span>产生式, 要么只有<span
class="math inline">\(S\rightarrow\epsilon\)</span>, 且若<span
class="math inline">\(S\rightarrow\epsilon\)</span>, 则<span
class="math inline">\(S\)</span>不出现在任何产生式右部.</p>
<h1 id="语义分析与中间代码生成">语义分析与中间代码生成</h1>
<p><strong>在语法分析的过程中边分析边翻译,
翻译的结果是生成中间代码</strong></p>
<p><strong>语法制导翻译</strong>
在语法分析中调用语义翻译程序生成相应的中间代码,
使用CFG来引导对语言的翻译, 面向文法</p>
<ul>
<li>根据产生式右部符号进行翻译</li>
<li>依据语义子程序
<ul>
<li>语义子程序: 用于改变变量的值, 查填符号表, 发现源程序错误,
产生中间代码</li>
</ul></li>
</ul>
<p><span class="math display">\[
X \rightarrow \alpha \{语义子程序\}
\]</span></p>
<ul>
<li>具体做法: <strong>为每一个产生式配置一个语义子程序,
当语法分析进行归约或推导时调用相应的语义子程序</strong></li>
<li>注意: <strong>产生式中同一个符号出现多次, 需要区分,
加上角标</strong></li>
</ul>
<p><span class="math display">\[
E \rightarrow E_1 + E_2
\]</span></p>
<ul>
<li>语义值: <strong>需要为每个文法符号赋予不同的语义值</strong>, 如类型,
(符号表) 地址, 代码值 (不是数字), 并且
<strong>只有非终结符才有语义值</strong></li>
<li>语义栈: 各个符号的语义值放在语义栈中. 产生式进行归约时,
需对右部符号的语义值进行综合, 结果作为左部符号的语义值保存在语义栈中.
<strong>语义栈, 符号栈, 状态栈同步变化</strong></li>
</ul>
<p><strong>中间代码</strong> 转化为目标代码的中间生成的代码,
容易翻译</p>
<ul>
<li>形式
<ul>
<li>四元式: <span class="math inline">\(Operator, Op_1, Op_2,
Result\)</span>, 两个操作数和结果可以是用户自定义, 也可以是编译时变量.
变量采用的是符号表入口地址.</li>
<li>三元式: <span class="math inline">\(Operator, Op_1, Op_2\)</span>,
三元式本身就是结果, 以三元式的编号区别</li>
<li>逆波兰式 (后缀表示): <span class="math inline">\(Op_1, Op_2,
Operator\)</span>, 无括号, 从左到右扫描一遍</li>
<li>树形表示</li>
</ul></li>
</ul>
<h2 id="赋值语句-简单变量无数组-的翻译">赋值语句 (简单变量无数组)
的翻译</h2>
<p><strong>文法</strong>:</p>
<p>$$ A i = E \</p>
<p>E E + E | E * E | -E | (E) | i $$</p>
<p><strong>内置函数</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NEWTEMP  # 产生临时变量</span><br><span class="line">ENRTY(i)  # 获取变量i的符号表地址</span><br><span class="line">GEN(operator, op1, op2, result)  # 生成四元式中间代码</span><br></pre></td></tr></table></figure>
<p><strong>语义变量</strong>:</p>
<p><span class="math display">\[
E.PLACE
\]</span></p>
<ul>
<li>值是某个变量的符号表地址或临时变量的序号</li>
<li>分析过程需要就建立, 不需要就消亡</li>
</ul>
<p><strong>建立语法制导定义 (SDD)</strong>:</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>产生式</th>
<th>语义规则 (子程序)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(A \rightarrow i = E\)</span></td>
<td>{<span class="math inline">\(GEN(=, E.PLACE, NULL,
ENTRY(i))\)</span>}</td>
</tr>
<tr class="even">
<td><span class="math inline">\(E \rightarrow -E_1\)</span></td>
<td>{<span class="math inline">\(T = NEWTEMP; GEN(@, E_1.PLACE, NULL,
T); E.PLACE = T;\)</span>}</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(E \rightarrow E_1 * E_2\)</span></td>
<td>{<span class="math inline">\(T = NEWTEMP; GEN(*, E_1.PLACE,
E_2.PLACE, T); E.PLACE = T;\)</span>}</td>
</tr>
<tr class="even">
<td><span class="math inline">\(E \rightarrow E_1 + E_2\)</span></td>
<td>{<span class="math inline">\(T = NEWTEMP; GEN(+, E_1.PLACE,
E_2.PLACE, T); E.PLACE = T;\)</span>}</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(E \rightarrow (E_1)\)</span></td>
<td>{<span class="math inline">\(E.PLACE = E_1.PLACE\)</span>}</td>
</tr>
<tr class="even">
<td><span class="math inline">\(E \rightarrow i\)</span></td>
<td>{<span class="math inline">\(E.PLACE = ENTRY(i)\)</span>}</td>
</tr>
</tbody>
</table>
<h3 id="类型转换">类型转换</h3>
<p>处理混合运算, 如整型与实型运算, 最后的结果为实型</p>
<p><strong>语义变量</strong>:</p>
<p><span class="math display">\[
E.MODE
\]</span></p>
<p><strong>建立语法制导定义 (SDD)</strong>:</p>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th>产生式</th>
<th>语义规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(E \rightarrow E_1\ op\ E_2\)</span></td>
<td>{<span class="math inline">\(IF\ E_1.MODE = int\ AND\ E_2.MODE =
int\ THEN\ E.MODE = int\ ELSE\ E.MODE = real\)</span>}</td>
</tr>
</tbody>
</table>
<p>例如 <span class="math inline">\(X = Y + I * J\)</span>, 其中<span
class="math inline">\(X, Y\)</span>是实型的, <span
class="math inline">\(I, J\)</span>是整型的, 四元式为:</p>
<p><span class="math display">\[
(*_i, I, J, T_1) \\
(itr, T_1, NULL, T_2) \\
(+_r, Y, T_2, T_3) \\
(=, T_3, NULL, X)
\]</span></p>
<p>对运算符也要指出相应的类型.</p>
<h2 id="布尔表达式的翻译">布尔表达式的翻译</h2>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://Andrew-Rey.github.io"></a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://andrew-rey.github.io/2022/09/05/CS/Compiler-zh/">https://andrew-rey.github.io/2022/09/05/CS/Compiler-zh/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/CS/">CS</a>
            <a href="/tags/Compiler/">Compiler</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2022/10/12/Life/Code/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">今天又是码代码的一天呢</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2022/09/01/Android/AndroidBasic/">
        <span class="next-text nav-default">Android Basic</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:andrewrey.cc@gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/Andrew-Rey" class="iconfont icon-github" title="github"></a>
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/631454496" class="iconfont icon-bilibili-line" title="bilibili-line"></a>
        </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"></span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.1"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
