<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMakeTutorial</title>
    <url>/2022/08/10/CS/CMakeTutorial/</url>
    <content><![CDATA[<p>CMake version: 3.x</p>
<span id="more"></span>
<h1 id="command-line">Command Line</h1>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># (configure step) create build dir, and generate build/Makefile -&gt; generate Makefile</span><br>cmake -B build<br><br><span class="hljs-comment"># (build step) invoke building system and build the project in different OS -&gt; generate executable file</span><br>cmake --build build -j4<br><br><span class="hljs-comment"># invoke building system to execute target &quot;install&quot;</span><br>cmake --build build --<span class="hljs-keyword">target</span> <span class="hljs-keyword">install</span><br><br><span class="hljs-comment"># define configure variables, only use in configure step</span><br><span class="hljs-comment"># use -D</span><br><span class="hljs-comment"># set build type in configure step, the value will remain when invoked the second time unless delete build dir</span><br>cmake -B build -DCMAKE_BUILD_TYPE=Release<br><br><span class="hljs-comment"># Specify generator (generator: generate build system build rule from CMakeLists.txt)</span><br><span class="hljs-comment"># use -G</span><br><span class="hljs-comment"># generator Ninja, faster than Unix Makefile, generate *.ninja</span><br>cmake -B build -G Ninja<br></code></pre></td></tr></table></figure>
<h1 id="cmakelists.txt">CMakeLists.txt</h1>
<p><strong>add source file</strong></p>
<p>(1). single file: main.cpp</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC main.cpp)<br></code></pre></td></tr></table></figure>
<p>(2). multiple files: main.cpp | other.cpp | other.h</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC main.cpp other.cpp)<br></code></pre></td></tr></table></figure>
<p>or <strong>set</strong> a new variable</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">set</span>(sources main.cpp other.cpp other.h)  <span class="hljs-comment"># other.h can delete</span><br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>
<p>or use <strong>GLOB</strong> to search all files in current dir</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)  <span class="hljs-comment"># add CONFIGURE_DEPENDS to detect any change when next build</span><br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>
<p>when we have a dir structure:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">mylib<br>  +----*.cpp<br>  +----*.h<br>*.cpp<br>*.h<br></code></pre></td></tr></table></figure>
<p>no need to write all files:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># add all file in current dir and mylib dir</span><br><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">aux_source_directory</span>(. sources)<br><span class="hljs-keyword">aux_source_directory</span>(mylib sources)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>
<p>or use <strong>GLOB_RECURSE</strong> to find all files recursely:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main)<br><span class="hljs-keyword">file</span>(GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class="hljs-keyword">target_sources</span>(main PUBLIC <span class="hljs-variable">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>
<p><strong>ERROR</strong>: use GLOB_RECURSE will include *.cpp files in
build dir.</p>
<p><strong>solution</strong>: Add all source files in a dir named
src</p>
<h2 id="configure-variables">Configure variables</h2>
<p><strong>CMAKE_BUILD_TYPE</strong>: type of build,
<strong>Release</strong>, <strong>Debug</strong>,
<strong>MinSizeRel</strong> and <strong>RelWithDebInfo</strong>,
defualt: none (debug).</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br></code></pre></td></tr></table></figure>
<p>set default build type as Release to reach high performance: in the
first three lines:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> CMAKE_BUILD_TYPE)<br>    <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Specify version of cmake</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>)<br><br><span class="hljs-comment"># set c++ standard</span><br><span class="hljs-comment"># don&#x27;t modify CMAKE_CXX_FLAGS to add -std=c++17</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><br><span class="hljs-comment"># if use the needed CXX standard defined.</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)  <span class="hljs-comment"># OFF default</span><br><br><span class="hljs-comment"># prevent features GCC only</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-comment"># set project info</span><br><span class="hljs-keyword">project</span>(project_name LANGUAGES language_list(such as C CXX ASM...))<br></code></pre></td></tr></table></figure>
<h2 id="linkable-library">Linkable library</h2>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main mian.cpp mylib.cpp)<br></code></pre></td></tr></table></figure>
<p>or generate a static library</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib STATIC mylib.cpp)  <span class="hljs-comment"># create libmylib.a</span><br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>
<p>or generate dynamic lib</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>
<p>or use object lib, no *.a file, let CMake remember which objects
files are created</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylib OBJECT mylib.cpp)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>
<p>静态库问题: GCC会自行剔除没有引用符号的对象, 此时使用对象库避免,
从而不会自动剔除没引用到的对象文件, 绕开编译器不统一问题.
动态库也可以避免剔除没引用的对象文件, 但引入了运行时链接的麻烦.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># no specify variable in add_library()</span><br><span class="hljs-keyword">set</span>(BUILD_SHARED_LIBS <span class="hljs-keyword">ON</span>)  <span class="hljs-comment"># default OFF</span><br><br><span class="hljs-keyword">add_library</span>(mylib mylib.cpp)<br></code></pre></td></tr></table></figure>
<p><strong>HINT</strong> 静态库常常被认为直接链接到可执行文件上.
因此在动态库中不要链接静态库. 很呆. 地址会变.
当然<strong>解决方法</strong>是: 要么转化为对象库,
要么让静态库变成地址无关的代码PIC</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># set global property</span><br><span class="hljs-keyword">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">add_library</span>(otherlib STATIC otherlib.cpp)<br><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>
<p>or set local property</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># set local property</span><br><span class="hljs-keyword">add_library</span>(otherlib STATIC otherlib.cpp)<br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> otherlib PROPERTY POSITION_INDEPENDENT_CODE <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br>add_execuable(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>
<h2 id="attributes-of-objects">Attributes of objects</h2>
<p>设置单属性: <code>set_property(TARGET ... PROPERTY ...)</code>;</p>
<p>设置多属性:
<code>set_target_properties(file_name PROPERTIES properties_list)</code></p>
<p><strong>HINT</strong>:
以上命令在<code>add_executable</code>后有效.</p>
<p>设置全局属性 (改变属性的默认值): <code>set(CMAKE_XXX)</code>,
在<code>add_executable</code>前设置.</p>
<blockquote>
<p>如果需要在Windows下面使用动态库 (Windows对动态链接不友好),
则需要在定义和声明添加: <strong>Deffinition:</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span><br>__declspec(dllexport)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayy_hello</span><span class="hljs-params">()</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<strong>Declaration:</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span><br>__declspec(dllimport)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure> 然后CMakeLists.txt这样写:
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># In Main dir</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>)<br><span class="hljs-keyword">add_subdirectory</span>(mylib)  <span class="hljs-comment"># add sub module</span><br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main PUBLIC mylib)<br><br><span class="hljs-comment"># In sub module dir</span><br><span class="hljs-keyword">add_library</span>(mylib SHARED mylib.cpp mylib.h)<br></code></pre></td></tr></table></figure> 然后Windows极有可能会报错: 运行时找不到dll;
原因是dll和exe不在同一目录 (Windows只会查找exe所在目录和PATH). -
把dll添加到PATH环境变量 - 或者dll和dll其他的所有依赖dll,
全部拷贝到exe同一目录</p>
<p>这是因为CMake把main放在build下, 而mylib放在build/mylib/mylib.dll</p>
</blockquote>
<p>因此重定向输出路径, 改变mylib属性, 让.dll文件输出到
<strong>PROJECT_BINARY_DIR</strong> 里面. <figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_(DEBUG | RELEASE | NONE) | ARCHIVE_OUTPUT_DIRECTORY | LIBRARY_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)<br></code></pre></td></tr></table></figure></p>
<h2 id="externel-library">Externel library</h2>
<p>In Linux: feel free to link externel libraries. (/usr/lib/...) But
Windows can't. Linux can also include head file directly
(/usr/include/...).</p>
<p><strong>HINT:</strong> CMake 的分隔符永远是 "/", 即使是Windows,
CMake会自动转化.</p>
<p>More general method: <figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(package_name REQUIRED)<br></code></pre></td></tr></table></figure></p>
<p>没听懂, 以后补, 以后也不想补.</p>
<h2 id="variables-and-outputs">Variables and Outputs</h2>
<p>output some log infomation when running <code>cmake -B build</code>,
used for debugging. <figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;log info&quot;</span>)<br></code></pre></td></tr></table></figure></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;status info&quot;</span>)  <span class="hljs-comment"># -- prefix</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;warning info&quot;</span>)  <span class="hljs-comment"># yellow</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(SEND_ERROR <span class="hljs-string">&quot;error info&quot;</span>)  <span class="hljs-comment"># send error log but continue to run</span><br><br><span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;error info&quot;</span>)  <span class="hljs-comment"># print error and stop running</span><br></code></pre></td></tr></table></figure>
<h2 id="variable-and-cache">Variable and Cache</h2>
<p>重复执行<code>cmake -B build</code>: 第一次较慢,
将环境的检测存入缓存, 第二次以及以后直接查看缓存内容.
因此某些错误可以通过删除 <strong>./build/CMakeCache.txt</strong>解决.
当然也可以删了整个build文件夹重新编译, 慢一点而已.</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>Algorithm-FFT</title>
    <url>/2022/04/06/Algorithm/Algorithm-FFT/</url>
    <content><![CDATA[<p>"FFT是我见过最美的算法."</p>
<p>"说的好像你见过很多算法似的."</p>
<span id="more"></span>
<h1 id="多项式乘积问题">多项式乘积问题</h1>
<p>首先来思考这样的一个问题:</p>
<div class="note note-primary">
            <h3 id="question-1">Question 1</h3><p>你有两个多项式函数:</p><p><span class="math display">\[p(x)=2x^3+x+1\]</span></p><p><span class="math display">\[q(x)=x^2+4x+5\]</span></p><p>应该如何计算它们的乘积?</p>
          </div>
<p>当然, 我不是说要用笔算的方式, 而是用<strong>计算机</strong>.
显然这个问题我们在<a
href="https://space.bilibili.com/254463269/?spm_id_from=333.999.0.0">小学二年级</a>就写过的,
当初正在学习"数据结构"这门课, 如果没记错, 应该是用链表实现的.</p>
<p>但是, 就算是用链表实现, 那不也是和手算一样的原理吗?</p>
<ul>
<li>将二者相乘</li>
<li>分配律</li>
<li>合并同类项</li>
</ul>
<p>例如上面那个例子:</p>
<div class="note note-primary">
            <h3 id="solution-1">solution 1</h3><p><span class="math display">\[\begin{align*}    r(x) &amp;= (2x^3+x+1)(x^2+4x+5) \\    &amp;= 2x^5+8x^4+10x^3+x^3+4x^2+5x+x^2+4x+5 \\    &amp;= 2x^5+8x^4+11x^3+5x^2+5x+5\end{align*}\]</span></p>
          </div>
<p>(<strong>???是什么动力让我深夜在这里口算多项式乘法???</strong>)</p>
<p>显然, 如果一个 n 次多项式乘上一个 m 次多项式, 在合并同类项前应该有
<span class="math inline">\(n\times m\)</span> 次多项式, 这谁顶得住?
对于正常人类而言显然顶不住, 对于计算机而言, 时间复杂度是<span
class="math inline">\(O(n^2)\)</span>, 也是算比较大的开销了吧.</p>
<p>咋办?</p>
<h1 id="点表示法">点表示法</h1>
<h2 id="开始">开始</h2>
<p>有谁规定, 我多项式一定是用系数表示的?</p>
<p>好家伙, 你这样说我就摸不着头脑了,
难道除了系数表示还有其他表示方法吗?</p>
<p>首先, 多项式集合其实是构成了一个<strong>线性空间</strong>, 也就是说,
任意两个多项式进行线性运算 (加法和数乘) 后, 结果仍然是多项式. 事实上</p>
<p><span class="math display">\[
{1, x, x^2, \dots, x^n, \dots}
\]</span></p>
<p>构成了该空间的一组基, 将函数展开成 Taylor 级数便用了这组基作为基底,
基前面的系数也就是<strong>坐标</strong>.</p>
<p>其次, 对于一个 n 次多项式而言, 只要我们确定了它的坐标,
就能唯一确定这个多项式. <strong>现在的问题是不知道坐标,
如何确定多项式.</strong> 这里的巧妙之处就在于, 多项式函数是一个映射,
对于一个特定的 x, 总是能给出唯一一个值与之对应, 这不就是一个方程吗?</p>
<p>我给你一个 x, 你输出一个值, 同时由于多项式系数全部未知,
这就是一个关于 <span class="math inline">\(n+1\)</span> 个系数的方程</p>
<p>显然, 我需要 <span class="math inline">\(n+1\)</span>
个不同的点来唯一确定我的系数. 这就是所谓的点表示法. 这样一来, 我们将这
<span class="math inline">\(n+1\)</span> 个方程写成矩阵形式:</p>
<p><span class="math display">\[
\begin{bmatrix}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{bmatrix}
=
\begin{bmatrix}
1\quad &amp; x_0\quad &amp; \dots\quad &amp; x_0^n \\
1\quad &amp; x_1\quad &amp; \dots\quad &amp; x_1^n \\
\vdots\quad &amp; \vdots\quad &amp; \quad &amp; \vdots \\
1\quad &amp; x_n\quad &amp; \dots\quad &amp; x_n^n
\end{bmatrix}
\begin{bmatrix}
c_0 \\
c_1 \\
\vdots \\
c_n
\end{bmatrix}
\]</span></p>
<p>看到这里我终于理解了为什么在学高等代数时要突然讲一个<strong>范德蒙德(Vandermonde)行列式</strong>,
也就是这里的</p>
<p><span class="math display">\[
\left[
\begin{aligned}
1\quad &amp; x_0\quad &amp; \dots\quad &amp; x_0^n \\
1\quad &amp; x_1\quad &amp; \dots\quad &amp; x_1^n \\
\vdots\quad &amp; \vdots\quad &amp; \quad &amp; \vdots \\
1\quad &amp; x_n\quad &amp; \dots\quad &amp; x_n^n
\end{aligned}
\right]
\]</span></p>
<p>将上述矩阵定义为我们最喜欢的字母<span
class="math inline">\(A\)</span>.</p>
<p>好, 既然这东西是范德蒙德行列式, 那我们可以知道它行列式<span
class="math inline">\(|A|=\prod_{0\leq j&lt; i\leq
n}(x_i-x_j)\)</span>不为 0, 也就是说, 这个矩阵是可逆的, 也就是当我们取
<span class="math inline">\(n+1\)</span> 个不同点时,
确实是可以使方程组有唯一解, 也就是 <strong><span
class="math inline">\(n+1\)</span> 个点可以唯一表示一个 n
次多项式.</strong></p>
<h2 id="乘法">乘法</h2>
<p><strong>问题来了, 如何做乘法?</strong></p>
<p>我们有 n 次多项式和 m 次多项式做乘法, 得到的是一个 <span
class="math inline">\(n+m\)</span> 次多项式, 那么我们只要找到 <span
class="math inline">\(n+m+1\)</span> 个点即可, 也就是只要在 n 次多项式和
m 次多项式中分别找 <span class="math inline">\(n + m + 1\)</span> 个点,
<strong>这些点的横坐标 x 相等</strong>, 再将对应的函数值相乘即可.</p>
<h2 id="进一步">进一步</h2>
<p>现在, 我们知道了如何用点表示多项式, 以及如何用点表示进行乘法运算.
但是仔细一想, 这种方法需要求解线性方程组, 这里的计算复杂度并不低.
也就是从系数表示法到点表示法的转化过程带来的计算复杂度还是很高的.</p>
<p>有什么方法可以进行简化吗?</p>
<p>先等一等, 我们先来梳理我们用点表示求多项式乘法的思路:</p>
<div class="note note-primary">
            <h3 id="mainidea">MainIdea</h3><ul><li>将 n 次多项式和 m 次多项式分别从系数表示转化为点表示</li><li>对应点相乘</li><li>将得到的 <span class="math inline">\(n+m+1\)</span>个点表示的多项式转化为系数表示</li></ul>
          </div>
<h2 id="奇偶">奇偶</h2>
<p>先来考虑简单的情况: <div class="note note-primary">
            <h3 id="question-2">Question 2</h3><p>多项式</p><p>$ p(x) = x^2 $</p><p>和多项式</p><p>$ q(x)=x^3 $</p><p>用点表示法相乘</p>
          </div></p>
<p>那我们当然是按部就班地进行乘法啦~ - 由于结果是 5 次多项式,
因此对<span class="math inline">\(p(x)\)</span>取 5 个点, 对<span
class="math inline">\(q(x)\)</span>取 5 个点.</p>
<p><strong>取点</strong>, 说得轻巧, 做起来倒是挺犹豫的.
取什么样的点能满足要求呢? 或者<del>得寸进尺地</del>说,
什么样的点能让效率更高呢? <strong>注意到二次函数是对称的</strong>,
那我们是不是只要取正的 2 个点, 就能知道负的 2 个点, 另外加一个原点?</p>
<p>确实如此.</p>
<p>那三次多项式呢? 照理来说,
我们同样也是只要取一半的点就能知道另一半点的值(这里的"一半"针对正负而言),
只不过要在函数值上添加负号, 何必呢? 还不如干脆 <strong>提出一个
x</strong>, 然后不也变成了二次函数?</p>
<p>事实上, 一般而言, 我们要用点表示法表示多项式, 可以用如下方法:
<div class="note note-primary">
            <h3 id="method1">Method1</h3><p><span class="math display">\[p(x)=\sum_{i=1}^n c_ix^i=P_e(x)+P_o(x)=P_{e1}(x)+xP_{e2}(x)\]</span> 其中, <spanclass="math inline">\(P_{ei}(x)\)</span>表示只含偶次的多项式函数, <spanclass="math inline">\(P_o(x)\)</span>表示只含奇次的多项式.</p>
          </div></p>
<p>这样, 我们只要在非负轴上取值就可以确定整个多项式, 取点的个数是
<strong>原来的一半</strong>.</p>
<p>甚至, 这里形成了一个 <strong>递归</strong> 算法: 分解后的<span
class="math inline">\(P_{ei}(x)\)</span>不也是一个关于 x 的多项式吗?!
那我继续啊, 把<span class="math inline">\(P_{ei}(x)\)</span>继续分解啊,
<strong>大事化小, 小事化了.</strong></p>
<p><strong>等等!</strong></p>
<p>我们的<span class="math inline">\(P_{ei}(x)\)</span>其实是<span
class="math inline">\(P_{ei}(x^2)\)</span>, 这里每个<span
class="math inline">\(x^2\)</span>都是<strong>非负的</strong>啊.
未来我们只能在非负轴取值了, 也就是说, 分解为偶次多项式后,
<strong>递归停止了</strong>.</p>
<p>完蛋.</p>
<h1 id="复数域分解">复数域分解</h1>
<p>"山重水复疑无路, 柳暗花明又一村"</p>
<p>看到标题就已经知道要怎么做了. 既然在实数域上无法继续分解<span
class="math inline">\(P_{ei}(x^2)\)</span>,
那为何不去<strong>复数域</strong>呢?</p>
<p>在复数域上我们可以快乐地进行递归.</p>
<p>如何个快乐法呢? 我们来细品: <div class="note note-primary">
            <h3 id="偶次多项式在复平面上的根">偶次多项式在复平面上的根</h3><p>为什么突然变成了 <strong>求根</strong>?</p><p>从第二节中"奇偶", 我们可以选取对称的点,来减少选取点的个数(即原来的一半). 接着我们把任意 n次多项式分解成两个偶次多项式, 偶次多项式的好处在于容易选取对称的点.但是由于在实数范围内, 在对偶次多项式进行递归时会发生中断,于是我们扩展至复数域讨论分解.</p><p><strong>方便起见</strong>: 对于<spanclass="math inline">\(x^0\)</span>, 我们取<spanclass="math inline">\(x=1\)</span>作为特征点, 对于<spanclass="math inline">\(x^2\)</span>, 我们取<spanclass="math inline">\(x=1, x=-1, x=0\)</span>作为三个特征点, 那对于<spanclass="math inline">\(x^4\)</span>, 我们应该怎样取点, 抛开<spanclass="math inline">\(x=0\)</span>不谈, 令<spanclass="math inline">\(x^4=1\)</span>, 由 <strong>代数基本定理</strong>,该方程在复数域上有 4 个 <strong>根</strong>,对于其它偶次多项式我们以此类推.</p><p>就这样, 我们找到了一个简单的方法寻找所有需要的点, 进行递归.</p><h3 id="单位根">单位根</h3><p>写到这里, 我也感觉有点吃力, 关键是为什么一定就取了令<spanclass="math inline">\(x^{2k}=1\)</span>呢?</p><p>虽然但是, 确实是所谓的"<strong>方便起见</strong>", 这是因为, 取了"1",我们可以在复平面上的单位圆上讨论这个问题.</p><p>在<ahref="https://space.bilibili.com/254463269/?spm_id_from=333.999.0.0">小学二年级</a>我们就知道,<span class="math inline">\(x^{n}=1\)</span>的根可以用我们熟悉的<spanclass="math inline">\(\omega\)</span>的幂来表示, 即 <spanclass="math display">\[\omega = e^{\frac{2k\pi}{n}i}\qquad(k=0,1,\dots,n-1)\]</span> 这些<span class="math inline">\(n\)</span>个点在复平面单位圆上<strong>对称分布</strong>. 每递归一次, 单位根的数量减少一半,但保持对称性不变.</p><p>确实方便.</p>
          </div></p>
<h1 id="快速傅里叶变换fft">快速傅里叶变换(FFT)</h1>
<p>终于能正式地介绍世界上最美丽的算法了:
<strong>快速傅里叶变换(FFT)</strong>.
FFT解决的是多项式从系数表示到点表示的过程中, 计算复杂度的问题.</p>
<h2 id="框架">框架</h2>
<p><strong>分解:</strong></p>
<p><span class="math display">\[
p(x)=\sum_{k=0}^nc_kx^k=P_{e1}(x^2)+xP_{e2}(x^2):=[ \omega^0, \omega^1,
\dots, \omega^n]
\]</span></p>
<p><strong>递归:</strong></p>
<p><span class="math display">\[
P\_{e1}(x^2) = P^{\prime}\_{e1}(x^4)+xP^{\prime}\_{e2}(x^4):=[\omega^0,
\omega^1, \dots, \omega^{n-1}]
\]</span></p>
<p><span class="math display">\[
P\_{e2}(x^2) = P^{\prime}\_{e1}(x^4)+xP^{\prime}\_{e2}(x^4):=[\omega^0,
\omega^1, \dots, \omega^{n-1}]
\]</span></p>
<p><strong>加和:</strong> <span class="math display">\[
P(\omega^j)=P\_{e1}(\omega^{j})+\omega^jP\_{e2}(\omega^j)
\]</span></p>
<p><span class="math display">\[
P(\omega^{j+n/2})=P\_{e1}(\omega^{j+n/2})+\omega^{j+n/2}P\_{e2}(\omega^{j+n/2})
\]</span></p>
<p><span class="math inline">\(j\in[0,1,\dots, n/2+1]\)</span></p>
<p><strong>返回</strong><span class="math inline">\(p(x)\)</span></p>
<p>时间复杂度为: <span class="math inline">\(O(nlog_2n)\)</span></p>
<h2 id="一些数学">一些数学</h2>
<div class="note note-primary">
            <p>对于 n 次多项式 <span class="math inline">\(p(x)=\sum_{k=0}^nc_kx^k\)</span>, 我们给定<span class="math inline">\(n+1\)</span>个点:<span class="math inline">\(x_0, \dots, x_n\)</span>,从而得到关于原多项式 <span class="math inline">\(n+1\)</span>个系数的线性方程组:</p><p><span class="math display">\[\left[\begin{aligned}p_0 \\p_1 \\\vdots \\p_n\end{aligned}\right]=\left[\begin{aligned}1\quad &amp; x_0\quad &amp; \dots\quad &amp; x_0^n \\1\quad &amp; x_1\quad &amp; \dots\quad &amp; x_1^n \\\vdots\quad &amp; \vdots\quad &amp; \quad &amp; \vdots \\1\quad &amp; x_n\quad &amp; \dots\quad &amp; x_n^n\end{aligned}\right]\left[\begin{aligned}c_0 \\c_1 \\\vdots \\c_n\end{aligned}\right]\]</span></p><p>我们在复数域上考虑, 令 <span class="math display">\[x_k=\omega^k,\quad where\ \ \omega=e^{\frac{2k\pi}{n}}\]</span> (这是因为, 我们希望多项式在复数域上考虑时,我们可以在单位圆周上讨论. 其中<spanclass="math inline">\(x_k\)</span>表示我们取的第 k 个点, 刚好与 <spanclass="math inline">\(\omega^k\)</span>是对应的.)</p><p>则线性方程组可以化为:</p><p><span class="math display">\[\left[\begin{aligned}p_0 \\p_1 \\\vdots \\p_n\end{aligned}\right]=\left[\begin{aligned}[c]1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;\dots\quad &amp; 1 \\1\quad      &amp; \omega\quad   &amp; \omega^2\quad          &amp;\dots\quad &amp; \omega^n \\1\quad      &amp; \omega^2\quad &amp; \omega^4\quad          &amp;\dots\quad &amp; \omega^{2n} \\\vdots\quad &amp; \vdots\quad   &amp;\vdots\quad       &amp;            &amp; \vdots \\1\quad      &amp; \omega^n\quad &amp; \omega^{2n}\quad  &amp; \dots\quad&amp; \omega^{n\times n}\end{aligned}\right]\left[\begin{aligned}c_0 \\c_1 \\\vdots \\c_n\end{aligned}\right]\]</span></p><p>其中</p><p><span class="math display">\[\left[\begin{aligned}[c]1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;\dots\quad &amp; 1 \\1\quad      &amp; \omega\quad   &amp; \omega^2\quad          &amp;\dots\quad &amp; \omega^n \\1\quad      &amp; \omega^2\quad &amp; \omega^4\quad          &amp;\dots\quad &amp; \omega^{2n} \\\vdots\quad &amp; \vdots\quad   &amp;\vdots\quad       &amp;            &amp; \vdots \\1\quad      &amp; \omega^n\quad &amp; \omega^{2n}\quad  &amp; \dots\quad&amp; \omega^{n\times n}\end{aligned}\right]\]</span> 称为<strong>离散傅里叶变换矩阵(DFT)</strong>显然该矩阵是<strong>对称的</strong> 且 <strong>可逆</strong>, 其逆矩阵为: <spanclass="math display">\[\frac{1}{n}\left[\begin{aligned}[c]1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;\dots\quad &amp; 1 \\1\quad      &amp; \omega^{-1}\quad   &amp;\omega^{-2}\quad          &amp; \dots\quad &amp; \omega^{-n} \\1\quad      &amp; \omega^{-2}\quad &amp; \omega^{-4}\quad          &amp;\dots\quad &amp; \omega^{-2n} \\\vdots\quad &amp; \vdots\quad   &amp;\vdots\quad       &amp;            &amp; \vdots \\1\quad      &amp; \omega^{-n}\quad &amp; \omega^{-2n}\quad  &amp;\dots\quad &amp; \omega^{-n\times n}\end{aligned}\right]   \]</span></p><p>并且, 该逆矩阵看起来和原矩阵 <strong>一模一样!</strong> .</p>
          </div>
<h2 id="结束了">结束了?</h2>
<p>当我们乐呵呵地把FFT转化为代码时, 开心的分解多项式, 然后选点, 相乘,
<strong>等等!</strong> 你还没告诉我, 怎么从点表示转化回系数表示呢!</p>
<p>这就是FFT<strong>对称</strong>的魅力了. 由点求系数,
不过是矩阵求逆的过程:</p>
<p><span class="math display">\[
\left[
\begin{aligned}
c_0 \\
c_1 \\
\vdots \\
c_n
\end{aligned}\right]
=
\left[
\begin{aligned}[c]
1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;
\dots\quad &amp; 1 \\
1\quad      &amp; \omega\quad   &amp; \omega^2\quad          &amp;
\dots\quad &amp; \omega^n \\
1\quad      &amp; \omega^2\quad &amp; \omega^4\quad          &amp;
\dots\quad &amp; \omega^{2n} \\
\vdots\quad &amp; \vdots\quad   &amp;
\vdots\quad       &amp;            &amp; \vdots \\
1\quad      &amp; \omega^n\quad &amp; \omega^{2n}\quad  &amp; \dots\quad
&amp; \omega^{n\times n}
\end{aligned}
\right]^{-1}
\left[
\begin{aligned}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{aligned}\right] \\
=\frac{1}{n}
\left[
\begin{aligned}[c]
1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;
\dots\quad &amp; 1 \\
1\quad      &amp; \omega^{-1}\quad   &amp;
\omega^{-2}\quad          &amp; \dots\quad &amp; \omega^{-n} \\
1\quad      &amp; \omega^{-2}\quad &amp; \omega^{-4}\quad          &amp;
\dots\quad &amp; \omega^{-2n} \\
\vdots\quad &amp; \vdots\quad   &amp;
\vdots\quad       &amp;            &amp; \vdots \\
1\quad      &amp; \omega^{-n}\quad &amp; \omega^{-2n}\quad  &amp;
\dots\quad &amp; \omega^{-n\times n}
\end{aligned}
\right]
\left[
\begin{aligned}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{aligned}\right]
\]</span></p>
<p>显然, 由于DFT和DFT逆矩阵具有相似的形式,
我们完全可以用<strong>同一个函数</strong>完成快速傅里叶的正反变换!</p>
<h1 id="后记-对称-万变不离其宗">后记-"对称, 万变不离其宗"</h1>
<p>不会真有人会把这个没有图的文章看完吧?</p>
<p>相信我, 日后在这里补充图片的概率为 <span class="math display">\[
p=lim_{x\rightarrow\infty}xsin (1/x)
\]</span> (糟糕, 好像出简单了)</p>
<p>另外, 在递归的地方, 觉得并没有讲清楚具体的步骤, 但是思想到位了.
日后也不想改了. 可能以后补一补应用场景之类的, 至于代码, 看情况吧.</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>AndroidBasic</title>
    <url>/2022/09/01/Android/AndroidBasic/</url>
    <content><![CDATA[<p>"我只是想学kotlin而已"</p>
<p>"我不理解"</p>
<span id="more"></span>
<h1 id="android-studio">Android Studio</h1>
<p>一开始用的是Intelij IDEA, 后来觉得Android Studio挺香的.
当然前提是有JDK, Studio的话, 下载很快, 然后安装路径自选, 但是
<strong>注意在提示没有安装SDK的时候, 选择CANCEL</strong>,
安装完成后直接启动它.</p>
<p>这时候会提示你没有安装SDK, 并且会告诉你安装哪些东西,
只要选择安装路径即可, 等待片刻.</p>
<p>在<code>create device</code>里面, 可以新建<code>device</code>,
然后我新建了一个和我手机屏幕一样大的安卓虚拟机, 内存之类的看情况选,
没什么感觉.</p>
<h1 id="组件">组件</h1>
<h2 id="activity">Activity</h2>
<p>用于显示用户界面, 用户通过Activity交互完成相关操作,
一个APP可以有多个Activity</p>
<h1 id="布局">布局</h1>
<h2 id="linear-layout">Linear Layout</h2>
<p>比较常用的属性:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">android:id<br>android:layout_width<br>android:layout_height<br>android:background<br>android:layout_margin<br>android:layout_padding<br>android:layout_orientation<br>android:gravity  <span class="hljs-comment">&lt;!--相对位置--&gt;</span><br>android:layout_weight  <span class="hljs-comment">&lt;!--将剩余内容平分--&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="relative-layout">Relative Layout</h2>
<p>比较常用的属性:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">android:layout_toLeftOf<br>androidLlayout_toRightOf<br>android:alignBottom<br>android:alignParentBottom<br>android:layout_below<br></code></pre></td></tr></table></figure>
<h1 id="控件">控件</h1>
<h2 id="text-view">Text View</h2>
<p>可以实现 <strong>文字大小, 颜色; 显示不下时使用...; 文字加icon;
中划线, 下划线; 跑马灯</strong></p>
<p><code>kotlin</code>实现中划线要重写扩展方法<code>apply()</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">my_text_view.apply &#123;<br>    paintFlags = paintFlags or Paint.STRIKE_THRU_TEXT_FLAGS or Paint.ANTI_ALIAS_FLAG<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="material-button">Material Button</h2>
<p>谷歌给的<code>Button</code>控件, 继承了之前的<code>Button</code></p>
<p>需要在<code>app/build.gradle</code>中添加依赖:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">implementation <span class="hljs-keyword">group</span>: <span class="hljs-string">&#x27;com.google.android.material&#x27;</span>, name: <span class="hljs-string">&#x27;material&#x27;</span>, version: <span class="hljs-string">&#x27;1.4.0&#x27;</span><br></code></pre></td></tr></table></figure>
<p>还需要更换谷歌它指定的样式主题,
在<code>values/theme.xml</code>中将主题改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">Theme.MaterialComponents.Light.NoActionBar<br></code></pre></td></tr></table></figure>
<p>同步后便可以使用谷歌的<code>MaterialButton</code>, 不过为了修改属性,
用到了<code>app</code>和<code>tool</code>,
因此在相应的<code>activity</code>文件头添加:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br>xmlns:tools=&quot;http://schemas.android.com/tools&quot;<br></code></pre></td></tr></table></figure>
<p>以示礼貌</p>
<p><strong>重点</strong></p>
<p>按钮又不是摆设, 所以要设计相应的页面跳转,
也就是需要实现相应的<code>clickListener</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> ...</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mBtn: MaterialButton<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> onCreate ...</span><br><br>        mBtn = findViewById(R.id.button_name)<br>        mBtn.setOnClickListener() &#123;<br>            startActivity(Intent(<span class="hljs-keyword">this</span>, OtherActivity::<span class="hljs-keyword">class</span>.java))<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>接着是颜值比较高的选择栏设计:</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Compiler-zh</title>
    <url>/2022/09/05/CS/Compiler-zh/</url>
    <content><![CDATA[<p>“编译原理网课”</p>
<p>“B站大学不用交学费!!!”</p>
<span id="more"></span>
<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><p><strong>编译</strong>: 由高级语言转化为低级语言</p>
<p><strong>解释</strong>: 接受高级语言的 <strong>一个语句输入</strong>, 进行解释并执行, 立刻得到执行结果, 然后再接受下一句.</p>
<ul>
<li>不产生目标文件, 直观易懂, 结构简单, 易于人机对话</li>
<li>但效率低: 没有目标文件, 每次运行相当于要重新解释</li>
</ul>
<p><strong>编译的两个转换形式</strong></p>
<ul>
<li>编译 - 运行<ul>
<li>先编译产生机器语言, 生成目标文件(.exe), 在运行时添加参数</li>
</ul>
</li>
<li>编译 - 汇编 - 运行<ul>
<li>编译后产生汇编语言, 生成目标文件(.obj), 汇编语言汇编后产生机器语言</li>
</ul>
</li>
</ul>
<p><strong>编译过程</strong></p>
<p>源程序 -&gt; Lexical analyzer -&gt; Syntax analyzer -&gt; Semmantic Analyzer -&gt; Intermediate code generation -&gt; Optimization -&gt; Code generation -&gt; Target</p>
<p>symbol table management, error handler</p>
<h2 id="词法分析-Lexical-Analysis"><a href="#词法分析-Lexical-Analysis" class="headerlink" title="词法分析 Lexical Analysis"></a>词法分析 Lexical Analysis</h2><p>扫描源程序, 识别一个个 <strong>单词lexeme</strong>, 并进行 <strong>分类token</strong> (包括: keyword, constant, identifier, operator, separator). 转化后的格式为 <token-name, attr-value>, 前者为token, 后者为 <strong>指向符号表的指针</strong>.</p>
<p>描述词法规则的有效工具是 <strong>正规式</strong>和<strong>有限自动机</strong></p>
<h2 id="语法分析-Syntax-Analysis"><a href="#语法分析-Syntax-Analysis" class="headerlink" title="语法分析 Syntax Analysis"></a>语法分析 Syntax Analysis</h2><p>把单词符号组成各类各类的语法单位, 如短语, 句子, 过程, 程序等</p>
<p>方法: </p>
<ul>
<li>derive:<ul>
<li>最右推导: 每次将最右的部分按照规则进行转化</li>
<li>最左推导:</li>
</ul>
</li>
<li>reduce: 推导的逆过程<ul>
<li>最左归约: 最右推导的逆过程</li>
<li>最右归约: 最左推导的逆过程</li>
</ul>
</li>
</ul>
<p>计算机处理方法: <strong>语法树</strong></p>
<h2 id="语义分析-Semmantic-Ananlysis"><a href="#语义分析-Semmantic-Ananlysis" class="headerlink" title="语义分析 Semmantic Ananlysis"></a>语义分析 Semmantic Ananlysis</h2><p>审查源程序有无语义错误, 为代码生成阶段收集类型信息. 重要的一步是 <strong>类型检查</strong></p>
<h2 id="中间代码生成-Intermediate-Code-Generation"><a href="#中间代码生成-Intermediate-Code-Generation" class="headerlink" title="中间代码生成 Intermediate Code Generation"></a>中间代码生成 Intermediate Code Generation</h2><p>中间代码设计原则</p>
<ul>
<li>容易生成</li>
<li>容易翻译为目标代码</li>
</ul>
<p>中间代码形式: 四元式, 三元式, 逆波兰式</p>
<ul>
<li>四元式: &lt;运算符, 操作数1, 操作数2, 结果&gt;</li>
</ul>
<h2 id="优化-Optimization"><a href="#优化-Optimization" class="headerlink" title="优化 Optimization"></a>优化 Optimization</h2><p>原则: <strong>等价变换</strong></p>
<p>主要方面: 公共子表达式的提取, 合并已知量, 删除无用语句, 循环优化</p>
<h2 id="目标代码生成-Code-Generation"><a href="#目标代码生成-Code-Generation" class="headerlink" title="目标代码生成 Code Generation"></a>目标代码生成 Code Generation</h2><p>将经过优化的中间代码转化为特定机器上的低级语言</p>
<p>目标代码的形式:</p>
<ul>
<li>绝对指令代码: 可立即执行的目标代码, 纯粹的0-1代码.</li>
<li>汇编指令代码: 汇编语言程序, 需要通过汇编程序汇编后才能运行, 能和物理机隔离.</li>
<li>可重定位指令代码: 先将各目标模块连接起来, 确定变量, 常数在主存中的位置, 装入主存后才能成为可以运行的绝对指令代码, 而后还需要进行 <strong>链接</strong>.</li>
</ul>
<h2 id="表格管理-Symbol-Table-Management"><a href="#表格管理-Symbol-Table-Management" class="headerlink" title="表格管理 Symbol Table Management"></a>表格管理 Symbol Table Management</h2><p>用来记录源程序的各种信息和编译过程中的各种状况.</p>
<p>与编译前三段有关的表格有: 符号表, 常数表, 标号表, 分程序入口表, 中间代码表<br>&lt;!— </p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th>information</th>
</tr>
</thead>
<tbody>
<tr>
<td>m</td>
<td>整型, 变量地址</td>
</tr>
<tr>
<td>n</td>
<td>整型, 变量地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常数表"><a href="#常数表" class="headerlink" title="常数表"></a>常数表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
<tr>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<h3 id="标号表"><a href="#标号表" class="headerlink" title="标号表"></a>标号表</h3><div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th>information</th>
</tr>
</thead>
<tbody>
<tr>
<td>xx</td>
<td>某句话</td>
</tr>
</tbody>
</table>
</div>
<p>*某句话是在 —&gt;</p>
<h2 id="错误处理-Error-Handler"><a href="#错误处理-Error-Handler" class="headerlink" title="错误处理 Error Handler"></a>错误处理 Error Handler</h2><p>如果源程序出错, 编译程序应该设法发现错误, 并报告给用户.</p>
<h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><p><strong>趟/遍 pass</strong>: 将源程序从头到尾扫描一遍, 做相应的加工处理, 并生成相应的中间代码和目标代码. 多遍扫描可以节省内存空间, 提高目标代码质量, 使编译的逻辑结构更清楚, 但编译时间长, 因此 no free launch.</p>
<p>因此在一遍编译中:</p>
<p>源程序 -&gt; 编译程序 -&gt; 目标代码</p>
<p><strong>编译程序的编写</strong></p>
<ul>
<li>直接用机器语言</li>
<li>用汇编语言编写, 编译程序的核心部分常用汇编语言编写<ul>
<li>编译程序怎么生成? 编译程序是用汇编语言编写的, 汇编语言经过汇编后即可生成编译程序(可执行), 再利用这个编译程序将自己的源代码变为目标代码.</li>
</ul>
</li>
<li>用高级语言编写, 普遍采用的方法.<ul>
<li>例如用C语言写成的编译程序, 则先用C语言的编译器将C源程序编译为exe, 再用于分析其他语言, 也可以是C语言.</li>
</ul>
</li>
<li>自编译<ul>
<li>先编写一个很小的编译程序的核心, 再由这个核心逐渐去分析, 编译其他代码.</li>
</ul>
</li>
<li>编译工具: LEX(词法分析), YACC(语法分析)</li>
<li>移植: 同种语言的编译程序在不同类型的机器之间移植</li>
</ul>
<h1 id="编译基础"><a href="#编译基础" class="headerlink" title="编译基础"></a>编译基础</h1><p>高级语言是一个记号系统. </p>
<ul>
<li>语法</li>
<li>语义</li>
</ul>
<p><strong>语法</strong> 包括 <strong>词法规则</strong> 和 <strong>语法规则</strong></p>
<ul>
<li>词法规则: 判断每一个”单词”是否正确, 规定了哪些符号是是单词符号(最基本结构; 常数, 标识符, 基本字, 算符, 界限符等); 用正规式和有限自动机描述和分析</li>
<li>语法规则: 结合单词是否是语言中的语法单位(表达式), 规定如何用单词形成语法单位, 包括表达式, 子句, 语句, 函数, 过程, 程序等.</li>
</ul>
<p><strong>语义</strong> 给出单词符号和语法符号的意义, 大多数编译程序使用基于属性文法的语法制导翻译方法来分析语义.</p>
<p>重点是正规文法, 上下文无关文法及其对应的有限自动机和下推自动机.</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p><strong>字母表</strong>: 符号的非空有穷集合, 用$V, \Sigma$表示. 所使用的符号均出自字符表.</p>
<p><strong>符号</strong>: 语言中最基本的不可再分的单位.</p>
<p><strong>符号串</strong>: 字符表中符号组成的有穷序列. <strong>空串</strong> 用$\epsilon$表示.</p>
<p><strong>句子</strong>: 字母表上符合某种规则构成的串</p>
<p><strong>语言</strong>: 字母表上句子的集合</p>
<p>*小写字母表示符号, 大写字母表示集合, 希腊字母表示符号串.</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p><strong>连接(乘积)运算</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
  A &= \{\alpha_1, \alpha_2, \cdots\} \\
  B &= \{\beta_1, \beta_2, \cdots\} \\
  def:\quad AB &= \{\alpha \beta | \alpha\in A\ and\ \beta\in B\}
\end{aligned}</script><p>其中$A,B$是串集.<br>规定: $A^0={\epsilon}$. 注意该运算 <strong>非可交换</strong>. 例子: $\alpha$表示<code>if ()</code>, $\beta$表示<code>then()</code>.</p>
<p><strong>闭包</strong></p>
<script type="math/tex; mode=display">
A^\star=A^0\cup A^1 \cup A^2 \cup \cdots</script><p>由A上所有符号组成的所有串的集合.</p>
<p><strong>正闭包</strong></p>
<script type="math/tex; mode=display">
A^{+} = A^1 \cup A^2 \cup A^3 \cup \cdots = A^\star - {\epsilon}</script><p><strong>文法</strong></p>
<p>描述语言的语法结构规则</p>
<ul>
<li><strong>非终结符</strong>: 出现在规则的左部, 用”&lt;&gt;”括起来或用大写字母表示, 表示一定语法概念的词, 用$V_N$表示</li>
<li><strong>终结符</strong>: 语言中不可以再分割的字符串, 用$V_T$表示</li>
<li><strong>开始符号</strong>: 表示所定义的语法范畴的非终结符, 表示该文法中最大的一个语法成分 (?比如说一个句子)</li>
<li><strong>产生式</strong>: 是用来定义符号串之间关系的一组语法规则, $A\rightarrow \alpha$</li>
<li><strong>推导</strong>: 推导是从开始符号开始, 通过产生式的右部取代左部, 最终产生语言的一个句子的过程.<ul>
<li><strong>最左推导</strong>: 每次使用一个规则, 以其右部取代符号串最左的非终结符.</li>
</ul>
</li>
<li><strong>归约</strong>: 推导的逆过程, 从给定的源语言的一个句子开始, 通过规则的左部取代右部, 最终达到开始符号的过程.<ul>
<li><strong>最左归约</strong>: 最常采用</li>
</ul>
</li>
<li><strong>句型</strong>: 从文法的开始符号$S$开始, 每步推导(包括0步推导)所得到的字符串$\alpha$. 记作$S\rightarrow^\star \alpha, where\ \alpha\in (V_N \cup V_T)^\star$<ul>
<li><strong>句子</strong>: 仅含终结符的句型, 若能归约为开始符号, 则该句子是正确的</li>
</ul>
</li>
<li><strong>语言</strong>: 语言是由开始符号$S$通过1步或1步以上推导所得的句子的集合, 记为$L(G)={\alpha|S\rightarrow^+\alpha,\alpha\in V_T^*}$</li>
<li><strong>文法规则的递归定义</strong>: 非终结符的定义中包含了非终结符自身</li>
</ul>
<h2 id="文法与语言的形式定义"><a href="#文法与语言的形式定义" class="headerlink" title="文法与语言的形式定义"></a>文法与语言的形式定义</h2><p>Chomsky对文法的定义: 文法G是一个四元组$(V_N, V_T, P, S)$, 其中$P$是文法规则的集合, $S$是开始符号</p>
<p><strong>0型文法</strong></p>
<p>又称短语文法或者无限制文法. $P$中产生式$\alpha\rightarrow\beta,\alpha\in V^+=(V_N\cup V_T)^+$, $\alpha$至少含有一个非终结符,$\beta\in V^\star$.</p>
<ul>
<li>对产生式限制最少</li>
<li>图灵机</li>
<li>可递归可枚举</li>
</ul>
<p><strong>1型文法</strong></p>
<p>$P$中产生式$\alpha\rightarrow\beta$, 除可能有$S\rightarrow \epsilon$外均有$|\beta|\geq|\alpha|$, 若有$S\rightarrow\epsilon$, 规定$S$不能出现在产生式的右部.</p>
<p>等价定义: $P$中产生式$\alpha\rightarrow\beta$除了可能有$S\rightarrow\epsilon$外均有$\alpha S \beta \rightarrow \alpha \gamma \beta, \alpha, \beta \in V^\star, A\in V^n, \gamma\in V^+$.</p>
<div class="note note-info">
            <p>对非终结符进行替换时, 必须考虑上下文, 并且一般不允许替换为$\epsilon$, 除非是开始符号产生$\epsilon$.</p>
          </div>
<p><strong>2型文法</strong></p>
<p>$P$中产生式具有形式$A\rightarrow\beta, A\in V_N, \beta\in V^\star$. 要求产生式左边只有一个非终结符.</p>
<p>不必考虑上下文, 上下文无关文法.</p>
<p>识别2型文法的自动机称为下推自动机</p>
<p><strong>3型文法</strong></p>
<p>$P$中产生式具有形式$A\rightarrow \alpha B, A\rightarrow \alpha$或者$A \rightarrow B\alpha, A\rightarrow \alpha, A,B\in V_N, \alpha\in V_T^\star$. 也称为正规文法, (左|右)线性文法, 识别3型文法的自动机称为有限自动机.</p>
<div class="note note-info">
            <p>词法分析和语法分析中对产生式的限制: 1)不产生$P\rightarrow P$, 2)产生式中出现的任何非终结符必须有用, 能经过若干步推导出终结符</p>
          </div>
<p><strong>一些例子</strong></p>
<p><strong>例1</strong> 语言$L={\omega|\omega\in(a,b)^\star$且$\omega$中含有个数相同的$a,b}$, 构造生成该语言的文法:</p>
<script type="math/tex; mode=display">
\begin{align*}
  S&\rightarrow\epsilon \\
  S&\rightarrow aA\\
  S&\rightarrow bB\\
  A&\rightarrow aAA | bS\\
  B&\rightarrow aS | bBB
\end{align*}</script><p>解释: 要么以$a$开头, 要么以$b$开头, 后面跟着符号串. 对于符号串$A$, 如果以$b$开头, 则后面跟着$ab$个数相等的符号串, 如果仍然以$a$开头, 此时后面必须还要至少出现两次$b$.</p>
<p>或者</p>
<script type="math/tex; mode=display">
\begin{align*}
  S&\rightarrow\epsilon\\
  S&\rightarrow aSbS\\
  S&\rightarrow bSaS
\end{align*}</script><p>解释: 若以$a$开头, 则在字符串的某个位置必然出现一个$b$, 而这两个$a,b$中间是$ab$个数相等的的字符串, b后面也是$ab$个数相等的符号串.</p>
<p><strong>例2</strong> 设$L={\omega | \omega\in(0,1)^\star$且$1$的个数为偶数个$}$, 构造生成该语言的文法:</p>
<p>可以先列出看一下:</p>
<script type="math/tex; mode=display">
\omega\in\{\epsilon, 0, 11, 011, 101, 110,\cdots\}</script><p>然后:</p>
<script type="math/tex; mode=display">
\begin{align*}
  S&\rightarrow\epsilon\\
  S&\rightarrow 0S\\
  S&\rightarrow 1A\\
  A&\rightarrow 1S | 0A
\end{align*}</script><h2 id="文法的构造与简化"><a href="#文法的构造与简化" class="headerlink" title="文法的构造与简化"></a>文法的构造与简化</h2><h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>同一语言可以产生不同的文法, 选择产生式最少, 最符合语言特征的文法来描述; 有些产生式对推导不起作用, 包括: <strong>推导中永远用不到, 永远导不出终结符的, 形如$P\rightarrow P$的…</strong></p>
<p><strong>一些例子</strong></p>
<p><strong>例1</strong> 简化文法:</p>
<script type="math/tex; mode=display">
\begin{align*}
  S&\rightarrow Be\\
  S&\rightarrow Ee\\
  A&\rightarrow Ae\\
  A&\rightarrow e\\
  A&\rightarrow A\\
  B&\rightarrow Ce\\
  B&\rightarrow Af\\
  C&\rightarrow Cf\\
  D&\rightarrow f
\end{align*}</script><p>显然应该保留0236.</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><strong>构造无$\epsilon$产生式的上下文无关文法</strong></p>
<p>满足: $P$中要么不含有$\epsilon$产生式, 要么只有$S\rightarrow\epsilon$, 且若$S\rightarrow\epsilon$, 则$S$不出现在任何产生式右部.</p>
<h1 id="语义分析与中间代码生成"><a href="#语义分析与中间代码生成" class="headerlink" title="语义分析与中间代码生成"></a>语义分析与中间代码生成</h1><p><strong>在语法分析的过程中边分析边翻译, 翻译的结果是生成中间代码</strong> </p>
<p><strong>语法制导翻译</strong>  在语法分析中调用语义翻译程序生成相应的中间代码, 使用CFG来引导对语言的翻译, 面向文法</p>
<ul>
<li>根据产生式右部符号进行翻译</li>
<li>依据语义子程序<ul>
<li>语义子程序: 用于改变变量的值, 查填符号表, 发现源程序错误, 产生中间代码</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
X \rightarrow \alpha \{语义子程序\}</script><ul>
<li>具体做法: <strong>为每一个产生式配置一个语义子程序, 当语法分析进行归约或推导时调用相应的语义子程序</strong></li>
<li>注意: <strong>产生式中同一个符号出现多次, 需要区分, 加上角标</strong></li>
</ul>
<script type="math/tex; mode=display">
E \rightarrow E_1 + E_2</script><ul>
<li>语义值: <strong>需要为每个文法符号赋予不同的语义值</strong>, 如类型, (符号表) 地址, 代码值 (不是数字), 并且 <strong>只有非终结符才有语义值</strong></li>
<li>语义栈: 各个符号的语义值放在语义栈中. 产生式进行归约时, 需对右部符号的语义值进行综合, 结果作为左部符号的语义值保存在语义栈中. <strong>语义栈, 符号栈, 状态栈同步变化</strong></li>
</ul>
<p><strong>中间代码</strong>  转化为目标代码的中间生成的代码, 容易翻译</p>
<ul>
<li>形式<ul>
<li>四元式: $Operator, Op_1, Op_2, Result$, 两个操作数和结果可以是用户自定义, 也可以是编译时变量. 变量采用的是符号表入口地址.</li>
<li>三元式: $Operator, Op_1, Op_2$, 三元式本身就是结果, 以三元式的编号区别</li>
<li>逆波兰式 (后缀表示): $Op_1, Op_2, Operator$, 无括号, 从左到右扫描一遍</li>
<li>树形表示</li>
</ul>
</li>
</ul>
<h2 id="赋值语句-简单变量无数组-的翻译"><a href="#赋值语句-简单变量无数组-的翻译" class="headerlink" title="赋值语句 (简单变量无数组) 的翻译"></a>赋值语句 (简单变量无数组) 的翻译</h2><p><strong>文法</strong>:</p>
<script type="math/tex; mode=display">
A \rightarrow i = E \\

E \rightarrow E + E | E * E | -E | (E) | i</script><p><strong>内置函数</strong>:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">NEWTEMP  # 产生临时变量<br>ENRTY(i)  # 获取变量i的符号表地址<br>GEN(operator, op1, op2, result)  # 生成四元式中间代码<br></code></pre></td></tr></table></figure>
<p><strong>语义变量</strong>: </p>
<script type="math/tex; mode=display">
E.PLACE</script><ul>
<li>值是某个变量的符号表地址或临时变量的序号</li>
<li>分析过程需要就建立, 不需要就消亡</li>
</ul>
<p><strong>建立语法制导定义 (SDD)</strong>:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>产生式</th>
<th>语义规则 (子程序)</th>
</tr>
</thead>
<tbody>
<tr>
<td>$A \rightarrow i = E$</td>
<td>{$GEN(=, E.PLACE, NULL, ENTRY(i))$}</td>
</tr>
<tr>
<td>$E \rightarrow -E_1$</td>
<td>{$T = NEWTEMP; GEN(@, E_1.PLACE, NULL, T); E.PLACE = T;$}</td>
</tr>
<tr>
<td>$E \rightarrow E_1 * E_2$</td>
<td>{$T = NEWTEMP; GEN(*, E_1.PLACE, E_2.PLACE, T); E.PLACE = T;$}</td>
</tr>
<tr>
<td>$E \rightarrow E_1 + E_2$</td>
<td>{$T = NEWTEMP; GEN(+, E_1.PLACE, E_2.PLACE, T); E.PLACE = T;$}</td>
</tr>
<tr>
<td>$E \rightarrow (E_1)$</td>
<td>{$E.PLACE = E_1.PLACE$}</td>
</tr>
<tr>
<td>$E \rightarrow i$</td>
<td>{$E.PLACE = ENTRY(i)$}</td>
</tr>
</tbody>
</table>
</div>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>处理混合运算, 如整型与实型运算, 最后的结果为实型</p>
<p><strong>语义变量</strong>:</p>
<script type="math/tex; mode=display">
E.MODE</script><p><strong>建立语法制导定义 (SDD)</strong>:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>产生式</th>
<th>语义规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>$E \rightarrow E_1\ op\ E_2$</td>
<td>{$IF\ E_1.MODE = int\ AND\ E_2.MODE = int\ THEN\ E.MODE = int\ ELSE\ E.MODE = real$}</td>
</tr>
</tbody>
</table>
</div>
<p>例如 $X = Y + I * J$, 其中$X, Y$是实型的, $I, J$是整型的, 四元式为:</p>
<script type="math/tex; mode=display">
(*_i, I, J, T_1) \\
(itr, T_1, NULL, T_2) \\
(+_r, Y, T_2, T_3) \\
(=, T_3, NULL, X)</script><p>对运算符也要指出相应的类型.</p>
<h2 id="布尔表达式的翻译"><a href="#布尔表达式的翻译" class="headerlink" title="布尔表达式的翻译"></a>布尔表达式的翻译</h2>]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>GAMES101</title>
    <url>/2022/07/09/CS/GAMES101/</url>
    <content><![CDATA[<p>"From GAMES101"</p>
<span id="more"></span>
<h1 id="transformation">Transformation</h1>
<h2 id="basic"><strong>Basic</strong></h2>
<h3 id="scale">Scale</h3>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{aligned}
    &amp;s_x\ \ &amp;0 \\
    &amp;0\ \ &amp;s_y
\end{aligned} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
\]</span></p>
<h3 id="rotation">Rotation</h3>
<p>Rotation:</p>
<p><span class="math display">\[
R_{\theta} =
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;cos\theta\ \ &amp;-sin\theta \\
    &amp;sin\theta\ \ &amp;cos\theta
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
\]</span></p>
<p>inverse rotation:</p>
<p><span class="math display">\[
R_{-\theta} =
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;cos\theta\ \ &amp;sin\theta \\
    &amp;-sin\theta\ \ &amp;cos\theta
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
= R_{\theta}^{-1}
= R^T
\]</span></p>
<p>3-D: Eular angle: rotation around axises. The rotation is similar to
2-D, but inverse for axis y.</p>
<p>For a general rotation around an axis vector <span
class="math inline">\(n\)</span>, Rodrigues' Rotation Formula:</p>
<p><span class="math display">\[
R(n, \alpha) = cos\alpha I + (1 - cos\alpha)n n^T + sin\alpha
\left [ \begin{matrix}
    &amp;0 &amp;-n_z &amp;n_y \\
    &amp;n_z &amp;0 &amp;-n_x \\
    &amp;-n_y &amp;n_x &amp;0
\end{matrix} \right ]
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\left [ \begin{matrix}
    &amp;0\ \ &amp;-n_z\ \ &amp;n_y \\
    &amp;n_z\ \ &amp;0\ \ &amp;-n_x \\
    &amp;-n_y\ \ &amp;n_x\ \ &amp;0
\end{matrix} \right ]
\]</span></p>
<p>是叉积算子, 物理含义为角速度</p>
<p>For an arbitrary axis, do a translation (following).</p>
<h3 id="homogeneous-coordinates">Homogeneous coordinates</h3>
<p><span class="math display">\[
x_1 = x + t_x \\
y_1 = y + t_y
\]</span></p>
<p>solution:</p>
<p><strong>point:</strong> <span class="math inline">\((x, y,
1)^T\)</span></p>
<p><strong>vector:</strong> <span class="math inline">\((x, y,
0)^T\)</span></p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime} \\
    w
\end{aligned} \right ]
=
\left [ \begin{aligned}
    &amp;1\ &amp;0\ &amp;t_x \\
    &amp;0\ &amp;1\ &amp;t_y \\
    &amp;0\ &amp;0\ &amp;1
\end{aligned} \right ]
\left [ \begin{aligned}
    x \\
    y \\
    1
\end{aligned} \right ]
=
\left [ \begin{aligned}
    x + t_x \\
    y + t_y \\
    1
\end{aligned} \right ]
\]</span></p>
<p>for a general form:</p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x \\
    y \\
    w
\end{aligned} \right ]
\]</span></p>
<p>is the same with (<span class="math inline">\(w\neq 0\)</span>)</p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x / w \\
    y / w \\
    1
\end{aligned} \right ]
\]</span></p>
<h3 id="affine">Affine</h3>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;a\ \ &amp;b \\
    &amp;c\ \ &amp;d
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
+
\left [ \begin{aligned}
    t_x \\
    t_y
\end{aligned} \right ]
\]</span></p>
<p>is the same with</p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime} \\
    w
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;a\ &amp;b\ &amp;t_x \\
    &amp;c\ &amp;d\ &amp;t_y \\
    &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y \\
    1
\end{aligned} \right ]
\]</span></p>
<h2 id="viewing">Viewing</h2>
<p>MVP transformation (Model, View, Projection)</p>
<h3 id="view">view</h3>
<p>Define the camera:</p>
<ul>
<li>position <span class="math inline">\(e\)</span></li>
<li>gaze direction (look-at): <span
class="math inline">\(g\)</span></li>
<li>up direction: <span class="math inline">\(t\)</span></li>
</ul>
<p><strong>Method: Fix the camera: origin, look-at axis -z, look-up axis
y</strong> (将相机移动到一个规定位置上)</p>
<figure>
<img src="view1.png" alt="view" />
<figcaption aria-hidden="true">view</figcaption>
</figure>
<p>对应的变换, 先做平移, 再做旋转:</p>
<p><span class="math display">\[
M_{view} = R_{view}T_{view}
\]</span></p>
<p>其中平移:</p>
<p><span class="math display">\[
T_{view} =
\left [ \begin{matrix}
    &amp;1\ &amp;0\ &amp;0\ &amp;x_e \\
    &amp;0\ &amp;1\ &amp;0\ &amp;y_e \\
    &amp;0\ &amp;0\ &amp;1\ &amp;z_e \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ];
\]</span></p>
<p>旋转:</p>
<p><span class="math display">\[
R_{view}^{-1} =
\left [ \begin{matrix}
    &amp;x_{g\times t}\ &amp;x_t\ &amp;x_{-g}\ &amp;0 \\
    &amp;y_{g\times t}\ &amp;y_t\ &amp;y_{-g}\ &amp;0 \\
    &amp;z_{g\times t}\ &amp;z_t\ &amp;z_{-g}\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ],
R_{view} =
\left [ \begin{matrix}
    &amp;x_{g\times t}\ &amp;y_{g\times t}\ &amp;z_{g\times t}\ &amp;0
\\
    &amp;x_t\ &amp;y_t\ &amp;z_t\ &amp;0 \\
    &amp;x_{-g}\ &amp;y_{-g}\ &amp;z_{-g}\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\]</span></p>
<p>注意对所有物体变换.</p>
<h3 id="projection">projection</h3>
<figure>
<img src="projection.png" alt="projection" />
<figcaption aria-hidden="true">projection</figcaption>
</figure>
<p><strong>orthographic projection</strong></p>
<p>将模型 <span class="math inline">\([r, l]\times[b, t]\times[f,
n]\)</span> 转化为 <span class="math inline">\([-1, 1]\times[-1,
1]\times[-1, 1]\)</span></p>
<p><span class="math display">\[
M_{ortho} =
\left [ \begin{matrix}
    &amp;\frac{2}{r-l}\ &amp;0\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;\frac{2}{t-f}\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;\frac{2}{n-f}\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\left [ \begin{matrix}
    &amp;1\ &amp;0\ &amp;0\ &amp;-\frac{r+l}{2} \\
    &amp;0\ &amp;1\ &amp;0\ &amp;-\frac{b+t}{2} \\
    &amp;0\ &amp;0\ &amp;1\ &amp;-\frac{n+f}{2} \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\]</span></p>
<p><strong>perspective projection</strong></p>
<p>分两步进行: 先将棱锥变换为长方体; 再将长方体做正交投影.</p>
<p><strong>第一步</strong>: 保证远平面的中心不变, 远平面的 z 坐标不变,
近平面不变.</p>
<p>三角形相似:</p>
<p><span class="math display">\[
y^{\prime}=\frac{n}{z}y;\ x^{\prime}=\frac{n}{z}x
\]</span></p>
<p>设棱锥内任意一点 <span
class="math inline">\(P=(x_0,y_0,z_0,1)^T\)</span>, 经过挤压后变换为
<span
class="math inline">\(P^{\prime}=(x_0^{\prime},y_0^{\prime},z_0^{\prime},1)^T=(\frac{n}{z_0}x_0,\frac{n}{z_0}y_0,z_0^{\prime},1)^T=(nx_0,ny_0,z_0z_0^{\prime},z_0)^T\)</span>.
接下来确定 <span class="math inline">\(z_0^{\prime}\)</span>.</p>
<p>取近平面的中心点 <span class="math inline">\(O_1=(0,0,n,1)\)</span>
和远平面的中心点 <span class="math inline">\(O_2=(0,0,f,1)\)</span>,
变换后位置不变.</p>
<p><span class="math display">\[
O_1\Rightarrow O_1^{\prime}=(0,0,n^2,n)^T;\ O_2\Rightarrow
O_2^{\prime}=(0,0,f^2,f)
\]</span></p>
<p>从而确定矩阵:</p>
<p><span class="math display">\[
M_{perp\rightarrow ortho}
\left [ \begin{matrix}
    &amp;n\ &amp;0\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;n\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;n+f\ &amp;-nf \\
    &amp;0\ &amp;0\ &amp;1\ &amp;0
\end{matrix} \right ]
\]</span></p>
<p><strong>第二步</strong>: 将变换后的长方体做正交投影 <span
class="math inline">\(M_{ortho}\)</span></p>
<p>因此透视投影为</p>
<p><span class="math display">\[
M_{perp} = M_{ortho}M_{perp\rightarrow ortho}
\]</span></p>
<p>可以代入一些特殊点发现一些现象:</p>
<p>例如将中轴的中点 <span class="math inline">\(P=(0,0,\frac{n+f}{2},
1)\)</span> 经过上述变换得 <span
class="math inline">\(P^{\prime}=(0,0,\frac{n^2+f^2}{n+f}, 1)\)</span>,
与此时的中轴中点 <span
class="math inline">\(Q^{\prime}=(0,0,\frac{n+f}{2},1)\)</span>
比较发现, <span class="math inline">\(\frac{n^2+f^2}{n+f} &gt;
\frac{n+f}{2}\)</span>, 即原来的中点应该更加 <strong>靠近</strong>
相机.</p>
<h1 id="resterization">Resterization</h1>
<h2 id="triangles">Triangles</h2>
<h3 id="some-definition">Some definition</h3>
<ul>
<li><strong>aspect ratio:</strong> width / height</li>
<li><strong>FOV, field of view:</strong></li>
</ul>
<figure>
<img src="raster1.png" alt="def" />
<figcaption aria-hidden="true">def</figcaption>
</figure>
<ul>
<li><strong>screen (raster)</strong>
<ul>
<li>an array of pixels</li>
<li>size of the pixels: resolution (分辨率)</li>
<li>a typical kind of raster display</li>
</ul></li>
</ul>
<p>将raster放置在坐标系中, 并以像素的 <strong>左下角</strong> 作为坐标,
其像素中心则需要再加上0.5. (虎书里以中心作为坐标)</p>
<p>假设显示区域为 <span class="math inline">\(width\times
height\)</span>, 则将 viewing 后的 <span
class="math inline">\([-1,1]^3\)</span> 变换为显示区域大小 <span
class="math inline">\(width\times height\)</span>, 即 <strong>视口变换
(view port)</strong>:</p>
<p><span class="math display">\[
M_{viewport}
\left [ \begin{matrix}
    &amp;\frac{width}{2}\ &amp;0\ &amp;0\ &amp;\frac{width}{2} \\
    &amp;0\ &amp;\frac{height}{2}\ &amp;0\ &amp;\frac{height}{2} \\
    &amp;0\ &amp;0\ &amp;1\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\]</span></p>
<h3 id="triangles-1">Triangles</h3>
<p>将图像用三角形光栅</p>
<p>为什么是三角形?</p>
<ul>
<li>最基本多边形, 任意多边形可以拆成三角形</li>
<li>保证三角形是一个平面</li>
<li>内部和外部可以定义</li>
<li>内部插值</li>
</ul>
<h3 id="samlping">Samlping</h3>
<p>连续函数离散化</p>
<p><span class="math display">\[
Sampling (x) = \left\{
    \begin{matrix}
        1,\quad x\in triangle, \\
        0,\quad x\notin triangle
    \end{matrix}
    \right.
\]</span></p>
<p>其中 <span class="math inline">\(x\)</span>
是像素<strong>中心</strong></p>
<p>判断某个点是否在三角形内部: 设点 <span
class="math inline">\(P\)</span>, 三角形 <span
class="math inline">\(\triangle XYZ\)</span>, 分别用 <span
class="math inline">\(\vec{XY}, \vec{YZ}, \vec{ZX}\)</span> 与 <span
class="math inline">\(\vec{XP}, \vec{YP}, \vec{ZP}\)</span> 做外积,
若外积的结果方向一致, 则说明 <span class="math inline">\(P\)</span>
在三角形内部, 反之外部.</p>
<p><strong>Bounding Box:</strong> 最小的包围所考虑图形的长方体.
遍历时只遍历 Bounding Box 即可. 又称轴向包围盒 (AABB)</p>
<p>此外, 还可以找三角形内部的, 每一行的最小和最大坐标进行遍历.</p>
<p><strong>jaggies (锯齿)</strong></p>
<h2 id="antialiasing-and-z-buffering">Antialiasing and Z-Buffering</h2>
<p>Aliasing: artifacts to sampling</p>
<ul>
<li>Jagging (锯齿), sampling in space</li>
<li>Moire (摩尔纹), undersampling image</li>
<li>Wagon Wheel effect, sampling in time</li>
</ul>
<p>Reason: 信号变化太快, 采样慢</p>
<p>Antialiasing Idea: Blurring (Pre-Filtering) before sampling
(模糊处理)</p>
<figure>
<img src="sample1.png" alt="blur" />
<figcaption aria-hidden="true">blur</figcaption>
</figure>
<p>Aliasing 的来源: 相同采样频率采样不同函数, 得到的采样点相同.</p>
<figure>
<img src="sampel2.png" alt="aliasing" />
<figcaption aria-hidden="true">aliasing</figcaption>
</figure>
<p>大部分自然图像信号的信息集中在低频, 在变化剧烈处形成边界,
高频所代表的信息大部分是边界.</p>
<ul>
<li>低通滤波器: 大面积色块</li>
<li>高通滤波器: 边界</li>
<li>带通滤波器: 不明所以的东西</li>
</ul>
<p>注: 现实情况是<strong>非理想</strong>滤波.</p>
<p>另一个角度: <strong>滤波</strong> 相当于 <strong>卷积</strong> 或
<strong>平均</strong></p>
<h3 id="antialiasing">Antialiasing</h3>
<p>背景: 一般而言, 直接对原始图像进行三角形光栅化会出现明显的锯齿</p>
<p>减少锯齿的方法: 先对原始图像进行模糊处理, 再进行采样.</p>
<p>步骤: 1. <strong>模糊:</strong> 用某个低通滤波器 (卷积核)
对<strong>原始图像</strong>进行卷积, 例如可以选择 <span
class="math inline">\(1\times 1\)</span> 的低通滤波器,
卷积结果就是在每个像素的灰度平均值; 2. <strong>采样:</strong>
将模糊后的图像的每一个像素对像素中心进行采样</p>
<figure>
<img src="sample3.png" alt="antialiasing" />
<figcaption aria-hidden="true">antialiasing</figcaption>
</figure>
<p>新的问题:
<strong>如何计算光栅三角形在每一个像素里覆盖的区域</strong></p>
<p><strong>MSAA, Antialiasing by Supersampling</strong>:
将像素再进行划分, 划分为多个像素,
最后以子像素在父像素的百分比作为结果.</p>
<ul>
<li>近似 <strong>模糊</strong> 这一步</li>
<li>代价是更大计算量</li>
</ul>
<p>其他抗锯齿方法:</p>
<ul>
<li>FXAA (fast approximete AA)
<ul>
<li>先得到带锯齿的图像, 再进行图像比对找到边界, 并将锯齿去掉</li>
</ul></li>
<li>TAA (temperal AA)
<ul>
<li>复用上一帧提供的信息</li>
</ul></li>
</ul>
<p>其他概念:</p>
<ul>
<li>super resolution / super sampling
<ul>
<li>将低分辨率的图像恢复为高分辨率, 依然解决的是样本不够的问题</li>
<li>DLSS (Deep Learning Super Sampling)</li>
</ul></li>
</ul>
<h3 id="z-buffering">Z-Buffering</h3>
<p><strong>深度缓存</strong>: 解决可见性和遮挡.</p>
<p><strong>Painter's Algorithm</strong>: 将场景物品的深度由远及近排序,
先画最远的物品, 再画较近物品. 其中排序所需要的时间为 <span
class="math inline">\(O(n log n)\)</span></p>
<ul>
<li>问题: 深度如何定义, 相互覆盖如何处理, 深度关系有时候难定义.</li>
<li>因此画家算法一般不用</li>
</ul>
<p><strong>Z-Buffering Algorithm</strong>:
在每个像素中记录当前的最小深度</p>
<ul>
<li>frame buffer stores color value</li>
<li>z-buffer stores depth (e.i. <span
class="math inline">\(|z|\)</span>)</li>
</ul>
<figure>
<img src="zbuf1.png" alt="z-buffer" />
<figcaption aria-hidden="true">z-buffer</figcaption>
</figure>
<p>时间复杂度为 <span class="math inline">\(O(n)\)</span>,
但浮点数判断相等比较复杂</p>
<h3 id="summarize">Summarize</h3>
<figure>
<img src="sum1.png" alt="sum" />
<figcaption aria-hidden="true">sum</figcaption>
</figure>
<h1 id="shading">Shading</h1>
<p><strong>Def:</strong> darkening or coloring of an illustration or
diagram with parallel lines or a block of color.</p>
<ul>
<li>The process of <strong>applying a material</strong> to an object,
considering the interaction with light.</li>
<li>目前只考虑shading, 不考虑Shadow</li>
</ul>
<p><strong>Other terminologies:</strong></p>
<ul>
<li><strong>specular light 高光</strong></li>
<li><strong>diffuse reflection 漫反射</strong></li>
<li><strong>ambient light 间接光照</strong>: 简化为常量</li>
</ul>
<h2 id="blin-phong-reflection-model">Blin-Phong Reflection Model</h2>
<p>简单<strong>漫反射</strong>模型: 设物体表面法向量 <span
class="math inline">\(\vec{n}\)</span> 与光照的 <strong>反方向</strong>
<span class="math inline">\(\vec{l}\)</span> 夹角为 <span
class="math inline">\(\theta\)</span> 且为单位向量, 则</p>
<p><span class="math display">\[
cos \theta = \vec{l} \cdot \vec{n}
\]</span></p>
<p>物体表面接收的光强与 <span class="math inline">\(cos \theta\)</span>
成正比.</p>
<p>设光源为点光源, 传播过程不损失能量, 球面波传播. 则由能量守恒,
距离点光源 <span class="math inline">\(r\)</span> 的球面上一点的强度为
<span class="math inline">\(I/r^2\)</span>, 其中 <span
class="math inline">\(I\)</span> 表示单位球壳上的能量.</p>
<p>因此物体的不同点的光照强度可以表示为</p>
<p><span class="math display">\[
I_p = k_d\frac{I}{r^2}max\{0,\vec{l} \cdot \vec{n}\}
\]</span></p>
<p>其中取最大是考虑: 当光线逆向射过来后<strong>不考虑折射</strong>.</p>
<p>其中 <span class="math inline">\(k_d\)</span> 表示整体的颜色影响, 当
<span class="math inline">\(k_d=0\)</span> 时表示强度为 <span
class="math inline">\(0\)</span>, 此时全黑. 此外, 若是RGB, <span
class="math inline">\(k_d\)</span> 分别取值.</p>
<figure>
<img src="kd.png" alt="kd" />
<figcaption aria-hidden="true">kd</figcaption>
</figure>
<h1 id="geometry">Geometry</h1>
<h1 id="ray-tracing">Ray Tracing</h1>
<h1 id="animation-simulation">Animation / Simulation</h1>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>2022年4月15日-夜</title>
    <url>/2022/04/15/Life/2022%E5%B9%B44%E6%9C%8815%E6%97%A5-%E5%A4%9C/</url>
    <content><![CDATA[<p>"别看, 这是日记."</p>
<p>"日记? 那我更要看看了!"</p>
<span id="more"></span>
<h1 id="随便写写">随便写写</h1>
<p>从某种意义上确实是一篇日记, 但是既然敢发表在博客上,
那和朋友圈应该差不多, 不过是记录一下这忙碌的一周.</p>
<p>早三周就收到了要中期答辩的通知了, 啥也没做 (当然,
自己在家还是读了一些论文的, 还顺便玩了 python
中和<code>安全</code>相关的几个库). 一开始还是停留在寒假导师给我们要求:
<code>可以学学 Nmap</code>, 甚至开学以后还在用.
每次使用不过是随便指定一个倒霉的 ip, 然后去对方日志里面踩上一脚.
虽然有时候识别一下操作系统 (说实话,
这个从端口扫描到识别操作系统的一系列操作都被包含在了 Nmap
里面是我没想到的), 但主要还是没事干拿来用用.</p>
<p>最后做项目当然是没有用它: - 它好像不能读取流量数据? - 不知道怎么用
python 系统调用 Nmap? - 效率比较低? (当然, 最后用 python + wireshark
的组合也不见得有多高效率)</p>
<p>当然, 我体验最深的必须是这一周. 两个组员去写综述了.
代码和数据都在我这边做. 目前对中期也没什么把握,
毕竟确实什么都没有做.</p>
<p>没做也要硬着头皮去做啊. 这是你的项目, 你是负责人啊.</p>
<p>是啊, 这是我的项目啊. 为什么会从某一刻开始觉得无所谓了?
至少要完成这一件事吧?</p>
<p>那从最开始的数据集建立: 我们买了点物联网设备, 毕竟实验室那边去不了,
万幸的是刚好给我发了几个不同标记的设备过来, 后面还有一些因为疫情没送了.
这样我也可以做分类啊. 接下来是数据集的收集,
我就让这些设备连到电脑热点里, 然后连续抓了 24 小时包, 最后拿到了 54
万条流量数据. 那截下来就是用 python 读取这些流量, 然后统计个特征,
画几个图, 也就希望中期通过了. 但是问题就在于读取这些数据, 然后写入 csv
里面, 我惊呆了, 花我最长时间的事情不是统计, 不是训练模型,
不是写中期报告, 而是读文件?! 最初我还挺开心, 哦你 python
竟然还提供了读取这种文件的接口, 那我当然是毫不吝啬地用呗. 但是,
跑个程序, 内存占用直接飙到 6 个 Gib, 这是干嘛呢?
然后就听电脑风扇哗啦啦地响. 第一版程序还是非常暴力的, 在 github
找到了使用这个库的一些实例, 然后就照着来用, 不就是先判断再读取特征,
写入文件吗? 这不简单吗! 那我不过是多遍历几遍就行了啊,
现在的算力又不是盖的.</p>
<p>但是, 你这是要内存啊.</p>
<p>我绷不住了, 那天晚上跑了俩小时没出来, 又不敢关电脑, 那就让它一直跑吧.
结果第二天早上去看, 还在哗啦啦地读数据. ??? 这是干嘛, 我马上中期了啊哥.
重新想了想, 翻了一下代码, 我真傻, 为啥用这么多循环呢? 是吧,
我只遍历一遍不行吗. 接着一边用另一台电脑改了一份代码出来.
然后把之前那份停了 (毕竟没有输出什么日志信息, 心里也没啥底,
干脆一刀切吧). 停了以后, 我担心它内存会不会出事, 于是重启了一下,
刚好看见有系统更新, 那就重启并更新吧! 然后我看着九点半的太阳,
去外面逛了一圈, 感觉这次的 beta 版代码应该会好很多.</p>
<p>但是回来后, 我发现为什么我的电脑是关机状态? 难道我刚刚点成了关机?
开机看看呗. 理所应当地, 锁屏上出现了我可爱的薇尔莉特.</p>
<p>然后它<code>哔</code>地一声, 寄了.</p>
<p>???????????????????????</p>
<p>我要中期的啊哥, 你别搞我. 我又小心翼翼地开了一次机, 直接给我跳到了
windows 系统保护程序, 我看了一下选项, "退出并继续使用 win10". 可是您是
win11 啊哥. 所以我乖乖地选择了关机.</p>
<p>当然, 我算了一下, 反正还在保修期, 于是就再次按下开机,
于是薇尔莉特有一次出现在了锁屏上. 接下来我需要按下一个恐怖的键:
这个键可能会在莫名其妙的时候给你确认什么东西,
然后你的电脑就会发生一些不可名状的物理变化; 当然更多时候,
按下这个键的时候会带来一种快感, 因为它确实很好按.</p>
<p>没错啊, 就是回车键.</p>
<p>按了以后, 过了一会儿, 我的登录界面它出来了!!! 我的贝尔头像!
然后我输了密码, 把 beta 版的代码跑起来了.</p>
<p>在它跑的时候, 我干嘛呢? 哦, 中期报告和文献综述.
当然文献综述大部分还是交给了队友去写. 然后就巴拉巴拉写了一堆
(可能是写了综述吧, 我现在记忆十分混乱) 反正从上午十点,
一直跑到了下午五点半, 七个小时. 我是眼睁睁看着它的计数器跑到了 54 万,
然后, 我发现, <strong>它为什么还在跑???</strong> 甚至, 已经超过了 55 万,
不是, 这是在干嘛? 我是在做梦吗.</p>
<p>我是.</p>
<p>我的意思是, 我打开错了一个文件, 这个文件里面有 166 万数据, 其中 2/3
的数据是空包... 赶紧到处问, 我跑到一半能不能保存数据啊各位, 我这个 beta
版把文件写入放到了读取的最后, 因此如果没有读完, 你休想写入.</p>
<p>停吧停吧.</p>
<p>而这时已经是星期一晚上了. 星期五晚上答辩.</p>
<p>那这代码必须改啊. 我学聪明了, 我一开始我就写入, 还测试了许多小 demo,
看看循环写入文件会不会覆盖. 然后, 换了一个文件!</p>
<p>继续写中期报告... 到了一点钟, 只跑了 30 万个数据. 不管了,
赶紧先存下来了, 并且先发到群里去了. 要是后面又出事, 就...开摆吧.</p>
<p>第二天早上, 电脑是睡着的, 像我一样睡眼朦胧的. 不过我看见它是睡着的,
我立马变得十分清醒----是不是又要寄了? 好吧, 不知道是什么牛马更新,
把我之前设置的永不睡眠给改回去了. 然后去看了看文件, 啊! 满满当当的 54
万数据, 以及我其他提取特征的数据! 我的天啊! 你们真可爱.
而控制台输出了我设置的输出: 用时 7.72 小时.</p>
<p>不错. 现在是星期二, 我觉得我又行了. 当然, 我在它第一次没读出来的时候,
我还认为是它库的源码错了, 我就跑它的实现去看. 好家伙?
您搁着开心地递归呢? 本来 python 就比 C 慢, 你还疯狂递归. 不管了,
毕竟这个库不是主打读文件的.</p>
<p>星期三是文件提交的 ddl, 早上交的. 星期二改了改报告,
画了几张图用来镇场子, 然后做完了就开始在 push 导师给我们签字, 系统审核,
不知道他那边怎么想的, 感觉不想理我们.</p>
<p>反正你得给我签.</p>
<p>星期三毕竟没课, 就开始做 PPT, 晚上做完了. 觉得没啥事了.
就一边欣赏自己的 PPT, 一边感概自己真菜.
我一定要放一个看起来我们做了事的结果上去, 因为到时候老师问你:
"啊半年就做了个统计吗?" 于是我尝试用 SVM 浅浅地分了一个类.
之前还是了解过一些东西的. 所以参数哗啦啦就输进去了. 难就难在,
可视化.</p>
<p>星期四, 看着大家都在对卡时间背稿, 我要不要也做个稿子呢? 做吧,
毕竟开题答辩的时候脱稿是真的拉垮. 然后稿也写完了.
晚上给学长看了一下.</p>
<p>"就是, 听你讲完, 我不知道你在干嘛."</p>
<p>???!!!寄</p>
<p>听了他的建议啊, 我重新分配了讲稿的安排时间, 稍微改了 PPT. 晚上熬大夜,
到了三点多, 还是没能看懂多分类的 3 特征决策面怎么画
(我这句话说这么清楚当然就是希望有没有 hxd 告诉我咋搞,
model.decision_function.reshape 为什么不是说我特征维度不对, 就是说我不能
reshape). 反正我三点多的脑袋已经 reshape 了.</p>
<p>星期五, 早上上课差点迟到, 中午太困了. 和 Jerry 去搞了个泡面.
一点半回来的, 下午满课, 上完课和答辩前的半小时之间解决了晚餐.
之后就是紧张局促地等答辩开始.</p>
<p>总之不管怎么样吧. 还是答完了. 还挺流畅的, 老师问的问题也特别友好
(这种情况下, 一般没什么好结果, 因为极大可能性是老师不知道你在干嘛).</p>
<p>不管了, 睡觉!</p>
<h1 id="还是写了写后记">还是写了写后记</h1>
<p>当然, 正文和后记的写作时间没有间隔 1 秒.</p>
<p>主要是想说, 这一周见了很多很厉害的人, 很厉害的项目, 很团结的组员.
看了汤老师雷打不动每天调代码, pc 隔离后出来多了欢乐的气息, 还有 Jerry
时常带来一些地狱笑话, 鸡哥偶尔也过来"嘘寒问暖"...
虽然我不是和他们一起做项目, 但是我觉得很快乐.</p>
<p>就是这样.</p>
<p>2022 年 4 月 16 日凌晨</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>BabyBlog</title>
    <url>/2022/01/11/Life/BabyBlog/</url>
    <content><![CDATA[<h2 id="finished-my-first-blog">Finished! My First Blog!</h2>
<p>After a long time deploying my blog webpage and a lot of other
borthering settings, I finally finished it! I mean, FINALLY!!!
:laughing: :laughing: :laughing:</p>
<span id="more"></span>
<h3 id="original-intention">Original Intention</h3>
<p>Can a programmer has no personal blog? I have seen many blogers
writing their own blogs no metter answering a question or just taking
notes from time to time on websites such as <a
href="https://zhihu.com">zhihu</a> and <a
href="https://csdn.net">csdn</a>, but among which I prefer is to
establish a personal website where I can put my blogs on.</p>
<p>So, at first I have no intention about what to do with my site, maybe
I just feel that it's really cool to have such a lovely home for oneself
to "lie down and rest".</p>
<p>But when it was finally established by myself, experencing a lot of
confusing problems and taking amount of time to debug, I must to say
that, I love here, and I believe I will take after it like taking after
a baby, a baby who are growing up. :blush:</p>
<h3 id="thanks">Thanks</h3>
<p>I would not finish my work without the help of JerryYang, whose
helpful blog is the guidance of mine (though there are still some
mistakes maybe? :dizzy_face:). Based on it, I have known some basic
command with Linux, Git and <a href="https://github.com">Github</a>,
which is also beneficial for my lessons next term. Except him I want to
link some videos there to thank for another ups from bilibili:</p>
<p><a
href="https://www.bilibili.com/video/BV1mU4y1j72n?from=search&amp;seid=13163723927059638874&amp;spm_id_from=333.337.0.0">using
hexo to start blog</a></p>
<p><a
href="https://www.bilibili.com/video/BV18z4y197J7?from=search&amp;seid=13163723927059638874&amp;spm_id_from=333.337.0.0">how
to writing blogs</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统练习</title>
    <url>/2022/05/09/CS/OSPractice/</url>
    <content><![CDATA[<p>"操作系统习题, 包括进程同步, CPU调度等内容."</p>
<p>"还在更新...也有可能不在更新..."</p>
<span id="more"></span>
<h1 id="进程同步与互斥">进程同步与互斥</h1>
<h3 id="习题1">习题1</h3>
<p>哲学家进餐问题: 问题描述见<a
href="https://andrew-rey.github.io/2022/04/19/OS/">操作系统笔记</a>.</p>
<p><strong>解法1</strong>: 最多允许 4 个哲学家同时进餐,
以保证至少有一个哲学家可以正常用餐, 并且最终可以释放出其使用的筷子,
从而使给多的哲学家用餐.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">semaphore choopsticks[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>semaphore room = <span class="hljs-number">4</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">philosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">think</span>();<br>        <span class="hljs-built_in">wait</span>(room);<br>        <span class="hljs-built_in">wait</span>(chopsticks[i]);<br>        <span class="hljs-built_in">wait</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-built_in">eat</span>();<br>        <span class="hljs-built_in">signal</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-built_in">signal</span>(chopsticks[i]);<br>        <span class="hljs-built_in">signal</span>(room);<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解法2</strong>: 将拿一双筷子作为一个
<strong>原子操作</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">semaphore mutex = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 将一双筷子视作资源, 表示当前是否有人在拿筷子</span><br>semaphore chopsticks[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">philosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">think</span>();<br>        <span class="hljs-built_in">wait</span>(mutex);  <span class="hljs-comment">// 申请拿筷子的权限</span><br>        <span class="hljs-built_in">wait</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-built_in">wait</span>(chopsticks[i]);<br>        <span class="hljs-built_in">signal</span>(mutex);<br>        <span class="hljs-built_in">eat</span>();<br>        <span class="hljs-built_in">signal</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        <span class="hljs-built_in">signal</span>(chopsticks[i]);<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解法3</strong>: 规定奇数的哲学家先拿左边的筷子,
再拿右边的筷子; 偶数的哲学家先拿右边的筷子再拿左边的筷子.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">semaphore chopsticks[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">philosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">think</span>();<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">wait</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>            <span class="hljs-built_in">wait</span>(chopsticks[i]);<br>            <span class="hljs-built_in">eat</span>();<br>            <span class="hljs-built_in">signal</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>            <span class="hljs-built_in">signal</span>(chopsticks[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">wait</span>(chopsticks[i]);<br>            <span class="hljs-built_in">wait</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>            <span class="hljs-built_in">eat</span>();<br>            <span class="hljs-built_in">signal</span>(chopsticks[i]);<br>            <span class="hljs-built_in">signal</span>(chopsticks[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="习题2">习题2</h3>
<p><strong>生产者消费者问题的变式:</strong> 4 个进程 R1, R2, W1, W2
共享大小为 1 的缓冲器 B.</p>
<ul>
<li>R1 将输入的数放入 B 并且 <strong>只给 W1 使用</strong></li>
<li>R2 将输入的数放入 B 并且 <strong>只给 W2 使用</strong></li>
</ul>
<p>分析:</p>
<ul>
<li>生产者: R1, R2; 消费者: W1, W2</li>
<li>R1, R2互斥, R1&amp;W1, R2&amp;W2同步</li>
<li>只有一个空间大小: 用 empty 代替 mutex</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">semaphore empty = <span class="hljs-number">1</span>, full1 = <span class="hljs-number">0</span>, full2 = <span class="hljs-number">0</span>;<br>buffer B;<br><br><span class="hljs-function">process <span class="hljs-title">R1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">input</span>();<br>        <span class="hljs-built_in">wait</span>(empty);  <span class="hljs-comment">// R1, R2 竞争权限</span><br>        B = x;<br>        <span class="hljs-built_in">signal</span>(full1);  <span class="hljs-comment">// 如果是 R2, 则改为 full2</span><br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function">process <span class="hljs-title">W1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-built_in">wait</span>(full1);  <span class="hljs-comment">// 如果是 W2, 则改为 full2</span><br>        i = B;<br>        <span class="hljs-built_in">signal</span>(full);  <span class="hljs-comment">// 释放资源</span><br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>今天又是码代码的一天呢</title>
    <url>/2022/10/12/Life/Code/</url>
    <content><![CDATA[<p>"正如标题所言, 今天又是写代码的一天呢"</p>
<p>"哈哈"</p>
<span id="more"></span>
<h1 id="年秋">2022年秋</h1>
<h2 id="disk上的矩阵乘法">Disk上的矩阵乘法</h2>
<div class="note note-info">
            <p>10/16</p><p>discription: 由于矩阵太大, 不能一次性load进内存, 希望研究缓存大小,对矩阵乘法效率的影响.</p><p>lang: Cpp</p><p>project: 暂未完成</p>
          </div>
<p>本来以为挺简单的一个作业, 没想到这么复杂, 10%的时间在写矩阵乘法,
自以为是地写了个指定嵌套顺序的for循环,
然后发现难点在于文件的读取和写入.</p>
<p><strong>问题 1: 写入时覆盖</strong></p>
<p>由于缓存大小有限, 并且对于特定的for循环顺序,
矩阵可能需要以列的方式写入, 这时候如何定位指针的顺序?</p>
<p><strong>问题 2: 读取时返回</strong></p>
<p>意思是我需要的矩阵的绝对坐标小于此坐标在缓存上的相对坐标(即相对坐标小于0),
这时候需要返回去读取, 但是如果从头开始读取, miss hit 的数目会陡然增加,
如果从当前位置读取, 需要知道上一次指针的位置,
然而上一次的指针已经被更新了, 并且更新的时间不在同一个生命周期.</p>
<p><strong>问题 3: 以上两种情况有可能在读取和写入时都出现</strong></p>
<p><strong>问题 4: 写入时返回需要先读取再写入,
直到下标符合条件</strong></p>
<h2 id="外部快排">外部快排</h2>
<div class="note note-info">
            <p>10/9</p><p>discription: use interval heap to realize the priority double endedqueue (PDEQ); use PDEQ to do external sort.</p><p>lang: Cpp</p><p>project: <ahref="https://github.com/Andrew-Rey/Self-Study-For-Cpp/tree/Final-task/DataStructure/ExternalQuickSort">ExternalQuickSort</a></p>
          </div>
<p>说实话还是第一次写一个六百多行的代码.
虽然不知道用六百行实现一个简单的外部快速排序是否比较能令人接受,
但我还是从中学到了很多东西.</p>
<p><strong>使用STL</strong></p>
<p>以前一般是说说要用STL比较高效, 不过自己看了一些教程以后,
也一直没有什么用武之地, 所以很多东西经常会忘.
然后这份代码里就用了很多的诸如<code>std::deque</code>,
<code>std::vector</code>等一些简单的STL, 当然,
期间还用了一些<code>std::priority_queue</code>,
但是发现并不能实现自己的目标 (能以<span
class="math inline">\(O(1)\)</span>效率返回最大值和最小值),
所以就基于<code>std::deque</code>做了一个interval heap.</p>
<p><strong>官网DOC</strong></p>
<p>以前不太习惯在<a href="https://cplusplus.com/">这里</a>参考资料,
但是终于对网上那些复制粘贴的, 没有思考的blog忍无可忍了,
于是转身求助官网.</p>
<p><strong>CMake</strong></p>
<p>之前自己学了CMake, 这次终于用上了. yysy,
CLion的CMake及时更新还挺好的.</p>
<p><strong>Main</strong></p>
<p>说说主要内容.</p>
<p>这里主要是针对内存大小有限, 希望能对硬盘上的大量数据排序.</p>
<ul>
<li>人为定义宏来规定当前的内存大小 (只关心待排序的数据,
不考虑中间变量)</li>
<li>将内存划分为 Input, Small, Large 和 Middle 四个区. Middle
相当于快排里的pivot, 然后递归对Small和Large排序,
这里使用循环+栈的方式实现递归.</li>
<li>文件读写, 我认为的本项目最繁琐的操作之一. 因为当缓冲区满了以后,
再次写入时, 可能需要保留上一次写入的末尾位置,
所以我新定义了一个栈用来存末尾指针.</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>WinterHoliday</title>
    <url>/2022/12/26/Life/WinterHoliday/</url>
    <content><![CDATA[<p>"计划是什么"</p>
<p>"墙上的风景 (即答"</p>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>首先寒假大概分成三大块吧: <strong>学习, 写代码, 生活</strong>.
方才一想, 发现寒假要做的事情还挺多的, 比如啥 <strong>编译原理</strong>,
然后由于提前回家, 考试推迟, 就导致还要
<strong>准备下学期初的考试</strong>, 然后大作业的话,
<strong>还有操作系统和数据库的两个大作业</strong>,
还有那个所谓的<strong>SRTP</strong>要做, 甚至还要
<strong>准备TOEFL和GRE</strong>, <strong>准备出国的一些事情</strong>,
接着毕竟已经快大四了, 还要去找一些比较好的点, 复现别人成果也好,
自己写代码也好, 都要有一些相应的积累, 另外作为一个计算机学生,
还要修一些必要的课程. 在这闲暇之余, 还希望每天能写一些文字,
整个假期要看一些电影, 要找同学玩, 要做菜.</p>
<h1 id="学习">学习</h1>
<h2 id="编译原理">编译原理</h2>
<p>这必然是最重要的一部分</p>
<ul>
<li>听网课 (主要看语义分析往后的内容), 看龙书 (整体浏览一遍)</li>
<li>写一个半成品的编译器 (具体要求都写到某个README里面去了)</li>
</ul>
<h2 id="每周必做">每周必做</h2>
<p>这里的内容的话, 又多又杂</p>
<ul>
<li>复习某些考试课程
<ul>
<li>主要是一些非计算机课程, 需要每周花一点时间来做, 包括
<strong>自动控制原理</strong>, <strong>近代物理 (热学)</strong>.
人智导论和数据库可以考前一两周的时候复习.</li>
</ul></li>
<li><strong>至少看一部电影</strong></li>
</ul>
<h2 id="每天必做">每天必做</h2>
<p>这里就继续规定一下合理的每天必做的事情</p>
<ul>
<li>写代码: 计算机学生每天写点代码不过分吧</li>
<li><del>矫情文字</del>打卡</li>
<li>看书 (为啥不写看啥啊, <del>因为好多书要看</del>)</li>
</ul>
<h2 id="计算机课程">计算机课程</h2>
<ul>
<li>算法</li>
<li>图形学</li>
</ul>
<h2 id="制定一些ddl">制定一些ddl</h2>
<ul>
<li>数据库最后的大作业听天由命 (毕竟我不是组长, 但我希望快点写完)</li>
<li>操作系统最后一个实验 (这东西你不会还想留到明年吧)</li>
<li>过年前把编译器写<span class="math inline">\(\frac{2}{3}\)</span>
(写完语义分析, 但理论要全学完)</li>
<li>开学前能不能把SRTP搞出个什么东西</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title>Operating System</title>
    <url>/2022/11/23/CS/OS/</url>
    <content><![CDATA[<p>"This is the basic class for CS."</p>
<p>"And it is interesting. I mean if you can totally master it."</p>
<span id="more"></span>
<h1 id="concept">Concept</h1>
<p>Framework of this chapter:</p>
<ul>
<li>basic concepts</li>
<li>OS components</li>
<li>OS services (Using components)</li>
<li>System call (how to provide services)</li>
<li>Structure</li>
<li>virtual machine</li>
</ul>
<p>These contents will be detailed written in the following chapters</p>
<h2 id="operating-system-components">Operating system components</h2>
<h3 id="process-management">Process management</h3>
<p><strong>process</strong>: A process is a
<font color=blue>program</font> in <font color=red>execution</font>.</p>
<ul>
<li>program has its own address space</li>
</ul>
<div class="note note-info">
            <h3 id="os-activities">OS activities:</h3><ul><li>Process creation and deletion<ul><li>using <strong>fork</strong> system call</li></ul></li><li>Process suspension and resumption (挂起或恢复)</li><li>Provision of mechanism for:<ul><li>process synchronization (进程同步)<ul><li>such as two processes should share a variable to achieve a task orjob. And synchronization mechanism helps to finish this job in a properorder.</li></ul></li><li>process communication (进程通信)</li><li>deadlock handling (死锁处理)</li></ul></li></ul>
          </div>
<h3 id="main-memory-management">Main memory management</h3>
<p><strong>memory</strong>: Memory is a large array of words or bytes,
each with its own address. It is a repository of quickly accessible data
shared by the CPU and I/O devices.</p>
<p><strong>Main memory</strong> or <strong>primary storage</strong> is a
volatile storage device (掉电易失设备).</p>
<div class="note note-info">
            <h3 id="os-activities">OS activities:</h3><ul><li>Keep track of which parts of memory are currently being used and bywhom.</li><li>Decide which processes to load when memory space becomes available(Job scheduling, 任务调度).</li><li>Allocate and deallocate memory space as needed.</li></ul>
          </div>
<p><strong>Virtual memory</strong>: Virtual memory allows programs to
address memory from a logical point of view. This technique allows
applications <strong>regard</strong> that they have a continuous address
space rather than fragmented spaces from main memory to disk memory.</p>
<ul>
<li>without regard to the limits of physical memory.</li>
</ul>
<h3 id="file-management">File management</h3>
<p><strong>file</strong>: A file is a collection of related information
defined by its creator. Commonly, files represent programs (both source
and object form) and data.</p>
<ul>
<li>this a uniform logical view of information storage provided by
OS.</li>
</ul>
<div class="note note-info">
            <h3 id="os-activities">OS activities:</h3><ul><li>File creation and deletion.</li><li>Directory (can be seen as a special file) creation anddeletion.</li><li>Support of primitive for manipulating files and directories.</li><li>Mapping files onto secondary storage.<ul><li>for large files, how to map them onto secondary storage?</li></ul></li><li>File backup (备份) on stable (nonvolatile) storage media.</li></ul>
          </div>
<p><em>Windows file management is related to storage, but Linux not. In
Linux, every thing is file, having a unified form to access
files.</em></p>
<p><strong>Mount (挂载)</strong>: create a mounting point, and this file
is can be accessed using mounting point.</p>
<h3 id="io-system-management">I/O system management</h3>
<p>The I/O subsystem consists of:</p>
<ul>
<li>a buffer-caching system</li>
<li>a general device-driver interface (a driver is a part of OS,
specific for devices)
<ul>
<li>programmed I/O</li>
<li>interrupt I/O</li>
<li>DMA</li>
</ul></li>
<li>drivers for specific hardware devices</li>
</ul>
<h3 id="secondary-storage-disk-management">Secondary-storage (disk)
management</h3>
<p><strong>Secondary storage</strong> is the principle on-line storage
medium (线性存储介质) for both programs and data.</p>
<ul>
<li>disk</li>
<li>Main memory is volatile and too small to accommodate all data and
programs permanently, so the computer must provide secondary storage to
back up main memory.</li>
</ul>
<div class="note note-info">
            <h3 id="os-activities">OS activities;</h3><ul><li>Free space management (which parts of disk are free and how toallocate these free blocks)</li><li>Storage allocation</li><li>Disk scheduling (磁盘调度)<ul><li>磁头移动, 请求分布在不同柱面上, 相应时需要磁头在不同不同柱面上切换,经过算法, 设计磁头移动的最短距离 (有计算题).</li></ul></li></ul>
          </div>
<h3 id="protection-system">Protection system</h3>
<p><strong>Protection</strong> refers to a mechanism for controlling
access by programs, processes, or users to both system and user
resources.</p>
<ul>
<li>distinguish between authorized and unauthorized usage.</li>
<li>specify the controls to be imposed and means for enforcement.</li>
</ul>
<p>Example: In Linux, file access control: <strong>rwx</strong>,
<strong>owner</strong>, <strong>user(u)</strong>,
<strong>group(g)</strong>, <strong>other(o)</strong></p>
<h3 id="command-interpreter-system">Command-interpreter system</h3>
<p><strong>Command-interpreter system</strong>(命令行解释系统): Interact
with users, users can send instructions to OS.</p>
<ul>
<li>Shell</li>
<li>its functions is to get and execute the next command statement.</li>
</ul>
<h2 id="operating-system-services">Operating system services</h2>
<h3 id="core-operating-system-services">Core operating system
services</h3>
<p>From the view of an user:</p>
<p><strong>Program execution</strong></p>
<ul>
<li>load a program into memory and to run it
<ul>
<li>process management, memory management, disk management and so
on.</li>
</ul></li>
</ul>
<p><strong>I/O operations</strong></p>
<ul>
<li>user programs cannot execute I/O operations directly, the OS must
provide some means to perform I/O.</li>
</ul>
<p><strong>File-system manipulation</strong></p>
<ul>
<li>programs capability to read, write, create and delete files</li>
</ul>
<p><strong>Communication</strong></p>
<ul>
<li>exchange information between processes</li>
</ul>
<p><strong>Error detection</strong></p>
<ul>
<li>ensure correct computing in CPU, memory hardware, I/O devices, user
programs</li>
</ul>
<h3 id="additional-operating-system-functions">Additional operating
system functions</h3>
<p>From a view of system:</p>
<p>This part is user for <strong>efficient system operations</strong>,
not for helping users.</p>
<ul>
<li>Resource allocation</li>
<li>Accounting</li>
<li>Protection</li>
</ul>
<h2 id="system-call">System call</h2>
<p>An user how to use system services:</p>
<p>Normally, we write C code and define the <code>main</code> function,
this is a <em>system call</em>, but has been packaged to a
convenient-to-use API.</p>
<p><strong>System call</strong> is an <strong>interface</strong> between
a running program and the OS.</p>
<ul>
<li>generally available as assembly-language instructions.
(汇编语言形式呈现)</li>
<li>user programs (in <strong>user mode</strong>,
<code>mode bit=1</code>) send a <code>system call</code> to the OS (in
<strong>kernel mode</strong>, <code>mode bit=0</code>), and the OS
execute the system call, then the OS returns (and change the mode bit to
1), finally the user programs continue to execute.</li>
<li>Common in the OS</li>
<li>Some language like <code>C</code> language and <code>C++</code> are
defined to replace assembly-language for system programming, which allow
system call to be made directly.</li>
</ul>
<figure>
<img src="system_call1.png" alt="system_call1" />
<figcaption aria-hidden="true">system_call1</figcaption>
</figure>
<h3 id="the-implementation-of-system-call">The implementation of system
call</h3>
<p>Typically, a number (index) associated with each system call.</p>
<ul>
<li>System call interface maintains a table indexed according to these
numbers</li>
</ul>
<p>The system call interface invokes intended system call in OS kernel
and returns status of the system call and any return values.
(系统调用的接口使用OS内核中的系统调用, 并返回系统调用状态和相应参数)</p>
<p>The caller need to know <strong>nothing</strong> about how the system
call in implemented.</p>
<ul>
<li>just need to <strong>obey API</strong> and understand what OS will
do as a result call.</li>
<li>Most details of OS interface hidden from programmer by API
<ul>
<li>manage run-time support library <u>(set of functions built into
libraries included with compiler)</u></li>
</ul></li>
</ul>
<figure>
<img src="system_call2.png" alt="system_call2" />
<figcaption aria-hidden="true">system_call2</figcaption>
</figure>
<p>In this picture, <code>open()</code> function acts as an API, and
<code>open()</code> gives a system call (in the function library) to OS
(maybe in the library, <code>open()</code> function use other system
functions to give a system call, because <code>open()</code> is just an
<u>API</u> of system call functions). Then the OS look up this system
call in its number table and then execute a specific system program
(according to the index number). Finally, the OS returns the states.</p>
<h3 id="parameter-passing-in-system-call">Parameter passing in system
call</h3>
<p>Often, more information is required than simply identity of desired
system call.</p>
<p>Three types:</p>
<ul>
<li>simplest: pass the parameters in <strong><em>registers</em></strong>
<ul>
<li>maybe more parameters than registers</li>
</ul></li>
<li>Parameters stored in a <strong><em>block</em></strong>, or
<em>table</em>, in memory. and pass the block address to registers.
<ul>
<li>taken by Linux and Solaris</li>
</ul></li>
<li>Parameters placed, or <u>pushed</u> onto the
<strong><em>stack</em></strong> by program and <u>popped</u> off the
stack by the OS.</li>
</ul>
<p><u>Block and stack don't limit the number and the length of
parameters.</u></p>
<h3 id="types-of-system-call">Types of system call</h3>
<p>Five main types:</p>
<ul>
<li>process control</li>
<li>file management</li>
<li>device management</li>
<li>information maintenance</li>
<li>communication</li>
</ul>
<strong>process management</strong>
<center>
<b>Table 1: process management for major POSIX system</b>
</center>
<table>

<thead>
<tr class="header">
<th>call</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>pid=fork()</code></td>
<td>create a child process identical to the parent (child is same with
parents process)</td>
</tr>
<tr class="even">
<td><code>pid=waitpid(pid, &amp;statloc, options)</code></td>
<td>wait for a child to terminate</td>
</tr>
<tr class="odd">
<td><code>s=execve(name, argv, environp)</code></td>
<td>replace a process' core image, can be used with <code>fork()</code>
to let child do another things but both from parents process</td>
</tr>
<tr class="even">
<td><code>exit(status)</code></td>
<td>terminate process execution and return status</td>
</tr>
</tbody>
</table>
<strong>file management</strong>
<center>
<b>Table 2: file management for major POSIX system</b>
</center>
<table>

<thead>
<tr class="header">
<th>call</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fd=open(file, how, ...)</code></td>
<td>open a file for reading, writing, or both, <code>fd</code> is
文件描述符</td>
</tr>
<tr class="even">
<td><code>s=close(fd)</code></td>
<td>close an open file</td>
</tr>
<tr class="odd">
<td><code>n=read(fd, buffer, nbytes)</code></td>
<td>read data from a file into a buffer</td>
</tr>
<tr class="even">
<td><code>n=write(fd, buffer, nbytes)</code></td>
<td>write data from a buffer to file</td>
</tr>
<tr class="odd">
<td><code>position=lseek(fd, offset, whence)</code></td>
<td>move the file pointer</td>
</tr>
<tr class="even">
<td><code>s=stat(name, &amp;buf)</code></td>
<td>get a file's status information</td>
</tr>
<tr class="odd">
<td><code>mkdir()</code></td>
<td>create a new directory</td>
</tr>
<tr class="even">
<td><code>rmdir()</code></td>
<td>remove an empty directory</td>
</tr>
<tr class="odd">
<td><code>link()</code></td>
<td>create a new entry, name2, pointing to name2. (soft link)</td>
</tr>
<tr class="even">
<td><code>unlink()</code></td>
<td>remove the directory entry</td>
</tr>
<tr class="odd">
<td><code>mount()</code></td>
<td>mount a file system</td>
</tr>
<tr class="even">
<td><code>unmount()</code></td>
<td>unmount a file system</td>
</tr>
</tbody>
</table>
<p><strong>miscellaneous system call</strong></p>
<table>
<thead>
<tr class="header">
<th>call</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>chdir()</code></td>
<td>change working dir</td>
</tr>
<tr class="even">
<td><code>kill()</code></td>
<td>send a <b>signal</b> to a process</td>
</tr>
<tr class="odd">
<td><code>chmod()</code></td>
<td>change a file's protection bits</td>
</tr>
<tr class="even">
<td><code>time()</code></td>
<td>get the elapsed time since Jan 1, 1970</td>
</tr>
</tbody>
</table>
<h2 id="system-structure">System structure</h2>
<p>monolithic单体结构（一个进程）<span
class="math inline">\(\rightarrow\)</span> 分层式 <span
class="math inline">\(\rightarrow\)</span>
微内核结构（最核心的功能放在内核中）、模块化结构（linux） ### UNIX have
no concept of <strong>structure</strong>, is <strong>Single core
structure.</strong></p>
<p>consists of two separable parts:</p>
<ul>
<li>system programs</li>
<li>the kernel</li>
</ul>
<h3 id="microkernel">Microkernel</h3>
<p>assign only a few essential functions to the kernel</p>
<ul>
<li>address spaces</li>
<li>interprocess communication (IPC)</li>
<li>basic scheduling</li>
</ul>
<div class="note note-info">
            <h3 id="benefit-and-detriments">Benefit and detriments</h3><ul><li>reliable</li><li>easy to extend</li><li>secure</li><li>communication occupies much space</li></ul>
          </div>
<h3 id="modules">Modules</h3>
<p>most modern OS implement module method:</p>
<p>kernel is divided into different modules.</p>
<p>层次化不明显；可以动态对内核进行装载和删除内核模块</p>
<h2 id="virtual-machine">Virtual machine</h2>
<p>treats hardware and the OS kernel as though they were all hardware
(对物理资源抽象，即抽象层，在抽象层能实现虚拟机)</p>
<p><strong>management application:</strong></p>
<ul>
<li>type 1: built on hardware
<ul>
<li>use hardware directly</li>
<li>usually used in data center or service</li>
</ul></li>
<li>type 2: built on the OS
<ul>
<li>lower performance (性能)</li>
<li>lower security</li>
<li>usually used on PC</li>
</ul></li>
</ul>
<h1 id="process">Process</h1>
<h2 id="concept-of-process">Concept of process</h2>
<h3 id="what-is-a-process">What is a process?</h3>
<ul>
<li>A program in execution</li>
<li>An instance(实例) of a program running on a computer
<ul>
<li>同样代码跑两遍，是不同的进程</li>
</ul></li>
<li>The entity(实体) that can be assigned to(指派) and executed on a
processor</li>
<li>A unit of activity characterized by the execution of a sequence of
in instructions, a current state, and an associated set of system
resources(一系列指令执行，状态(如wait, execution, ready)，有资源)</li>
</ul>
<h3 id="process-in-memory">Process in memory</h3>
<ul>
<li><strong>text</strong> 代码段(<code>addr=0</code>)
<ul>
<li>code</li>
<li>codes are complied and stored here</li>
</ul></li>
<li><strong>data</strong> 数据段
<ul>
<li><code>global</code> data</li>
<li><code>static</code> data</li>
</ul></li>
<li><strong>heap</strong> 堆
<ul>
<li><code>new()</code></li>
<li><code>delete()</code></li>
</ul></li>
<li><strong>stack</strong> 栈(<code>addr=max</code>)
<ul>
<li>local function invoking</li>
<li>local variables calling</li>
</ul></li>
</ul>
<p><strong>example</strong>: <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>  <span class="hljs-built_in">f1</span>();<br>  <span class="hljs-type">int</span>* pointer = <span class="hljs-literal">NULL</span>;<br>  pointer = <span class="hljs-type">int</span> <span class="hljs-built_in">new</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> <code>x</code> and
<code>b</code> are in <code>data</code> sector; <code>a</code> and
<code>f1()</code> are in <code>stack</code>; <code>pointer</code> points
to a space of <code>heap</code>.</p>
<p>HINT: there is a <u>flexible space</u> between <strong>heap</strong>
and <strong>stack</strong>.</p>
<h3 id="process-elements">Process elements</h3>
<ol type="1">
<li>program code (possible shared)</li>
<li>a set of data</li>
<li>a number of attributes describing the state of the process</li>
</ol>
<h3 id="trace-of-the-process">Trace of the process</h3>
<p>The behavior of an individual process is shown by <strong>listing the
sequence of instructions</strong> the are executed. (指令按序执行)</p>
<p>This list is called a <strong>trace</strong>.</p>
<p><strong>Dispatcher</strong> is a small program which switches the
processor from one process to another. (进程切换)</p>
<h2 id="user-view-of-process">User-view of process</h2>
<h3 id="process-creation">Process creation</h3>
<p>The OS builds a data structure to manage the process.</p>
<ul>
<li>Traditionally, the OS create all processes</li>
<li>But it can be useful to let a running process create another
<ul>
<li>This action is called <strong>process spawning</strong> (进程派生)
<ul>
<li>Parent process is the original, creating processes</li>
<li>Child process is the new process</li>
<li>Parent process create child process, and child processes create
other processes, <strong>forming a tree of process</strong>.</li>
</ul></li>
</ul></li>
<li>Execution (can be set manually)
<ul>
<li>parent processes and child processes execute concurrently
(同时执行).</li>
<li>parents wait when children terminate</li>
</ul></li>
</ul>
<p>HINT: the children just copy a status of parent</p>
<table>

<thead>
<tr class="header">
<th>command</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>fork</code></td>
<td>system call creates new <b>same</b> process</td>
</tr>
<tr class="even">
<td><code>exec</code></td>
<td>system call used after a <code>fork</code> to replace the process'
memory space with a <b>new program</b></td>
</tr>
</tbody>
</table>
<div class="note note-info">
            <h3id="the-differences-using-fork-in-parents-and-children-processes">Thedifferences using <code>fork()</code> in parents and childrenprocesses</h3><ol type="1"><li><p>fork返回给child_pid在两个进程中不一样.在父进程中<code>fork()</code>的返回值大于零, 即子进程的编号;在子进程中<code>fork()</code>的返回值是0.</p></li><li><p>可以理解为父进程在<code>fork()</code>的初期产生了子进程,此时子进程拿到的返回值是初始化的返回值 0,在父进程即将结束<code>fork()</code>时, 父进程拿到了被赋值的返回值.因此在子进程中不会再次执行<code>fork()</code>,而执行其后面的内容.</p></li><li><p>子进程不会再次执行父进程先前的内容,只是创建时与父进程处于相同的状态.</p></li><li><p>父子进程执行的先后顺序取决于 OS 的调度</p></li></ol>
          </div>
<p><strong>example 1:</strong> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">pid = fork();<br><span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>&#123;<br>  <span class="hljs-built_in">fprintf</span>(stdrr, <span class="hljs-string">&quot;fork failed&quot;</span>)<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)  <span class="hljs-comment">// child process</span><br>&#123;<br>  <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-literal">NULL</span>);  <span class="hljs-comment">// replace with a new command</span><br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">// parent process</span><br>&#123;<br>  <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;children complete&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p><strong>example 2:</strong> <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*in file fork.c:*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">pid_t</span> child_pid;<br>  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the main program ID is %d\n&quot;</span>, (<span class="hljs-type">int</span>)<span class="hljs-built_in">getpid</span>());<br><br>  child_pid = fork();<br>  <span class="hljs-keyword">if</span> (child != <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is the parent process, with ID is %d\n&quot;</span>, (<span class="hljs-type">int</span>)<span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the child&#x27;s process ID is %d\n&quot;</span>, (<span class="hljs-type">int</span>)child_pid);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is the child process, with ID %d\n&quot;</span>, (<span class="hljs-type">int</span>)<span class="hljs-built_in">getpid</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> And the running result
is:</p>
<h3 id="process-termination">Process termination</h3>
<p>Process executes last statement and asks the OS to delete it.
(<code>exit()</code>)</p>
<ul>
<li>Output data from child to parents (via<code>wait()</code>)</li>
<li>Process' resources are de-allocated (收回) by the OS</li>
</ul>
<p>Parents may terminate the execution of children processes.
(<code>abort()</code>)</p>
<p>Some situations of this:</p>
<ul>
<li>Child has executed allocated resources</li>
<li>Task assigned to child is non longer required</li>
<li>Parent is exiting
<ul>
<li>OS does not allow child to continue if its parent terminates</li>
<li>Cascading termination (级联终止)</li>
<li>HINT: 父进程结束不代表子进程必须结束</li>
</ul></li>
</ul>
<h3 id="code-block">Code block</h3>
<p><strong>creating process:</strong></p>
<p><code>int fork(void);</code></p>
<ul>
<li>create a new process that is exact copy of current one</li>
<li>returns process ID of new process in parent</li>
<li>return 0 is child</li>
</ul>
<p><code>int waitpid(int pid, int *stat, int opt);</code></p>
<ul>
<li>pid: process <strong>to wait for</strong>, or -1 for any</li>
<li>stat: will contain exit value, or signal</li>
<li>opt: usually 0 or WNOHANG (?what's this)</li>
<li>return: process ID or -1 if error</li>
</ul>
<p><strong>deleting process:</strong></p>
<p><code>void exit(int status);</code></p>
<ul>
<li>current process ceases to exit</li>
<li>status shows up in waitpid(shifted)</li>
<li>by convention, status of 0 is successful, non-zero is error</li>
</ul>
<p><code>int kill(int pid, int sig);</code></p>
<ul>
<li>sends signal <code>sig</code> tp to process <code>pid</code></li>
<li><code>sig=SIGTERM</code>: most common value, kills process by
default</li>
<li>application can catch ti for "cleanup"</li>
<li><code>sig=SIGKILL</code>: stronger, kills process always</li>
</ul>
<p><strong>running programs:</strong></p>
<p><code>int execve(char *prog, char **argv, char **envp);</code></p>
<p><code>int execlp(char *prog, char *arg, ...);</code></p>
<h2 id="kernel-view-of-process-using-process-control-block-pcb">Kernel
view of process (using Process Control Block, PCB)</h2>
<p><strong>Main problem: How to manage such many process?</strong></p>
<p>For traditional UNIX process: process is an abstraction of OS, which
represents what is needed to run a program.</p>
<ul>
<li>often called a "HeavyWeightProcess"</li>
<li>while a thread is called "轻量级"</li>
</ul>
<p>This <strong>traditional</strong> process has two parts:</p>
<ol type="1">
<li>sequential program execution stream. (now is thread)
<ol type="1">
<li>code executed as a sequential stream of execution (thread)</li>
<li>includes states of CPU registers</li>
</ol></li>
<li>protected resources
<ol type="1">
<li>main memory state</li>
<li>IO state</li>
</ol></li>
</ol>
<h3 id="process-elements-1">Process Elements</h3>
<ul>
<li>identifier</li>
<li>state</li>
<li>priority</li>
<li>program counter (in fact has many registers, not only the PC)</li>
<li>memory pointers</li>
<li>context data</li>
<li>IO status information</li>
<li>accounting information</li>
<li>and so on</li>
</ul>
<h3 id="implementing-process">Implementing process</h3>
<p>内核如何实现一个进程? 管理一个进程?</p>
<p><strong>keep a data structure for each process</strong></p>
<ul>
<li><font color=red><b>process control block (PCB)</b></font></li>
<li>called "proc" in Unix and "task_struct" in Linux</li>
</ul>
<p><strong>track states of process</strong> ----"Process State"</p>
<ul>
<li>running, waiting, ready...</li>
</ul>
<p><strong>includes information necessary to run</strong></p>
<ul>
<li>registers, virtual memory mapping, open files...</li>
</ul>
<p><strong>Various other data about the process</strong></p>
<ul>
<li>such as user/groups...</li>
</ul>
<div class="note note-info">
            <p>PCB is also a <strong>snapshot</strong> of a process, saving allstatus of a process.</p>
          </div>
<h3 id="process-states">Process states</h3>
<p><strong>new</strong>: the process is being created</p>
<p><strong>ready</strong>: the process is waiting to be assigned to a
processor</p>
<p><strong>running</strong>: instructions are being executed</p>
<p><strong>waiting</strong>: the process is waiting for some event to
occur</p>
<p><strong>terminated</strong>: the process has finished execution</p>
<p>The process switching graph is shown as following:</p>
<figure>
<img src="process_state.jpg" alt="process_state" />
<figcaption aria-hidden="true">process_state</figcaption>
</figure>
<p>The CPU switch from process to process:</p>
<figure>
<img src="switch_state.jpg" alt="state_switch" />
<figcaption aria-hidden="true">state_switch</figcaption>
</figure>
<p>when to switch processes:</p>
<ul>
<li>interrupt</li>
<li>trap
<ul>
<li>current process running is wrong</li>
</ul></li>
<li>system call</li>
</ul>
<p>switch steps:</p>
<ul>
<li>save context of processor including program counter and other
registers</li>
<li>update the PCB that is currently in the Running state</li>
<li>move the PCB to appropriate queue</li>
<li>select another process for execution</li>
<li>update the PCB of the process selected</li>
<li>update memory-management data structures</li>
<li>restore context of the selected process</li>
</ul>
<h3 id="process-scheduling-queues">Process scheduling queues</h3>
<p><strong>Job queue</strong>: set of all processes in the system</p>
<p><strong>Ready queue</strong>: set of all processes residing in main
memory, <strong>ready</strong> and waiting to execute</p>
<p><strong>Device queue</strong>: set of processes
<strong>waiting</strong> for an I/O device</p>
<div class="note note-info">
            <p>Process migration between the various queue.</p>
          </div>
<figure>
<img src="queue_switch.jpg" alt="queue_switch" />
<figcaption aria-hidden="true">queue_switch</figcaption>
</figure>
<h3 id="scheduler">Scheduler</h3>
<p><strong>Long-term scheduler(Job scheduler)</strong>: select which
processes should be loaded into memory for execution.</p>
<p><strong>Short-term scheduler(CPU scheduler)</strong>: selects which
process should be executed next and allocates CPU</p>
<p>Short-term scheduler is invoked very frequently (milliseconds----must
be fast)</p>
<p>Long-term scheduler is invoked very infrequently (seconds,
minutes----may be slow)</p>
<p>The long-term scheduler controls the <em>degree of
multiprogramming</em></p>
<ul>
<li>IO-bound process: spends more time doing IO than computations, many
shout CPU bursts</li>
<li>CPU-bound process: spends more time doing computations, few very
long CPU burst</li>
</ul>
<p>We also have <strong>Medium-term scheduler</strong></p>
<h2 id="inter-process-communication">Inter-process communication</h2>
<h3 id="cooperating-process">Cooperating process</h3>
<p>Independent process cannot affect or be affected by the execution of
another process.</p>
<p>Cooperation process can affect or be affected by the execution of
another process.</p>
<div class="note note-info">
            <h3 id="advantages">Advantages</h3><ul><li>information sharing</li><li>computation speed-up</li><li>modularity</li><li>convenience</li></ul>
          </div>
<h3 id="communication-models">Communication models</h3>
<p><strong>message model</strong></p>
<ul>
<li>smaller data exchange</li>
<li>inter-computer communication (跨机的通信)</li>
<li>system call with kernel</li>
</ul>
<p><strong>shared memory</strong></p>
<ul>
<li>Maximum speed/memory</li>
<li>convenience of communication</li>
<li>protection and synchronization</li>
<li>routine memory access without kernel intervention</li>
</ul>
<p><strong>Producer-Consumer Problem</strong>: Paradigm for cooperating
processes, producer process produces information that is consumed by a
consumer process</p>
<p><strong>POSIX shared memory example</strong></p>
<table>

<thead>
<tr class="header">
<th>Cmd</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>shmget()</code></td>
<td>A process creates a shared memory segment using this function</td>
</tr>
<tr class="even">
<td><code>shmctl()</code></td>
<td>the original owner of a shared memory segment cna assign ownership
to another user with this function</td>
</tr>
<tr class="odd">
<td><code>shmat()</code></td>
<td>Once created, a shared memory segment can be attached to a process
address space using this</td>
</tr>
<tr class="even">
<td><code>shmdt()</code></td>
<td>shared segment can be detached using this</td>
</tr>
</tbody>
</table>
<p><strong>Inter-process Communication</strong>(IPC)</p>
<p>Two operations:</p>
<ul>
<li><strong>send(message)</strong></li>
<li><strong>receive(message)</strong></li>
</ul>
<p>if P and Q wish to communicate, they need to</p>
<ul>
<li>establish a communication link between them</li>
<li>exchange messages via send/receive</li>
</ul>
<p><strong>Direct Communication</strong></p>
<ul>
<li>Processes must name each other explicitly:
<ul>
<li><code>send(P, message)</code>----send a message to P</li>
<li><code>receive(Q, message)</code>----receive message from Q</li>
</ul></li>
<li>Properties of communication link:
<ul>
<li>links are established automatically</li>
<li>a link is associated with exactly one pair of communication
processes</li>
<li>between each pair processes, there exists exactly one link</li>
<li>the link may be unidirectional, but is usually bidirectional</li>
</ul></li>
</ul>
<p><strong>Indirect Communication</strong></p>
<ul>
<li>Operations:
<ul>
<li>creates a new mailbox</li>
<li>send and receive messages through mailbox</li>
<li>destroy a mailbox</li>
</ul></li>
<li>Primitives are defined as:
<ul>
<li><code>send(A, message)</code>----send a message to mailbox A</li>
<li><code>receive(A, message)</code>----receive a message from mail box
A</li>
</ul></li>
<li>Problems: P1, P2 and P3 share mailbox A, P1 sends, P2 and P3
receive, who get the message?
<ul>
<li>Allows a link to be associated with at most two processes</li>
<li>Allow only one process process at a time to execute s receive
operation</li>
<li>Allow the system to select arbitrarily the receiver. Sender is
notified who the receiver was.</li>
</ul></li>
</ul>
<p><strong>Synchronization</strong> Message passing may be either
blocking(阻塞), or non-blocking(非阻塞)</p>
<p><strong>Buffering:</strong></p>
<ul>
<li>zero capacity</li>
<li>bounded capacity</li>
<li>unbounded capacity</li>
</ul>
<p><strong>Pipe</strong> <code>|</code> or <code>Pipe()</code>, there is
a <strong>read end</strong> and a <strong>write end</strong></p>
<p><strong>Three communication methods</strong></p>
<ul>
<li>shared memory</li>
<li>pipe</li>
<li>sockets</li>
</ul>
<h1 id="threads">Threads</h1>
<h2 id="concept-1">Concept</h2>
<p>A <strong>thread</strong> (lightweight process, LWP) is a basic unit
of CPU execution.</p>
<ul>
<li>a sequential execution stream within process</li>
</ul>
<p>A thread has a <em>thread ID</em>, a <em>program counter</em>, a
<em>register set</em> and a <em>stack</em>.</p>
<p>A thread <strong>shares</strong> with each other threads in the
<strong>same</strong> process <strong>its code section, data section,
and other OS resources(e.g. files and signals)</strong></p>
<p><strong>Multithreading</strong>: a single program made up of a number
of different concurrent activities.</p>
<h2 id="actual-thread-operations">Actual thread operations</h2>
<table>

<thead>
<tr class="header">
<th>cmd</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>thread_fork(func, args)</code></td>
<td>create a new thread to run func(args)</td>
</tr>
<tr class="even">
<td><code>thread_yield()</code></td>
<td>relinquish processor voluntarily</td>
</tr>
<tr class="odd">
<td><code>thread_join(thread)</code></td>
<td>in parent, wait for forked thread to exit, then return</td>
</tr>
<tr class="even">
<td><code>thread_exit()</code></td>
<td>quit thread and clean up, wake up joiner if any</td>
</tr>
</tbody>
</table>
<p><strong>pThreads: POSIX standard for thread programming</strong></p>
<p><strong>thread switching faster than process switching(100
ns)</strong></p>
<h2 id="user-thread">User Thread</h2>
<p>thread management done by user-level thread library: e.g. POSIX
Pthread, Mach C-threads, Solaris UI-threads</p>
<p>User thread are supported at the user-level, the kernel is not aware
of user threads(kernel treat them as processes). A library provides all
support for thread creation, termination, joining and scheduling. There
is no kernel intervention and hence, <strong>user threads are more
efficient.</strong> Unfortunately, since the kernel only recognizes the
containing process (of the threads), <strong>if one thread is blocked,
every other threads of the same process are also blocked</strong>
because the containing process is blocked.</p>
<h2 id="kernel-threads">Kernel Threads</h2>
<p>Supported by the kernel. Kernel maintains context information for the
process and the threads.</p>
<p>Kernel threads are directly supported by the kernel. THe kernel dose
thread creation, termination, joining and scheduling in kernel space.
<strong>Kernel threads are usually slower than the user
threads.</strong> However, <strong>blocking one thread will not cause
other threads of the same process to block.</strong> The kernel simply
<strong>runs other threads</strong> In a multi-processor environment,
the kernel can schedule threads on different processors.</p>
<p>The kernel has a <strong>thread table</strong> that keeps track of
all the threads in the system. All calls that might block a thread are
implemented as system calls. When a thread blocks, the kernel can run
either another thread from the same process or a thread from a different
process.</p>
<h2 id="multi-threading-models">Multi-threading Models</h2>
<h3 id="many-to-one">Many-to-one</h3>
<p>Many user-level threads mapped to single kernel thread. Used on
system that do not support kernel thread.</p>
<h3 id="one-to-one">One-to-one</h3>
<p>Each user-level thread maps to kernel thread.</p>
<h3 id="many-to-many">Many-to-Many</h3>
<p>Allow many user threads to be mapped to many kernel threads.</p>
<p>Allows the OS to create a sufficient number of kernel threads.</p>
<h2 id="threading-issues">Threading Issues</h2>
<h3 id="semantics-of-fork-and-exec">Semantics of <code>fork()</code> and
<code>exec()</code></h3>
<p>Does <code>fork()</code> duplicate only the calling thread or all
threads? (应该复制所有线程还是指定线程)</p>
<ul>
<li>if invoke <code>exec()</code> just after <code>fork()</code>, no
need to duplicate all threads, since it is no meaning to duplicate all
threads now that they will be replaced right after
<code>fork()</code></li>
<li>if invoke <code>exec()</code> after <code>fork()</code> for a long
time, it will duplicates all threads</li>
</ul>
<h3 id="thread-cancellation">Thread Cancellation</h3>
<p>Terminating a thread before it has finished, two general
approaches:</p>
<ul>
<li>Asynchronous cancellation (terminate thread
<strong>immediately</strong>)</li>
<li>Deferred cancellation (thread check itself if it should be cancelled
periodically)</li>
</ul>
<h3 id="signal-handling">Signal handling</h3>
<p>Signal is used to notify a process that a particular event has
occurred. All signal has same patterns:</p>
<ul>
<li>generated by particular event</li>
<li>delivered to a process</li>
<li>signal is handled</li>
</ul>
<p>A signal handler is used to process signals</p>
<div class="note note-info">
            <h3 id="options">options</h3><ul><li>deliver the signal to the thread to which the signal applies</li><li>deliver the signal to every thread in the process</li><li>~ to certain threads</li><li>Assign a specific thread receive all signals for the process</li></ul>
          </div>
<h3 id="thread-pools">Thread Pools</h3>
<p>Create a number of threads in a pool where they await work.</p>
<div class="note note-info">
            <h3 id="advantages">Advantages</h3><ul><li>Usually slightly faster to service a request with an exiting threadthan create a new thread.</li><li>Allows the number of threads in the application(s) to be bound tothe size of pool.</li></ul>
          </div>
<h3 id="thread-specific-data">Thread Specific Data</h3>
<p>Allows each thread to have its own <strong>copy</strong> of data</p>
<h3 id="scheduler-activations">Scheduler Activations</h3>
<p>Both M:M and Two-level models require communication to maintain the
appropriate number of kernel threads allocated to the application</p>
<p>一种解决解决用户线程库和内核间通信的方法被称为
<strong>调度器激活</strong>.</p>
<p>Scheduler activations provides <strong>upcalls</strong>, a
communication mechanism from the kernel to the thread library.
上级调用用于告知用户程序特定的事件</p>
<h1 id="cpu-scheduling-important">CPU Scheduling (Important!)</h1>
<p><strong>Objective: design a scheduling algorithm for CPU. (select
time point, select jobs to execute)</strong></p>
<p>Maximum CPU utilization obtained with multiprogramming</p>
<p>CPU-I/O Burst cycle: Process execution consists of a cycle of CPU
execution and I/O wait.</p>
<p>Process execution repeats the CPU burst and I/O burst cycle. When a
process begins an I/O burst, another process can use the CPU for a CPU
burst.</p>
<div class="note note-info">
            <h3 id="cpu-io-bound">CPU, I/O bound</h3><ul><li>CPU bound: a process generates I/O requests infrequently, using moreof its time doing computation</li><li>I/O bound: a process spends more of its time to do I/O than doingcomputation</li></ul>
          </div>
<p><strong>CPU Scheduler:</strong> When the CPU is idle, the OS mus
select another process to run. The selected process is carried out by
<strong>the short-term scheduler(CPU scheduler)</strong>. The CPU
scheduler selects a process from the ready queue, and allocates the CPU
resources to it. The ready queue does not have to be a FIFO one. There
are many ways to organize the ready queue.</p>
<h2 id="circumstances-that-scheduling-may-take-place">Circumstances that
scheduling may take place</h2>
<ol type="1">
<li>running -&gt; wait (e.g. doing for I/O)</li>
<li>running -&gt; ready (e.g. interrupt occurs)</li>
<li>wait -&gt; ready (e.g. I/O completion)</li>
<li>terminates</li>
</ol>
<figure>
<img src="scheduler_time.png" alt="scheduler_time" />
<figcaption aria-hidden="true">scheduler_time</figcaption>
</figure>
<p><strong>Non-preemptive scheduling (非抢占式调度):</strong> scheduling
occurs when a process <strong>voluntarily</strong> enters the wait state
or terminates----simple, but very inefficient</p>
<p><strong>Preemptive scheduling (抢占式调度):</strong> scheduling
occurs in all possible cases.</p>
<p><strong>Dispatcher:</strong> gives control of the CPU to the process
selected by the short-term scheduler, involves: <em>switching context,
switching to user mode, jumping to the proper location in the user
program to restart that program.</em></p>
<p><strong>Dispatcher latency:</strong> time it takes for the dispatcher
to stop one process and start another running</p>
<h2 id="scheduling-criteria-调度准则">Scheduling Criteria
(调度准则)</h2>
<p>Five common ones:</p>
<ul>
<li>CPU utilization (max)
<ul>
<li>want to keep CPU as busy as possible</li>
</ul></li>
<li>throughput (吞吐量) (max)
<ul>
<li>the number of processes completed per time unit</li>
<li>long processes: rate is low, short processes: rate is high</li>
</ul></li>
<li>turnaround time (周转时间) (min)
<ul>
<li>the time period <strong>between job submission to
completion</strong></li>
<li>including:
<ul>
<li>waiting time before entering the system</li>
<li>waiting time in the ready queue</li>
<li>waiting time in all other events (e.g. I/O)</li>
<li>time the process actually running on the CPU</li>
</ul></li>
</ul></li>
<li>waiting time (min)
<ul>
<li>the sum of the periods that a process spends waiting <strong>in the
ready queue.</strong> (because CPU scheduling algorithm do not affect
the amount of time during which a process is waiting for I/O and other
events, so we consider waiting time in ready queue only)</li>
</ul></li>
<li>response time (min)
<ul>
<li>the time from the submission of a request to the first response (in
an interactive system).</li>
<li>do <strong>not</strong> include the time that it takes to output the
response</li>
</ul></li>
</ul>
<h2 id="scheduling-algorithm">Scheduling Algorithm</h2>
<ul>
<li>First-Come, First-Served (FCFS)</li>
<li>Shortest-Job-First (SJF)</li>
<li>Priority</li>
<li>Round-Robin</li>
<li>Multilevel Queue</li>
<li>Multilevel Feedback Queue</li>
</ul>
<h3 id="fcfs">FCFS</h3>
<p><strong>description</strong>: the process that requests the CPU first
is allocated the CPU first</p>
<p><strong>Queue</strong></p>
<p><strong>Non-preemptive</strong>: once a process has the CPU, it will
occupy the CPU until the process completes or voluntarily enters the
wait state.</p>
<p><strong>Gantt Chart</strong> <img src="gantt.png" alt="gantt" /></p>
<p><strong>average waiting time</strong>: calculate</p>
<p><strong>convoy effect (护航效应)</strong>: short processes behind
long processes</p>
<div class="note note-info">
            <h3 id="disadvantages">disadvantages</h3><ul><li>convoy effect: all the processes wait for one big process to get offthe CPU. CPU utilization may be low.</li><li>not be fair to those short ones.</li><li>troublesome for time-sharing system, where each user needs to get ashare of the CPU at regular intervals.</li></ul>
          </div>
<h3 id="sjf">SJF</h3>
<p><strong>use each process' CPU burst length----shortest the
first</strong>: when a process must be selected from the ready queue,
the process with smallest next CPU burst is selected. The processes in
the ready queue are sorted in CPU burst length</p>
<p><strong>if non-preemptive:</strong> once the CPU is given to the
process, it cannot be preempted until completes its CPU burst</p>
<p><strong>if preemptive:</strong> if a new process arrives with less
CPU burst length than <strong>remaining</strong> time of others, it will
be selected immediately.</p>
<ul>
<li><strong>shortest-remaining-time-first(SRTF)</strong></li>
</ul>
<p><strong>SJF is optimal</strong>: gives minimum average waiting time
for a given set of processes.</p>
<p><strong>some examples:</strong> <img src="nonpree.png"
alt="nonpree" /></p>
<figure>
<img src="pree.png" alt="pree" />
<figcaption aria-hidden="true">pree</figcaption>
</figure>
<div class="note note-info">
            <h3 id="how-to-know-the-next-cpu-burst">how to know the next CPUburst?</h3><p>predict: using the length of previous CPU bursts, using<strong>exponential averaging</strong></p><p><span class="math display">\[\tau_{n+1}=\alpha t_n + (1-\alpha)\tau_n\]</span></p><ol type="1"><li><span class="math inline">\(t_n=\)</span>actual length of <spanclass="math inline">\(n^{th}\)</span> CPU burst</li><li><span class="math inline">\(\tau_{n+1}=\)</span>predicted value forthe next CPU burst</li><li><span class="math inline">\(\alpha\in[0,1]\)</span></li></ol><p>this is a weighted equation for history data and current data</p>
          </div>
<div class="note note-info">
            <h3 id="disadvantages">disadvantages</h3><ul><li>difficult to estimate the next burst time value accurately</li><li>in favor of short jobs. some long time jobs have no chance to run.(starvation)</li></ul>
          </div>
<h3 id="priority">Priority</h3>
<p>Priority may be determetered internally or externally. FCFS and SJF
are the special cases of Priority.</p>
<p><strong>non-preemptive</strong></p>
<p><strong>preemptive:</strong> if the newly arrived process has higher
priority, it is selected.</p>
<p>but indefinite block (or starvation) may occur: a low priority
process may never have a chance to run</p>
<p><strong>method:</strong></p>
<p><strong>Aging:</strong> gradually increases the priority of processes
that wait in the system for a long time. It is a technique to overcome
the starvation problem.</p>
<h3 id="round-robin-rr">Round Robin (RR)</h3>
<p>Similar to FCFS, except that each process is assigned a <strong>time
quanntum</strong></p>
<ul>
<li>All processes are in the ready queue (FIFO list). When the CPU is
free and lets it run for one time quantum.</li>
<li>If a process uses CPU for more than one time quantum, it is moved to
the <strong>tial</strong> of the list.</li>
</ul>
<div class="note note-info">
            <h3 id="some-issues">Some issues</h3><ul><li>if time quantum is too large, RR reduces(退化) to FCFS</li><li>if time quantum is too small, RR becomes <strong>processorsharing</strong></li><li>context switching may affect the performance of RR, shorter timequantum means more context</li><li>turnaround time dependes on the size of time quantum</li><li>in general, 80% of the CPU burst should shorter than the timequantum</li></ul>
          </div>
<h3 id="multilevel-queue-多级队列">Multilevel Queue (多级队列)</h3>
<p>Ready queue is partitioned into separate queues: foreground
(interactive), background (batch)</p>
<p>[
有些进程希望保留在系统中(交互进程)，而有些进程则是后台进程，因此可以延迟执行。]</p>
<p>Each process is assigned permanently to one queue based on some
properties of the process</p>
<p>Each queue has its own scheduling algorithm:</p>
<ul>
<li>foreground, interactive----RR</li>
<li>bacjground, batch----FCFS</li>
</ul>
<h4 id="hint">Hint</h4>
<p>scheduling must be done between the queue:</p>
<ul>
<li>fixed <strong>priority</strong> scheduling(i.e. serve all from
foreground then from background); Possibility of starvation.</li>
<li>time quantum, each queue gets a certain amount of CPU time which it
can amongst its processes</li>
</ul>
<h3 id="multilevel-feedback-queue-多级反馈队列">Multilevel Feedback
Queue (多级反馈队列)</h3>
<p>allows processes to move between queues. (can be implemented by
aging)</p>
<p>if a processe uses more CPU time, it is moved to a queue of lower
priority.</p>
<p>defined my the following parameters:</p>
<ul>
<li>numbers of queues</li>
<li>scheduling algorithm for each queue</li>
<li>method used to determine when to upgrade a process</li>
<li>method used to determine when to demote a process</li>
<li>method used to determine which queue process will enter whne that
process needs services</li>
</ul>
<h2 id="multiple-process-scheduling">Multiple-Process scheduling</h2>
<p><em>Symmetric multiprocessing</em>--self scheduling for each
processor</p>
<p><em>Affinity</em>(亲和性)--cost of cache: 当进程在 CPU 间切换时,
需要对 cache 进行重构. 需要避免 cache 重构所带来的开销</p>
<p><em>Hyperthreading</em>--logical processors seen by CPU (i.e. by
setting BIOS)</p>
<h2 id="thread-scheduling">Thread scheduling</h2>
<p><em>Local scheduling</em>--how the threads library decides which
thread to put onto an available LWP</p>
<p><em>Global scheduling</em>--how the kernel decides which kernel
thread to run next</p>
<h2 id="algorithm-evaluation">Algorithm Evaluation</h2>
<p>no notes here.</p>
<h1 id="process-synchronization">Process Synchronization</h1>
<p>进程合作时, 几个进程之间会相互影响.
合作的进程要么会直接共享逻辑地址空间 (即代码和数据),
要么通过共享内存或信息传递的方式进行通信.
但是并发的进程对数据操作可能会导致数据的不一致,
因此需要进程间进行同步.</p>
<p>进程同步--抽象为临界区问题--提出三种解决方案 (软件方案, 硬件方案,
信号量方案)--经典同步问题--管程 (相对高级的同步结构)--补充例子 ##
Background Concurrent access to shared data may result in data
inconsisitency. Maintaining data consistency requires mechanisms to
ensure the <strong>orderly execution</strong> of coorperating processes.
Such as <em>producer-consumer problem</em> need a mechanism to ensure
the order of execution.</p>
<h3 id="race-condition">Race Condition</h3>
<p>Race condition occurs, if:</p>
<ul>
<li>2 or more processes/threads access and manipulate the same data
concurrently</li>
<li>the outcome of the execution depends on the particular order in
which the access takes place.</li>
</ul>
<div class="note note-info">
            <p>to prevent race conditions, concurrent processes must be<strong>synchronized</strong></p>
          </div>
<h2 id="the-critical-section-problem-临界区问题">the critical-section
problem (临界区问题)</h2>
<p>Each process has a <strong>code segment</strong>, called
<strong>critical-section</strong>, in which the shared data is
accessed.</p>
<p>Problem: ensure that when one process is executing in its critical
section, no other process is allowed to execute in its critical section.
So it's necessary to design a protocol that processes can use to
cooperate.</p>
<p>A <strong>protocol</strong> consists of two parts: entry section and
exit section. Between them is the critical section running in a mutually
exclusive way.</p>
<div class="note note-info">
            <h3 id="condition-must-be-followed">condition must be followed</h3><ul><li><strong>Mutual exclusion (互斥)</strong><ul><li>If there is a process exexuting in critical section, the<strong>entry protocol</strong> should be capable of blocking processesthat wish to enter. And if the process in critical exits, the entryprotocol must know the fact, and allows a waiting process to enter.</li></ul></li><li><strong>Progress (前进/有空让进)</strong><ul><li>If no process is executing in its critical section and someprocesses wish to enter critical sections, then only those processesthat are waiting to enter can participate in the competition; no otherprocess can influent the decision; this decision cannot be postponedindefinitely (不可无限推迟).</li></ul></li><li><strong>Bounded waiting (有限等待)</strong><ul><li>After a process made a request to enter its critical section andbefore it is granted the permission to enter, there exits a<em>bound</em> on the time to wait (it means that, a process will notwait forever to enter it critical section).</li></ul></li></ul><p>HINT:the solution to critical-section problem cannot depend onrelative speed of processes and scheduling policy.</p>
          </div>
<p><strong><em>We should design a solution to satisfy the three
condition.</em></strong> (临界区问题需要满足以上三种条件)</p>
<p><strong>For two process condition:</strong> (Peterson algorithm,
Important!) <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">do</span> &#123;<br>    flag[i] = <span class="hljs-literal">true</span>;<br>    turn = j;<br>    <span class="hljs-keyword">while</span> (flag[j] == <span class="hljs-literal">true</span> &amp;&amp; turn == j);<br>    <span class="hljs-comment">// critical section</span><br>    flag[i] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// remainder section</span><br>&#125;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></p>
<p><strong><em>ref:<a
href="https://zhuanlan.zhihu.com/p/374287625">peterson
algorithm</a></em></strong></p>
<h2 id="synchronization-hardware">Synchronization hardware</h2>
<p>Two types: <strong>disabling enabling interrupts</strong> close
interrupt if a process in critical section; <strong>Special machine
instructions</strong>.</p>
<h3 id="interrupt-disabling">Interrupt disabling</h3>
<p>Because interrupts are disabled, no context switch will occur in a
critical section. Infeasible in a multiprocessor system because all CPUs
must be informed. Some features that depend on interrupts (e.g. clock)
may not work properly.</p>
<h3 id="using-atomaical-instructions">Using Atomaical instructions</h3>
<p>Test and modify the content of a word
<strong>atomically</strong>.</p>
<div class="note note-info">
            <p><u>atomical instructions</u> mean an instruction that can't bedevided or interrupted.</p>
          </div>
<p><strong>Test-and-Set</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// define the test and set function</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TestAndSet</span> <span class="hljs-params">(<span class="hljs-type">bool</span> *lock)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> rt = *lock;<br>  *lock = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> rt;<br>&#125;<br><span class="hljs-comment">// shared data:</span><br><span class="hljs-type">bool</span> lock = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// process P_i</span><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">TestAndSet</span>(&amp;lock));<br>  <span class="hljs-comment">// critical section</span><br>  lock = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// remainder section</span><br>&#125;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<p><strong><em>the TestAndSet() function realizes that it changes all
processes' status to enter critical section, but <u>keeps the old value
of one process</u> which is going to enter critical section. <u>This
function satisfies Mutual Exception rule.</u> However, this mathod not
satisfies Bounded Waiting rule.</em></strong></p>
<p>Change TestAndSet to satisfy Bounded Waiting: <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// enter critical section</span><br>waiting[i] = <span class="hljs-literal">true</span>;<br>key = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (waiting[i] &amp;&amp; key) &#123;<br>  key = <span class="hljs-built_in">TestAndSet</span>(lock);<br>&#125;<br>waiting[i] = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// leave critical section</span><br>j = (i + <span class="hljs-number">1</span>) % n;<br><span class="hljs-keyword">while</span> ((j != <span class="hljs-number">1</span>) &amp;&amp; !waiting[j]) &#123;<br>  j = (j + <span class="hljs-number">1</span>) % n;<br>&#125;<br><span class="hljs-keyword">if</span> (j == i) &#123;<br>  lock = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  waiting[j] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>Though this is a <em>code</em> form, but TestAndSet() is realized in
hardware form.</p>
<p><strong>Swap</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;a, <span class="hljs-type">bool</span> &amp;b)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> temp = a;<br>  a = b;<br>  b = temp;<br>&#125;<br><span class="hljs-comment">// shared data, initializaed by false</span><br><span class="hljs-type">bool</span> lock = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// local data</span><br><span class="hljs-type">bool</span> key;<br><span class="hljs-comment">// for process P_i</span><br><span class="hljs-keyword">do</span> &#123;<br>  key = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">while</span> (key == <span class="hljs-literal">true</span>)<br>    <span class="hljs-built_in">Swap</span> (key, lock);<br>  <span class="hljs-comment">// critical section</span><br>  lock = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// remainder section</span><br>&#125;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<p><strong><em>The Swap() function will swap the value of lock and key,
if </em></strong></p>
<h2 id="semaphores-信号量-important">Semaphores (信号量,
Important!)</h2>
<p>Most used~<br />
Programmer-frendly~<br />
信号量可以看作是对资源数量的衡量, 用于临界区问题时, 由于临界区只有一个,
因此信号量设置为1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// atomic operator</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(S)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (S &lt;= <span class="hljs-number">0</span>);<br>  S--;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signal</span><span class="hljs-params">(S)</span> </span>&#123;<br>  S++;<br>&#125;<br><br><span class="hljs-comment">// algorithm</span><br><span class="hljs-comment">// shared data</span><br>semaphore mutex = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// for process p_i</span><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-built_in">wait</span>(mutex);<br>  <span class="hljs-comment">// critical section</span><br>  <span class="hljs-built_in">signal</span>(mutex);<br>  <span class="hljs-comment">// remainder section</span><br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<p><strong><em>semaphore algorithm satisfies three rules. semaphore is
like a lock. wait() lock, and signal() delock.</em></strong></p>
<p>the disadvantage is semaphore makes other processes <em>busy
waiting</em>, which do nothing while waiting. for single CPU, it waste
CPU resource. this is <strong>spinlock</strong>. spinlock is usually
used in multi-core system, one process can enter another CPU's critical
section while one process is in now critical section.</p>
<p><strong><em>the difference waiting state:</em></strong> <img
src="waiting_stat.png" alt="waiting_state" /></p>
<p><strong><em>ref:<a
href="https://blog.csdn.net/liuchuo/article/details/51986201">WaitingState</a></em></strong></p>
<p>Optimization: no busy-waiting</p>
<p>Makes one process not to busy-wait but to <strong>block
itself</strong> or <strong>mounted</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// define a new semaphore</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">int</span> value;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span> *L;  <span class="hljs-comment">// waiting process queue</span><br>&#125; semaphore;<br><br><span class="hljs-comment">// edit wait() and signal()</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(S)</span> </span>&#123;<br>  S.value--;<br>  <span class="hljs-keyword">if</span> (S.value &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// add this process to S.L</span><br>    block;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signal</span><span class="hljs-params">(S)</span> </span>&#123;<br>  S.value++;<br>  <span class="hljs-keyword">if</span> (S.value &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// remove a process P from S.L</span><br>    <span class="hljs-built_in">wakeup</span>(P);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <h3 id="deadlock">Deadlock</h3><p>two or more processes are waiting indefinitely for an event that canbe caused by only one of the waiting processes.</p><h3 id="starvation">Starvation</h3><p>indefinite blocking. A process may never be removed from thesemaphore queue in which it is suspended.</p>
          </div>
<h2 id="classical-problems-of-synchronization">Classical problems of
Synchronization</h2>
<ul>
<li>bounded-buffer problem</li>
<li>reader and writer problem</li>
<li>dining philosophers problem</li>
</ul>
<h3 id="bounded-buffer-problem">Bounded buffer problem</h3>
<p>生产者消费者问题: 存在若干生产者, 若干消费者以及一个缓冲区.
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// initialization shared data</span><br>semaphore full, empty, mutex;  <span class="hljs-comment">// full and empty relize the synchronization between consumer and producer, and also represent the resource.</span><br>full = <span class="hljs-number">0</span>;  <span class="hljs-comment">// </span><br>empty = n;  <span class="hljs-comment">// initial space</span><br>mutex = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前临界区没有进程, 当缓冲区大小为 1 时, 可以不用此变量.</span><br><br><span class="hljs-comment">// producer process:</span><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-comment">// code</span><br>  produce an item in nextp<br>  <span class="hljs-comment">// code</span><br>  <span class="hljs-built_in">wait</span>(empty);  <span class="hljs-comment">// judge if be full</span><br>  <span class="hljs-built_in">wait</span>(mutex);  <span class="hljs-comment">// buffer = 1 时, 可删</span><br>  <span class="hljs-comment">// code</span><br>  add nextp to buffer<br>  <span class="hljs-comment">// detail operation:</span><br>  buffer[in] = nextp;<br>  in = (in + <span class="hljs-number">1</span>) % bufferSize;  <span class="hljs-comment">// buffer = 1 时, 可删</span><br>  <span class="hljs-comment">// code</span><br>  <span class="hljs-built_in">signal</span>(mutex);  <span class="hljs-comment">// buffer = 1 时, 可删</span><br>  <span class="hljs-built_in">signal</span>(full);  <span class="hljs-comment">// inform</span><br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// consumer process</span><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-built_in">wait</span>(full);<br>  <span class="hljs-built_in">wait</span>(mutex);<br>  <span class="hljs-comment">// code</span><br>  remove an item from buffer to nextc<br>  <span class="hljs-comment">// detail operation</span><br>  a = buffer[out];<br>  out = (out + <span class="hljs-number">1</span>) % bufferSize;<br>  <span class="hljs-comment">// code</span><br>  <span class="hljs-built_in">signal</span>(mutex);<br>  <span class="hljs-built_in">signal</span>(empty);<br>  <span class="hljs-comment">// code</span><br>  consume the item in nextc<br>  <span class="hljs-comment">// code</span><br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></p>
<h3 id="reader-writer-problem">Reader-Writer Problem</h3>
<p>以数据库为背景, 同时有若干的写者和读者对数据库进行操作. 写时不可读,
读时不可写. 如何权衡进程通信?</p>
<p><strong>第一读者问题:</strong> 读者可以一直读, 除非有写者正在写.
说白了就是读者优先级高于写者.</p>
<p><strong>第二读者问题:</strong> 读者优先级低于写者.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// shared data</span><br>semaphore mutex, wrt;<br><span class="hljs-type">int</span> readcount;<br><span class="hljs-comment">// initailization</span><br>mutex = <span class="hljs-number">1</span>;<br>wrt = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 表示是否可以写, 或者是写的资源</span><br>readcount = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// writer</span><br><span class="hljs-built_in">wait</span>(wrt);<br><span class="hljs-comment">// writer is writing</span><br><span class="hljs-built_in">signal</span>(wrt);<br><br><span class="hljs-comment">// reader</span><br><span class="hljs-built_in">wait</span>(mutex);  <span class="hljs-comment">// 存在并发的读者程序</span><br>readcount += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (readcount == <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-built_in">wait</span>(wrt);  <span class="hljs-comment">// 第一个读者与写者进行权限的争抢</span><br>  <span class="hljs-comment">// 若抢到权限, 则后续读者无需再次判断, 登记读者数目后, 直接进行读的操作.</span><br>&#125;<br><span class="hljs-built_in">signal</span>(mutex);<br><span class="hljs-comment">// reader(s) are reading</span><br><span class="hljs-built_in">wait</span>(mutex);<br>readcount -= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (readcount == <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">signal</span>(wrt);  <span class="hljs-comment">// 最后一个读者释放对数据库操作的权限</span><br>&#125;<br><span class="hljs-built_in">signal</span>(mutex);<br></code></pre></td></tr></table></figure>
<h3 id="dining-philosophers-problem">Dining-Philosophers Problem</h3>
<p>问题描述: 有多个哲学家在一个圆桌上用餐. 相邻两人间放着
<strong>一支</strong> 筷子, 哲学家只能拿与自己相邻的筷子,
若拿到了两根筷子, 则可以用餐, 用完后放回. 但若只拿到一支筷子,
则等待另一支筷子并且不放下手中的筷子, 直到有两双筷子. 若一支也没有拿到,
则进行等待. 设计进程同步, 并防止 <strong>死锁</strong>.</p>
<p>假设有 5 个哲学家和 5 支筷子.</p>
<p><strong>Method 1(exit deadlock)</strong>: <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// shared data</span><br>semaphore chopsticks[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-comment">// for every philosopher i:</span><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-built_in">wait</span>(chopstick[i]);<br>  <span class="hljs-built_in">wait</span>(chopstick[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>  <span class="hljs-built_in">eat</span>();<br>  <span class="hljs-built_in">signal</span>(chopstick[i]);<br>  <span class="hljs-built_in">signal</span>(chopstick[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);<br>&#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure> 显然,
当每个哲学家都拿左边的筷子时, 会发生死锁现象.</p>
<p><strong>Solution 1</strong>: 设置一个"房间"作为信号量,
房间只能一次性供四个人使用</p>
<p><strong>Solution 2</strong>: 将拿起左筷子和右边筷子 (拿一双筷子)
作为一个原子操作, 将其放入临界区.</p>
<p><strong>Solution 3</strong>:
规定奇数和偶数序号的哲学家遵守不同的拿筷子的顺序: 奇数先左后右,
偶数先右后左.</p>
<p><strong><em><a
href="https://andrew-rey.github.io/2022/05/09/os-practice/">具体伪代码见操作系统习题</a></em></strong></p>
<h2 id="monitors">Monitors</h2>
<h2 id="synchronization-example">Synchronization example</h2>
<p>后面半本书没有写博客</p>
<p>结果是最后操作系统大寄</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>Pattern Recognition</title>
    <url>/2022/02/28/ML/PatternRecognition/</url>
    <content><![CDATA[<p>"This is really a great lesson."</p>
<p>"If there are no such many homework."</p>
<span id="more"></span>
<h1 id="introduction">Introduction</h1>
<h2 id="what-is-patter-recognition">What is Patter Recognition?</h2>
<ul>
<li>Pattern
<ul>
<li>the opposite of choas</li>
</ul></li>
<li>Recognition
<ul>
<li>Identification of a pattern as a member of a category</li>
<li><font color=blue>Classification</font>: category known <span
class="math inline">\(\Rightarrow\)</span> assign proper class label for
each pattern</li>
<li><font color=blue>Clustering</font>: category unknown <span
class="math inline">\(\Rightarrow\)</span> learn categories and group
patterns</li>
</ul></li>
<li>Pattern Recognition
<ul>
<li>Perceive (理解): interact with the real-world</li>
<li>Process (处理): learn to distinguish patterns of interest</li>
<li>Prediction (预测): make sound and reasonable decisions about the
categories</li>
</ul></li>
</ul>
<div class="note note-primary">
            <h3 id="previewthree-classification-ideas">preview:three classificationideas</h3><ul><li>estimate the class conditional function</li><li>estimate the posterior</li><li>calculate the discriminant function directly</li></ul>
          </div>
<h1 id="bayesian-decision-theory">Bayesian Decision Theory</h1>
<h2 id="basic-theory">Basic Theory</h2>
<h3 id="bayesian-formula">Bayesian Formula</h3>
<p><span class="math display">\[
P(\omega_i | \mathbf{x}) = \frac{P(\omega_i)p(\mathbf{x} |
\omega_i)}{p(\mathbf{x})}
\]</span> Where <span class="math inline">\(\omega_i(i = 1,\dots,
c)\)</span> is the category of research object. <span
class="math inline">\(\mathbf{x}\)</span> is the <strong>feature
vector</strong>, has <span class="math inline">\(d\)</span> dimensions.
We call <span class="math inline">\(P(\omega_i | \mathbf{x})\)</span>
<strong>posterior</strong>, <span
class="math inline">\(P(\omega_i)\)</span> <strong>prior
probability</strong> and <span class="math inline">\(p(\mathbf{x} |
\omega_i)\)</span> <strong>likelihood</strong> of <span
class="math inline">\(\mathbf{x}\)</span> in category <span
class="math inline">\(\omega_i\)</span>. Note that <span
class="math inline">\(p(\omega{x})\)</span> is a constant, we call it
<strong>evidence coefficient</strong>. <span class="math display">\[
p(\mathbf{x}) = \sum_{i = 1}^c P(\omega_i)p(\mathbf{x} | \omega_i)
\]</span></p>
<h3 id="loss-function">Loss function</h3>
<p>We use <span class="math display">\[
\lambda(\alpha_i | \omega_j)
\]</span> to describe the loss or penetrate we get since we take action
<span class="math inline">\(\alpha_i\)</span> while the true category is
<span class="math inline">\(\omega_j\)</span>.</p>
<h3 id="class-conditional-probability">Class-Conditional
Probability</h3>
<p>We define the <strong>class conditional probability</strong> relative
to the action <span class="math inline">\(\alpha_i\)</span> <span
class="math display">\[
R(\alpha_i | \mathbf{x}) = \sum_{j=1}^c \lambda(\alpha_i | \omega_j)
P(\omega_j | \mathbf{x})
\]</span> So the <strong>total risk</strong> is defined as: <span
class="math display">\[
R = \int_{feature\ space} R(\alpha_i | \mathbf{x}) p(\mathbf{x})
d\mathbf{x}
\]</span></p>
<h3 id="the-decision-theory">The Decision Theory</h3>
<p><strong>Bayesian Decision Theory</strong>: In order to minimize the
total risk <span class="math inline">\(R\)</span>, for <span
class="math inline">\(i = 1, \dots, a\)</span> we calculate the
class-conditional probability <span class="math display">\[
R(\alpha_i | \mathbf{x}) = \sum_{j=1}^c \lambda(\alpha_i | \omega_j)
p(\omega_j | \mathbf{x})
\]</span> and choose a proper action <span
class="math inline">\(\alpha_i\)</span> to make the <span
class="math inline">\(R(\alpha_i | \mathbf{x})\)</span> minimized.</p>
<h2 id="two-class-classification">Two-class classification</h2>
<p>The loss function is <span class="math display">\[
\lambda_{ij} \doteq \lambda(\alpha_i | \omega_j)
\]</span> And our class conditional function are: <span
class="math display">\[
\begin{aligned}
R(\alpha_1 | \mathbf{x}) &amp;= \lambda_{11} p(\omega_1 | \mathbf{x}) +
\lambda_{12} p(\omega_2 | \mathbf{x})\\
R(\alpha_2 | \mathbf{x}) &amp;= \lambda_{21} p(\omega_1 | \mathbf{x}) +
\lambda_{22} p(\omega_2 | \mathbf{x})
\end{aligned}
\]</span></p>
<p>The decision is: if <span class="math inline">\(R(\alpha_1 |
\mathbf{x}) &lt; R(\alpha_2 | \mathbf{x})\)</span>, then it means <span
class="math inline">\(\alpha_1\)</span> takes smaller risk, and so we
choose the action <span class="math inline">\(\alpha_1\)</span>.</p>
<p>Using the posterior probability to describe is: <span
class="math display">\[
(\lambda_{21} - \lambda_{11})P(\omega_1 | \mathbf{x}) &gt; (\lambda_{12}
- \lambda_{22})P(\omega_2 | \mathbf{x})
\]</span></p>
<p>Using the Bayes' Formula, converting the prior probability to
posterior probability: <span class="math display">\[
(\lambda_{21} - \lambda_{11})p(\mathbf{x} | \omega_1)P(\omega_1) &gt;
(\lambda_{12} - \lambda_{22})p(\mathbf{x} | \omega_2)P(\omega_2)
\]</span></p>
<p>Or writing with fraction form: <span class="math display">\[
\frac{p(\mathbf{x} | \omega_1)}{p(\mathbf{x} | \omega_2)} &gt;
\frac{\lambda_{12} - \lambda_{22}}{\lambda_{21} -
\lambda_{11}}\frac{P(\omega_2)}{P(\omega_1)}
\]</span></p>
<h2 id="the-minimum-error-classification">The Minimum-error
Classification</h2>
<p>We define the minimum-error classification is a problem that uses the
<strong>symmetric loss</strong> or <strong>"0-1" loss</strong>:</p>
<p><span class="math display">\[
\lambda(\alpha_i | \omega_j) = \left\{\begin{aligned}
&amp;0&amp;\ &amp;i=j,\\
&amp;1&amp;\ &amp;i\neq j
\end{aligned}\right.\ \ \ i,j = 1,\dots,c
\]</span></p>
<p>If you use this symmetric loss in a classification problem, you mean
<strong>all the error decisions make the same consequence</strong>.</p>
<p>Our decision is made based on conditional risk: <span
class="math display">\[
\begin{aligned}
R(\alpha_i | \omega_j) &amp;= \sum_{j = 1}^c \lambda_{ij} P(\omega_j |
\mathbf{x})\\
&amp;= \sum_{i\neq j} 1 \cdot P(\omega_j | \mathbf{x})\\
&amp;= 1 - P(\omega_i | \mathbf{x})
\end{aligned}
\]</span></p>
<h3 id="minimax-rule">Minimax Rule</h3>
<p>I will not write this part until I make it clear...</p>
<h2
id="the-discriminant-function-decision-surface-based-on-gaussian-distribution">The
Discriminant Function, Decision Surface Based on Gaussian
Distribution</h2>
<h3 id="gaussian-distribution">Gaussian Distribution</h3>
<p><span class="math display">\[
\begin{aligned}
\varphi(\mathbf{x}) =
\frac{1}{(2\pi)^{\frac{d}{2}}|\Sigma|^{\frac{1}{2}}}exp(-\frac{1}{2}(\mathbf{x}
- \mathbf{\mu})^T\Sigma^{-1}(\mathbf{x} - \mathbf{\mu}))
\end{aligned}
\]</span></p>
<h3 id="discriminant-function">Discriminant Function</h3>
<p>The discriminant function is defined as: we choose <span
class="math inline">\(i^{th}\)</span> class, if</p>
<p><span class="math display">\[
g_i(x)&gt;g_j(x)
\]</span></p>
<p>for <span class="math inline">\(\forall j\neq i\)</span>. And <span
class="math inline">\(g_i(x)\)</span> is called discriminant
function.</p>
<p>Based on minimum-error classification, the discriminant function can
be written as:</p>
<p><span class="math display">\[
\begin{aligned}
g_i(x)&amp;=-P(\omega_i|x) \\
&amp;=P(\omega_i|x) \\
&amp;=p(x|\omega_i)P(\omega_i)\ (Bayes&#39; Formula) \\
&amp;=lnp(x|\omega_i)+lnP(\omega_i)
\end{aligned}
\]</span></p>
<p>where the "=" means "equivalent" or "the same to".</p>
<p>Specially, if it's a two-class classification: <span
class="math display">\[
g(x)=g_1(x)-g_2(x)
\]</span> or <span class="math display">\[
g(x)=P(\omega_1|x)-P(\omega_2|x)
\]</span> or <span class="math display">\[
g(x)=ln\frac{p(x|\omega_1)}{p(x|\omega_2)}+ln\frac{P(\omega_1)}{P(\omega_2)}
\]</span> Correspondingly, we have <strong>decision boundary</strong>
and <strong>decision region</strong>.</p>
<h3
id="minimum-total-risk-based-on-gaussian-distribution-discriminant-function-discriminant-boundary">Minimum
total risk based on Gaussian distribution: Discriminant Function,
Discriminant Boundary</h3>
<p>On this section, we discuss the situation that <strong>the likelihood
submits Gaussian distribution</strong> and <strong>the loss is "0-1"
loss</strong>.</p>
<p><span class="math display">\[
p(x|\omega_i)=\frac{1}{(2\pi)^{d/2} |\Sigma_i| ^
{1/2}}exp(-\frac{1}{2}(x-\mu_i)^T\Sigma_i^{-1}(x-\mu_i))
\]</span></p>
<p><span class="math display">\[
\lambda(\alpha_i|\omega_j) = I(i\neq j)
\]</span></p>
<p><span class="math display">\[
g_i(x)=lnp(x|\omega_i)+lnP(\omega_i)=-\frac{1}{2}(x-\mu_i)^T
\Sigma_i^{-1}(x-\mu_i)-\frac{d}{2}ln2\pi-\frac{1}{2}ln|\Sigma|+lnP(\omega_i)
\]</span></p>
<p><b>Minimum distance classifier</b></p>
<p><strong>case 1a:</strong> suppose all prior probabilities are the
same</p>
<p><span class="math display">\[
P(\omega_i)=1/c\ \ \forall i \in (1,c)
\]</span></p>
<p>and all features have no relationships with others and all classes
have the same covariance matrices</p>
<p><span class="math display">\[
\Sigma_i=\sigma^2I\ \ \forall i \in (1,c)
\]</span></p>
<p>Discriminant function:</p>
<p><span class="math display">\[
\begin{aligned}
  g_i(x)&amp;=-\frac{1}{2}(x-\mu_i)^T\Sigma_i^{-1}(x-\mu_i)+constant \\
  g_i(x)&amp;=-\frac{1}{2\sigma^2}(x-\mu_i)^T(x-\mu_i)\ \ \ (Euclidean\
distance) \\
  g_i(x)&amp;=-\frac{1}{2\sigma^2}(x^Tx-2\mu_i^Tx+\mu_i^T\mu_i) \\
\end{aligned}
\]</span></p>
<p><span class="math inline">\(x^Tx\)</span> is independent with <span
class="math inline">\(\forall i\)</span>, so <span
class="math inline">\(x^Tx\)</span> is a constant when considering <span
class="math inline">\(i\)</span>.</p>
<p><span class="math display">\[  
g_i(x)=\frac{1}{\sigma^2}\mu_i^Tx-\frac{1}{2\sigma^2}\mu_i^T\mu_i  
\]</span></p>
<p>this is a <strong>linear discriminant machine</strong>.</p>
<p>Discriminant boundary:</p>
<p><span class="math display">\[  
g_i=g_j  
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
  &amp;\frac{1}{\sigma^2}\mu_i^Tx-\frac{1}{2\sigma^2}\mu_i^T\mu_i=
  \frac{1}{\sigma^2}\mu_j^Tx-\frac{1}{2\sigma^2}\mu_j^T\mu_j  \\
  &amp;\frac{1}{\sigma^2}(\mu_i^T-\mu_j^T)x -
\frac{1}{2\sigma^2}(\mu_i^T + \mu_j^T)(\mu_i - \mu_j)=0 \\
  &amp;\frac{1}{\sigma^2}(\mu_i-\mu_j)^T(x-\frac{1}{2}(\mu_i +
\mu_j))  =0 \\
\end{aligned}
\]</span></p>
<div class="note note-primary">
            <p>so the discriminant boundary must pass the point <spanclass="math inline">\(x=\frac{1}{2}(\mu_i + \mu_j)\)</span>, and isvertical with <span class="math inline">\((\mu_i-\mu_j)\)</span></p>
          </div>
<p><strong>case 1b:</strong> suppose all prior probabilities are the
same:</p>
<p><span class="math display">\[
P_i=1/c
\]</span></p>
<p>and all covariance are the same, but features have relationships with
each other:</p>
<p><span class="math display">\[
\Sigma_i=\Sigma
\]</span></p>
<p>Discriminant function: <span class="math display">\[
\begin{aligned}
&amp;g_i(x)=-\frac{1}{2}(x-\mu_i)^T\Sigma_i^{-1}(x-\mu_i)-\frac{1}{2}ln|\Sigma_i|+constant
\\
&amp;g_i(x)=-\frac{1}{2}(x-\mu_i)^T\Sigma_i^{-1}(x-\mu_i)-\frac{1}{2}ln|\Sigma|
\\
&amp;g_i(x)=-\frac{1}{2}(x-\mu_i)^T\Sigma_i^{-1}(x-\mu_i)\ \ \
(Mahalanobis\ distance) \\
&amp;g_i(x)=2\mu_i^T\Sigma^{-1}x-\mu_i^T\Sigma^{-1}\mu_i \\
\end{aligned}
\]</span></p>
<p>this is also a <strong>linear discriminant machine</strong>.</p>
<p>Discriminant boundary:</p>
<p><span class="math display">\[
(\Sigma^{-1}(\mu_i-\mu_j))^T(x-\frac{\mu_i+\mu_j}{2})=0
\]</span></p>
<div class="note note-primary">
            <p>the boundary crosses the middle point of <spanclass="math inline">\(\mu_i\)</span> and <spanclass="math inline">\(\mu_j\)</span>, but is not vertical with <spanclass="math inline">\(\mu_i-\mu_j\)</span> as <spanclass="math inline">\(\Sigma\)</span> provides a rotation with <spanclass="math inline">\(\mu_i-\mu_j\)</span>.</p>
          </div>
<p><strong>case 2a:</strong> suppose <span
class="math inline">\(P(\omega_i)\)</span> are not the same, while all
features have no relationships with others and all classes have the same
covariance matrices</p>
<p><span class="math display">\[
\Sigma_i=\sigma^2I\ \ \forall i \in (1,c)
\]</span></p>
<p>Discriminant function:</p>
<p><span class="math display">\[
  g_i(x)=2\mu_i^Tx-\mu_i^T\mu_i+2\sigma^2lnP(\omega_i)
\]</span></p>
<p>this is a <strong>linear discriminant machine</strong></p>
<p>Discriminant boundary:</p>
<p><span class="math display">\[
(\mu_i-\mu_j)^T(x-\frac{\mu_i+\mu_j}{2}-\frac{\sigma^2}{||\mu_i-\mu_j||^2}ln\frac{P(\omega_i)}{P(\omega_j)}(\mu_i-\mu_j))  
\]</span></p>
<p>if <span class="math inline">\(P(\omega_i)&gt;P(\omega_j)\)</span>,
then <span class="math display">\[  
\frac{\sigma^2}{||\mu_i-\mu_j||^2}ln\frac{P(\omega_i)}{P(\omega_j)}(\mu_i-\mu_j))&gt;0
\]</span> , it will cross a point that is closer to <span
class="math inline">\(\mu_j\)</span>.</p>
<p><strong>case 2b:</strong> suppose <span
class="math inline">\(P(\omega_i)\)</span> are not the same, while
covariance are the same, but features have relationships with each
other:</p>
<p><span class="math display">\[
\Sigma_i=\Sigma
\]</span></p>
<p>Discriminant function:</p>
<p><span class="math display">\[
g_i(x)=(\Sigma\mu_i)^Tx-\frac{1}{2}\mu_i^T\Sigma^{-1}\mu_i+lnP(\omega_i)  
\]</span></p>
<p>this is a <strong>linear discriminant machine</strong></p>
<p>Discriminant boundary:</p>
<p><span class="math display">\[
  (\Sigma(\mu_i-\mu_j))^T(x-\frac{1}{2}(\mu_i+\mu_j)-\frac{ln[P(\omega_i)/P(\omega_j)]}{(\mu_i-\mu_j)^T\Sigma(\mu_i-\mu_j)}(\mu_i-\mu_j))
\]</span></p>
<p><strong>case 3:</strong> suppose that <span
class="math inline">\(P(\omega_i)\)</span> are not the same as well as
covariance matrices, then the discriminant function is a quadric
function. The discriminant boundary will be more various.</p>
<h1 id="maximum-likelihood-estimation-and-bayesian-estimation">Maximum
Likelihood estimation and Bayesian estimation</h1>
<p>In the chapter 2, we suppose the likelihood function <span
class="math inline">\(p(x|\omega)\)</span> is known, but it impossible
to know about it in the daily life or experiments, so we must estimate
the likelihood function. Generally speaking, we have two methods to
solve this problem: the one is <strong>parameter estimation</strong> and
the other is <strong>non-parameter estimation</strong>.</p>
<p>In <strong>parameter estimation</strong>, we will give a prior model
of likelihood function of <span class="math inline">\(x\)</span> with
unknown parameters, and what we should do is estimating the parameters
using the data set.</p>
<h2 id="maximum-likelihood-estimation">Maximum Likelihood
estimation</h2>
<p>Use the <strong>parameterized form</strong> of class-conditional
density function (likelihood):</p>
<p><span class="math display">\[
p(x|\omega_i, \theta_i)
\]</span></p>
<p>As we solve all classes' parameters <strong>respectively</strong>, we
can simplify the denotation as:</p>
<p><span class="math display">\[
P(D|\theta)
\]</span></p>
<p>where <span class="math inline">\(D\)</span> means the data set of
class <span class="math inline">\(\omega_i\)</span>.</p>
<p>samples are i.i.d:</p>
<p><span class="math display">\[
p(D|\theta_i)=\prod_{k=1}^n p(x_k|\theta)
\]</span></p>
<p>and the ML estimation method asks we to find a suitable <span
class="math inline">\(\theta\)</span> to maximize <span
class="math inline">\(p(D|\theta)\)</span>, which means:</p>
<p><span class="math display">\[
\theta = argmax_{\theta} p(D|\theta)  
\]</span></p>
<p>if we know <span class="math inline">\(\theta\)</span>, we will know
<span class="math inline">\(p(x|\omega_i,\theta_i)\)</span>(just to
traverse all categories and calculate <span
class="math inline">\(\theta_i\)</span>), and then we can train
classifiers based on Bayesian decision thm.</p>
<p>So how to solve <span class="math inline">\(\theta = argmax_{\theta}
p(D|\theta)\)</span>:</p>
<p>log-likelihood function:</p>
<p><span class="math display">\[
\ell(\theta)=\sum_{k=1}^n lnp(x_k|\theta)  
\]</span></p>
<p>maximizing <span class="math inline">\(p(D|\theta)\)</span> is the
same with maximizing log-likelihood. So, calculate the gradient of <span
class="math inline">\(\theta\)</span>:</p>
<p><span class="math display">\[
\frac{\partial}{\partial \theta}\ell(\theta)
\]</span></p>
<p><strong>we will discuss the Gaussian situation:</strong></p>
<h3 id="ml-gaussian-case-mu-is-unknown">ML Gaussian Case: <span
class="math inline">\(\mu\)</span> is unknown</h3>
<p>As <span class="math inline">\(\Sigma\)</span> is know, so</p>
<p><span class="math display">\[
\theta=\mu
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\ell(\theta)&amp;=\sum_{k=1}^n lnp(x_k|\theta) \\
&amp;=\sum_{k=1}^n
-\frac{1}{2}(x_k-\mu)^T\Sigma^{-1}(x_k-\mu)-ln(2\pi)^{d/2}|\Sigma|^{1/2}
\\
\end{aligned}
\]</span></p>
<p>Gradient:</p>
<p><span class="math display">\[
\begin{aligned}
\ell^{\prime}(\theta)&amp;=\sum_{k=1}^n 2\Sigma^{-1}x_k-2\Sigma^{-1}\mu
\\
\end{aligned}
\]</span></p>
<p>let</p>
<p><span class="math display">\[
\ell(\theta)=0
\]</span></p>
<p>we get:</p>
<p><span class="math display">\[
\hat{\mu} = \frac{1}{n}\sum_{k=1}^n x_k
\]</span></p>
<h3 id="ml-gaussian-case-mu-and-sigma-are-unknown">ML Gaussian Case:
<span class="math inline">\(\mu\)</span> and <span
class="math inline">\(\Sigma\)</span> are unknown</h3>
<ol type="1">
<li><p>for only one feature (1-dim case): we have: <span
class="math display">\[
\hat{\mu} = \frac{1}{n}\sum_{k=1}^n x_k
\]</span> and <span class="math display">\[  
\hat{\Sigma} = \hat{\sigma} = \frac{1}{n}\sum_{k=1}^n(x_k-\hat{\mu})^2
\]</span></p></li>
<li><p>for multi-feature (multi-dim case):</p></li>
</ol>
<p><span class="math display">\[  
\hat{\mu} = \frac{1}{n}\sum_{k=1}^n x_k  
\]</span></p>
<p><span class="math display">\[
\hat{\Sigma} = \frac{1}{n}\sum_{k=1}^n(x_k-\hat{\mu})(x_k-\hat{\mu})^T
\]</span></p>
<div class="note note-primary">
            <p><span class="math inline">\(\hat{\mu}\)</span> is unbiasedestimation, <span class="math inline">\(\hat{\Sigma}\)</span> isnot.</p><p>But <span class="math inline">\(\frac{n}{n-1}\hat{\Sigma}\)</span> isunbiased estimation.</p>
          </div>
<h2 id="bayesian-estimation">Bayesian estimation</h2>
<p><strong>We suppose our parameter <span
class="math inline">\(\theta\)</span> submits to a prior distribution,
and our goal is to estimation <span
class="math inline">\(\theta\)</span>'s distribution with given data set
and prior distribution</strong>.</p>
<p>Some notions:</p>
<p>prior probability <span class="math inline">\(P(\theta)\)</span></p>
<p>posterior <span class="math inline">\(p(\theta|D)\)</span></p>
<p>likelihood <span
class="math inline">\(p(x|D)(i.e.p(x|\omega))\)</span></p>
<p>Two important relations:</p>
<p><span class="math display">\[
p(x|D) = \int p(x,\theta|D)d\theta = \int
p(x|\theta)p(\theta|D)d\theta\qquad(1)
\]</span></p>
<p><span class="math display">\[
  \begin{aligned}
  p(\theta|D)&amp;=\frac{p(D|\theta)P(\theta)}{\int
p(D|\theta)P(\theta)d\theta} \\
  &amp;=\alpha p(D|\theta)P(\theta) \\
  &amp;=\alpha\prod_{k=1}^n p(x_k|\theta)P(\theta)\qquad(2)
  \end{aligned}
\]</span></p>
<p><strong>Ongoing update...</strong></p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
  </entry>
  <entry>
    <title>空间杂谈</title>
    <url>/2022/03/20/Math/%E7%A9%BA%E9%97%B4%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>"内积空间和度量空间有什么区别? Hilbert空间是什么?
它与线性空间的关系是什么?"</p>
<p>"我已经晕了."</p>
<span id="more"></span>
<h1 id="数域">数域</h1>
<p>\(P\)是包含0, 1的数集, 且对 \(P\)中任意两个数的加减乘除运算封闭, 则称
\(P\)是一个数域.</p>
<h1 id="线性空间">线性空间</h1>
<p>在数域的基础上, 我们提出线性空间的概念:</p>
<p>给定数域 \(P\) , 和集合 \(V\). 有如下映射: <span
class="math display">\[
+:V\times V\rightarrow V
\]</span> <span class="math display">\[
\cdot:P\times V\rightarrow V
\]</span> 且 (\(V, P, +, \)) 满足<strong>八条基本性质</strong>,
则\(V\)称为一个线性空间.</p>
<h1 id="赋范空间">赋范空间</h1>
<p><u>赋范空间是定义在线性空间之上的.</u></p>
<p>定义在数域 \(P\) 的线性空间 \(V\) 存在如下映射: <span
class="math display">\[
||\cdot||:  V\rightarrow R
\]</span> 且该映射满足: 正定, 齐次, 三角不等式. 则 \(V\) 是一个赋范空间,
其中映射 \(||||\) 称为范数.</p>
<h1 id="内积空间">内积空间</h1>
<p><u>内积空间是定义在线性空间之上的.</u></p>
<p>定义在数域 \(P\) 的线性空间 \(V\) 存在如下映射: <span
class="math display">\[
\cdot:  V\times V\rightarrow R
\]</span> 则 \(V\) 是一个内积空间.</p>
<div class="note note-info">
            <p>定义了内积后, 我们可以讨论向量 (即线性空间的元素) 间的长度和夹角,并进一步讨论正交性等.</p>
          </div>
<div class="note note-danger">
            <p>注意: 内积本身具有自然定义的范数, 即内积可以诱导出范数, \(||x||=\),因此内积空间含于赋范空间.</p>
          </div>
<h1 id="度量空间">度量空间</h1>
<p>度量空间是某个具有距离函数的集合. 该函数定义的是集合内所有元素的距离,
即集合上的某种度量, 即:</p>
给定<strong>集合</strong>\(V\), 有映射: <span class="math display">\[
d:V\times V\rightarrow \mathbf{R}
\]</span> 满足:
<p>
[
<span class="math display">\[\begin{aligned}
&amp;d(x,y)\geq0\quad (d(x,y)=0\Leftrightarrow x=0,y=0)\\
&amp;d(x,y)=d(y,x)\\
&amp;d(x,y)\leq d(x,z)+d(z,y)
\end{aligned}\]</span>
]
</p>
<div class="note note-info">
            <p>注意: 此处并未要求线性结构.</p>
          </div>
<div class="note note-danger">
            <p><strong>注意: 赋范空间一定可以诱导出度量空间,因此赋范空间含于度量空间</strong></p>
          </div>
<h1 id="完备空间">完备空间</h1>
<p>完备空间又称 Cauchy 空间. <u>完备空间是定义在度量空间之上的.</u></p>
<p>若度量空间 \(M\) 中所有的柯西序列都收敛在 \(M\) 中的一点, 则 \(M\)
是一个完备空间.</p>
<h1 id="hilbert空间">Hilbert空间</h1>
<p>在<strong>内积空间</strong>的基础上增添<strong>完备性条件</strong>,
即得到<strong>Hilbert空间</strong>.</p>
<h1 id="总结">总结</h1>
<p>范数运算+向量空间=(线性)赋范空间</p>
<p>(线性)赋范空间 + 内积运算=内积空间</p>
<p>(线性)赋范空间 + 完备性 = Banach 空间</p>
<p>内积空间 + 完备性 = Hilbert 空间</p>
<p>内积空间 + 完备性 + 有限维 = Euclidean 空间</p>
<h1 id="references">References</h1>
<p>zhihu:</p>
<p>https://www.zhihu.com/question/332144499/answer/731866608</p>
<p>https://www.zhihu.com/question/42312263/answer/699451330</p>
<p>wikipedia:</p>
<p>https://en.wikipedia.org/wiki/Complete_metric_space</p>
<p>https://en.wikipedia.org/wiki/Metric_space</p>
<p>https://en.wikipedia.org/wiki/Cauchy_sequence</p>
<p>https://en.wikipedia.org/wiki/Cauchy_sequence</p>
<p>https://en.wikipedia.org/wiki/Cauchy_sequence</p>
<p>https://en.wikipedia.org/wiki/Normed_vector_space</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>SVM</title>
    <url>/2022/05/03/ML/SVM/</url>
    <content><![CDATA[<p>"很明显, 内容是抄来的."</p>
<p>"你是瞧不起李航还是瞧不起我?"</p>
<span id="more"></span>
<h1 id="引言">引言</h1>
<p>没什么引言, 姑且谈谈什么是 <strong>函数间隔</strong>, 什么是
<strong>几何间隔</strong> 吧.</p>
<p>其实大部分来自于直觉和观察吧. 比如你看下面这幅图, <del>好看不?
我画的.</del> <img src="svm_data1.png" alt="svm_data_1" /></p>
<p>假设蓝色点为正例, 显然直线代表的是分界面, 并且从直观上感受:
对于某个蓝色点而言, <strong>离分界面越远, 它是正例的可能性越高</strong>,
而 <strong>某个蓝色点离分界面越近, 它是正例可能性越小
(即被误判的可能性越高)</strong>. 因此, 能不能使用一种方法,
或者是表达方式来展示这种直觉呢? 答案是 <strong>距离</strong>.</p>
<p>一般而言, 一个点距离分离超平面的远近可以表示分类预测的确信程度.
设分离超平面为 <span class="math inline">\(w^Tx+b=0\)</span>, 则 <span
class="math inline">\(|w^Tx+b|\)</span> 表示了某个样本点 <span
class="math inline">\(x\)</span> 与超平面的距离. 而 <span
class="math inline">\(|w^Tx+b|\)</span> 的符号与类标签 <span
class="math inline">\(y\in{-1,1}\)</span> 是否一致能够表示分类是否正确.
所以, 用 <span class="math display">\[
y(w^Tx+b)
\]</span> 可以表示分类的正确性和确信度. 这便是所谓的函数间隔.</p>
<div class="note note-info">
            <h3 id="函数间隔">函数间隔</h3><p>训练集 <span class="math inline">\(T\)</span>, 超平面 <spanclass="math inline">\((w, b)\)</span>, <span class="math inline">\((w,b)\)</span> 关于某样本点 <span class="math inline">\((x_i, y_i)\)</span>的函数间隔定义为 <span class="math display">\[\hat{\gamma}_i=y_i(w^Tx_i+b)\]</span></p><p>而超平面 <span class="math inline">\((w, b)\)</span> 关于 <spanclass="math inline">\(T\)</span> 的函数间隔定义为 <spanclass="math display">\[\hat{\gamma}=min_{i=1,\cdots,n}\hat{\gamma}_i\]</span></p>
          </div>
<p>考虑到 <span class="math inline">\(\omega\)</span> 和 <span
class="math inline">\(b\)</span> 是齐次的,
同时增大或减小时会影响到函数间隔, 因此引出几何间隔的概念:</p>
<div class="note note-info">
            <h3 id="几何间隔">几何间隔</h3><p>训练集 <span class="math inline">\(T\)</span>, 超平面 <spanclass="math inline">\((w, b)\)</span>, <span class="math inline">\((w,b)\)</span> 关于某样本点 <span class="math inline">\((x_i, y_i)\)</span>的函数间隔定义为 <span class="math display">\[\gamma_i=y_i(\frac{w^T}{||w||}x_i+\frac{b}{||w||})\]</span></p><p>而超平面 <span class="math inline">\((w, b)\)</span> 关于 <spanclass="math inline">\(T\)</span> 的函数间隔定义为 <spanclass="math display">\[\gamma=min_{i=1,\cdots,n}\hat{\gamma}\]</span></p>
          </div>
<h1 id="正题">正题</h1>
<h2 id="硬间隔线性svm">硬间隔线性SVM</h2>
<p>SVM要求最大化几何间隔, 能使超平面以最大的置信度将样本分类 <span
class="math display">\[
\begin{aligned}
max_{w,b}\ \ &amp;\gamma \\
s.t.\ \ &amp;y_i(\frac{w^T}{||w||}x_i+\frac{b}{||w||}) \geq \gamma,\ \
i=1,\cdots,n
\end{aligned}
\]</span></p>
<p>将几何间隔化为函数间隔, <span
class="math inline">\(\gamma=\frac{\hat{\gamma}}{||w||}\)</span>,
并考虑到函数间隔与 <span class="math inline">\((w,b)\)</span> 无关, 取
<span class="math inline">\(\hat{\gamma}=1\)</span>, 得到如下二次规划:
<span class="math display">\[
\begin{aligned}
min_{w,b}\ \ &amp;\frac{1}{2}||w||^2 \\
s.t.\ \ &amp;y_i(w^Tx_i+b) \geq 1,\ \ i=1,\cdots,n
\end{aligned}
\]</span></p>
<p>优化该问题:</p>
<p><span class="math inline">\(Lagrange\)</span> 函数: <span
class="math display">\[
L(w,b,\lambda)=\frac{1}{2}w^Tw+\sum_i\lambda-\sum_i\lambda_i y_i(w^Tx_i
+ b)
\]</span> 对参数求梯度: <span class="math display">\[
\begin{aligned}
\frac{\partial}{\partial w}L&amp;=w-\sum_i\lambda_i y_i x_i = 0
&amp;\qquad(1)\\
\frac{\partial}{\partial b}L&amp;=-\sum_i\lambda_i y_i = 0
&amp;\qquad(2)
\end{aligned}
\]</span> 带入 <span class="math inline">\(Lagrange\)</span>
函数得对偶函数 (即拉格朗日函数关于参数的极小值): <span
class="math display">\[
-\frac{1}{2}\sum_{i,j}\lambda_i\lambda_j y_i y_j x_i^Tx_j +
\sum_i\lambda_i
\]</span> 得原问题的对偶问题: <span class="math display">\[
\begin{aligned}
max_{\lambda}\ \ &amp;-\frac{1}{2}\sum_{i,j}\lambda_i\lambda_j y_i y_j
x_i^Tx_j + \sum_i\lambda_i \\
s.t.\ \ &amp;\sum_i\lambda_i y_i = 0 \\
&amp;\lambda\geq 0
\end{aligned}
\]</span> 或: <span class="math display">\[
\begin{aligned}
min_{\lambda}\ \ &amp;\frac{1}{2}\sum_{i,j}\lambda_i\lambda_j y_i y_j
x_i^Tx_j - \sum_i\lambda_i \\
s.t.\ \ &amp;\sum_i\lambda_i y_i = 0 \\
&amp;\lambda\geq 0
\end{aligned}
\]</span> 由 <span class="math inline">\(KKT\)</span> 条件: <span
class="math display">\[
\begin{aligned}
\nabla_{w;b}L&amp;=0 \\
\lambda_i&amp;\geq 0 \\
y_i(w^Tx_i+b) &amp;\geq 1,\ \ i=1,\cdots,n \\
\lambda_i(y_i(w_*^Tx_i + b_*) - 1) &amp;= 0
\end{aligned}
\]</span> 考虑到 <span class="math inline">\(y_i^2=1\)</span> 得: <span
class="math display">\[
\begin{aligned}
w_*&amp;=\sum_i\lambda_i y_i x_i \\
b_*&amp;=y_i-\sum_i \lambda_i y_i x_i^Tx_j
\end{aligned}
\]</span> 此处的 <span class="math inline">\(\lambda_i\)</span>
表示最优的 <span class="math inline">\(\lambda_*\)</span>.</p>
<p>因此得到分离超平面: <span class="math display">\[
y(x) = (\sum_i\lambda_i y_i x_i)^Tx + y_i-\sum_i \lambda_i y_i x_i^Tx_j
\]</span> 此处的 <span class="math inline">\(\lambda_i\)</span>
表示最优的 <span class="math inline">\(\lambda_*\)</span>.</p>
<p>最后的决策函数可以定义为: <span class="math display">\[
f(x) = sgn (y(x))
\]</span></p>
<p>来个例题: 用二次规划和对偶问题两种方式求解. <img src="timu1.jpg"
alt="timu1" /></p>
<p>答案: <span class="math display">\[
\frac{1}{2}x^{(1)}+\frac{1}{2}x^{(2)}-2=0
\]</span></p>
<h2 id="软间隔线性svm">软间隔线性SVM</h2>
<p>数据集线性不可分, 设置松弛变量 <span
class="math inline">\(\xi\)</span>.
线性不可分表示部分数据不能满足函数间隔大于等于1.
但我们希望添加松弛变量后可以满足. <span class="math display">\[
y_i(w^Tx_i+b)\geq 1-\xi_i
\]</span> 但我们不允许无限制地引入松弛变量, 因此需要设置一定的代价:
<span class="math display">\[
C\sum_i\xi_i,\ \ C &gt; 0
\]</span> 因此原问题等价于下述二次规划: <span class="math display">\[
\begin{aligned}
min_{w,b}\ \ &amp;\frac{1}{2}||w||^2 + C\sum_i\xi_i \\
s.t.\ \ &amp;y_i(w^Tx_i+b) \geq 1 - \xi_i,\ \ i=1,\cdots,n \\
&amp;\xi_i  \geq 0
\end{aligned}
\]</span> 对偶问题: <span class="math display">\[
\begin{aligned}
max_{\lambda}\ \ &amp;-\frac{1}{2}\sum_{i,j}\lambda_i\lambda_j y_i y_j
x_i^Tx_j + \sum_i\lambda_i \\
s.t.\ \ &amp;\sum_i\lambda_i y_i = 0 \\
&amp;C-\lambda_i-\mu_i = 0 \\
&amp;\lambda_i, \mu_i \geq 0
\end{aligned}
\]</span> 其中 <span class="math inline">\(\lambda_i\)</span>
是对间隔引入的乘子, <span class="math inline">\(\mu_i\)</span>
是对松弛变量引入的乘子. 解出最优解: <span class="math display">\[
\begin{aligned}
w_*&amp;=\sum_i\lambda_i y_i x_i \\
b_*&amp;=y_i-\sum_i \lambda_i y_i x_i^Tx_j
\end{aligned}
\]</span> 此处的 <span class="math inline">\(\lambda_i\)</span>
表示最优的 <span class="math inline">\(\lambda_*\)</span>.</p>
<div class="note note-info">
            <h3 id="支持向量">支持向量</h3><p>对于硬间隔, 支持向量是使 <span class="math inline">\(\lambda &gt;0\)</span> 的样本, 由互补松弛性, 它们满足 <spanclass="math inline">\(y_i(w^Tx_i+b) = 1\)</span>,因此这些样本落在间隔边界, 将分离超平面"支持"起来.</p><p>对于软间隔, 支持向量是 使 <span class="math inline">\(0 &lt; \lambda&lt; C\)</span> 的样本, 由互补松弛性, 此时 <spanclass="math inline">\(y_i(w^Tx_i+b) = 1\)</span> 且 <spanclass="math inline">\(\xi_i = 0\)</span>; 同时, 若 <spanclass="math inline">\(\lambda = C\)</span> 即 <spanclass="math inline">\(\mu = 0\)</span>, 即 <spanclass="math inline">\(\xi_i \neq 0\)</span>:</p><p><span class="math inline">\(0 &lt; \xi_i &lt; 1\)</span>:分类正确</p><p><span class="math inline">\(\xi_i = 1\)</span>: 在分离超平面上;</p><p><span class="math inline">\(\xi_i &gt; 1\)</span>: 误分</p>
          </div>
<div class="note note-info">
            <h3 id="合页损失-hinge-loss">合页损失 (hinge loss)</h3><p>线性支持向量机的原始优化问题 <span class="math display">\[\begin{aligned}min_{w,b}\ \ &amp;\frac{1}{2}||w||^2 + C\sum_i\xi_i \\s.t.\ \ &amp;y_i(w^Tx_i+b) \geq 1 - \xi_i,\ \ i=1,\cdots,n \\&amp;\xi_i  \geq 0\end{aligned}\]</span> 等价于问题 <span class="math display">\[min_{w, b}\ \ \sum_i[(1-y_i(w^Tx_i+b))]_++\lambda||w||_2^2\]</span> 其中 <span class="math display">\[[z]_+=\left \{\begin{aligned}z&amp;,\quad z&gt;0 \\0&amp;,\quad z\leq 0\end{aligned}\right .\]</span> 称为合页损失. 后面的问题可以理解为: 当间隔大于1时, 无损失;当间隔小于1时给损失; 同时第二项是参数的正则项.</p><p>对比感知机, 线性SVM要求分类大于一定的置信度后, 才能将损失设置为0,而感知机无置信度, 见下图 <img src="duibi.png" alt="duibi" /></p>
          </div>
<h2 id="kernel-trick">Kernel Trick</h2>
<p>从线性SVM不能解决非线性问题的角度出发, 引入了核技巧,
从而得到非线性SVM.</p>
<p>核技巧的思想是将原特征空间经过 <strong>非线性映射</strong>,
映射至一个特征空间,
使得原特征空间中的超曲面对应与映射后特征空间的的超平面. 记非线性映射为
<span class="math inline">\(\phi\)</span>. 事实上,
该非线性映射将输入空间 (欧式空间或离散空间) 映射至一个特征空间
(Hilbert空间). 即: <span class="math display">\[
\phi(x):X \rightarrow H
\]</span> 但是, 由于 <span class="math inline">\(\phi\)</span> 不好构造,
而直接计算内积 <span class="math inline">\(\phi(x)^T\phi(y)\)</span>
比先计算 <span class="math inline">\(\phi(x)\)</span> 再计算内积容易,
因此引入 <strong>核函数</strong> 的概念: <div class="note note-info">
            <h3 id="核函数">核函数</h3><p>称 <span class="math inline">\(K(x,z)\)</span> 为核函数, 如果满足:<span class="math inline">\(\forall x,z\in X, \exists \phi(x):X\rightarrow H,\ s.t.\ K(x,z)=\phi(x)\cdot\phi(z)\)</span></p>
          </div> 这时, 可以将
<span class="math display">\[
\begin{aligned}
max_{\lambda}\ \ &amp;-\frac{1}{2}\sum_{i,j}\lambda_i\lambda_j y_i y_j
x_i^Tx_j + \sum_i\lambda_i \\
s.t.\ \ &amp;\sum_i\lambda_i y_i = 0 \\
&amp;C-\lambda_i-\mu_i = 0 \\
&amp;\lambda_i, \mu_i \geq 0
\end{aligned}
\]</span> 中的 <span class="math display">\[
\frac{1}{2}\sum_{i,j}\lambda_i\lambda_j y_i y_j x_i^Tx_j -
\sum_i\lambda_i
\]</span> 改为 <span class="math display">\[
W(\lambda)=\frac{1}{2}\sum_{i,j}\lambda_i\lambda_j y_i y_j K(x_i,x_j) -
\sum_i\lambda_i
\]</span></p>
<h3 id="正定核">正定核</h3>
<p>能否不用构造 <span class="math inline">\(\phi\)</span>
就可以判断某个函数是否是核函数?</p>
<p>一般, 核函数指正定核函数.</p>
<div class="note note-info">
            <h3 id="thm">Thm</h3><p><span class="math inline">\(K(x,z):X\times X\rightarrow R\)</span>是对称函数, 则 <span class="math inline">\(K\)</span>为正定核的充要条件为 <span class="math inline">\(K\)</span> 对应的 <spanclass="math inline">\(Gram\)</span> 矩阵半正定.</p>
          </div>
<p>*扩展: <span class="math inline">\(Mercer\)</span> 核</p>
<div class="note note-info">
            <h3 id="常用核函数">常用核函数</h3><p><strong>多项式核</strong>: <span class="math display">\[K(x,z)=(x^Tz+1)^p\]</span> <strong>高斯核</strong>: <span class="math display">\[K(x,z)=exp(-\frac{||x-z||^2}{2\sigma^2})\]</span> <strong>拉普拉斯核</strong>: <span class="math display">\[K(x,z)=exp(-\frac{||x-z||}{\sigma})\]</span> <strong>sigmoid核</strong>: <span class="math display">\[K(x,z)=tanh(x^Tz+1)\]</span></p>
          </div>
<h2 id="smo算法">SMO算法</h2>
<p>SMO: 序列最小最优算法</p>
<p>思想是将原问题不断分解为二次规划的子问题, 每次从优化变量中取两个,
其中一个严重违背 KKT 条件, 另一个满足; 直到所有的变量都满足 KKT
条件.</p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
  </entry>
  <entry>
    <title>Image Semantic Segmentation based on UNet</title>
    <url>/2022/08/21/ML/UNet/</url>
    <content><![CDATA[<p>"Semantic segmentation of images, use UNet model."</p>
<span id="more"></span>
<h1 id="abstract">Abstract</h1>
<p>In this project, we realize an basic UNet model and UNet++ model,
then we apply them on image semantic segmentation. We show our basic
theory of UNet and an improvement of it, and we provide main code of
this program. Finally, we give the result of segmentation images,
loss-curve and accuracy-curve on both training and validation set.</p>
<p>The copyright of this program is owned by our team mentioned on the
end of this blog.</p>
<h1 id="unet-structure">UNet Structure</h1>
<p>The <a href="https://arxiv.org/abs/1505.04597">paper</a> published in
2015 propose a noval network structure, whose shape is similar with the
captal "U". The idea comes from FCNN. U-Net is one of the classes of
"Encoder-Decoder" structure.</p>
<figure>
<img src="unet-structure.png" alt="U-Net Structure" />
<figcaption aria-hidden="true">U-Net Structure</figcaption>
</figure>
<p>The front half of the network is "encoder". The input image passes
covolutional kernel, and then passes the pooling layer (or other
dimension-decreasing layer). The opposite of that is the back part of
UNet, the "decoder". The input of decoder is a sequence of feature maps
with highly contracted pixels. The output of the decoder (or the whole
network) is an image with the same shape of input image, where each
pixel has its own class.</p>
<p>In this project, we decrease the number of convolutional layers so
that there are only two convolutional layers in each convolutional
kernel as the dataset includes images with shape <span
class="math inline">\(128\times 256\)</span>.</p>
<h2 id="operator-definitions">Operator Definitions</h2>
<p><strong>Convolutional Kernel:</strong></p>
<p>We define the basic convolutional kernel as follow:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">self.layer = nn.Sequential(<br>    <span class="hljs-comment"># in_channel, out_channel, kernel_size, stride, padding</span><br>    <span class="hljs-comment"># batch size * channel * height * weight</span><br>    nn.Conv2d(C_in, C_out, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), stride=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), padding=<span class="hljs-number">1</span>),  <span class="hljs-comment"># 64 64 128 256</span><br>    nn.BatchNorm2d(C_out),<br>    nn.Dropout(<span class="hljs-number">0.2</span>),<br>    nn.LeakyReLU(),<br><br>    nn.Conv2d(C_out, C_out, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), stride=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), padding=<span class="hljs-number">1</span>),  <span class="hljs-comment"># 64 64 128 256</span><br>    nn.BatchNorm2d(C_out),<br>    nn.Dropout(<span class="hljs-number">0.5</span>),<br>    nn.LeakyReLU(),<br></code></pre></td></tr></table></figure>
<p>It includes two convolution operations.</p>
<p><strong>Down Sampling Kernel:</strong></p>
<p>As for downsampling kernel, we replace conditional pooling layer to
convolutional layer with stride equaling to 2, which means the shape
will be shrunk to <span class="math inline">\(\frac{1}{2}\)</span> while
remaining the same channels.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">self.Down = nn.Sequential(<br>    nn.Conv2d(C, C, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), stride=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), padding=<span class="hljs-number">1</span>),  <span class="hljs-comment"># 64 64 64 128</span><br>    nn.LeakyReLU()<br>        )<br></code></pre></td></tr></table></figure>
<p><strong>Up Sampling Kernel:</strong></p>
<p>The basic structure of up-sampling contains only one convolutional
layer with <span class="math inline">\(1\times 1\)</span> convolutional
kernel size and half out-channel. The feature map should pass an
interpolation layer before getting into the convolutional layer.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, C</span>):<br>    <span class="hljs-built_in">super</span>(UpSampling, self).__init__()<br>    <span class="hljs-comment"># out-channel = 1/2 in-channel</span><br>    self.Up = nn.Conv2d(C, C // <span class="hljs-number">2</span>, kernel_size=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), stride=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, r</span>):<br>    <span class="hljs-comment"># neighbor interpolation</span><br>    up = F.interpolate(x, scale_factor=<span class="hljs-number">2</span>, mode=<span class="hljs-string">&quot;nearest&quot;</span>)<br>    x = self.Up(up)<br>    <span class="hljs-comment"># concatenate the feature map in encoder and </span><br>    <span class="hljs-comment"># the feature map in corrsponding decoder layer, in channel dimension</span><br>    res = torch.cat((x, r), <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<p>The interpolation mode we choose is "nearest". The function
<code>torch.cat(dim=1)</code> is used to concatenate two feature maps in
channel dimension.</p>
<h2 id="network-definition">Network Definition</h2>
<p>Based on the operators defined above, we link these blocks together
like UNet structure.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">super</span>(UNet, self).__init__()<br><br>    <span class="hljs-comment"># down sampling</span><br>    self.C1 = Conv(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>)<br>    self.D1 = DownSampling(<span class="hljs-number">64</span>)<br>    self.C2 = Conv(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>)<br>    self.D2 = DownSampling(<span class="hljs-number">128</span>)<br>    self.C3 = Conv(<span class="hljs-number">128</span>, <span class="hljs-number">256</span>)<br>    self.D3 = DownSampling(<span class="hljs-number">256</span>)<br>    self.C4 = Conv(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>)<br>    self.D4 = DownSampling(<span class="hljs-number">512</span>)<br>    self.C5 = Conv(<span class="hljs-number">512</span>, <span class="hljs-number">1024</span>)<br><br>    <span class="hljs-comment"># up sampling</span><br>    self.U1 = UpSampling(<span class="hljs-number">1024</span>)<br>    self.C6 = Conv(<span class="hljs-number">1024</span>, <span class="hljs-number">512</span>)<br>    self.U2 = UpSampling(<span class="hljs-number">512</span>)<br>    self.C7 = Conv(<span class="hljs-number">512</span>, <span class="hljs-number">256</span>)<br>    self.U3 = UpSampling(<span class="hljs-number">256</span>)<br>    self.C8 = Conv(<span class="hljs-number">256</span>, <span class="hljs-number">128</span>)<br>    self.U4 = UpSampling(<span class="hljs-number">128</span>)<br>    self.C9 = Conv(<span class="hljs-number">128</span>, <span class="hljs-number">64</span>)<br><br>    self.C10 = torch.nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, kernel_size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), stride=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), padding=<span class="hljs-number">1</span>)<br>    self.pred = torch.nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">34</span>, kernel_size=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), stride=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    self.Th = torch.nn.Sigmoid()<br></code></pre></td></tr></table></figure>
<p>Like U-Net mentioned in that paper, we designed 4 layer deep
network.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># part 1: down sampling, decreasing dimension</span><br>        R1 = self.C1(x)<br>        R2 = self.C2(self.D1(R1))<br>        R3 = self.C3(self.D2(R2))<br>        R4 = self.C4(self.D3(R3))<br>        Y1 = self.C5(self.D4(R4))<br><br>        <span class="hljs-comment"># part 2: up sampling, connect priori knowledge</span><br>        O1 = self.C6(self.U1(Y1, R4))<br>        O2 = self.C7(self.U2(O1, R3))<br>        O3 = self.C8(self.U3(O2, R2))<br>        O4 = self.C9(self.U4(O3, R1))<br><br>        <span class="hljs-comment"># part 3: active function</span><br>        <span class="hljs-keyword">return</span> self.Th(self.pred(self.C10(O4)))<br></code></pre></td></tr></table></figure>
<p>As you can see, the difference between U-Net and other networks
before U-Net is that U-Net conbines the former information from encoder
and current information from decoder.</p>
<h1 id="code">Code</h1>
<p>During the training process, we want to keep some information of loss
values and accuracy values on training set and validation set so that we
can analyze the variance.</p>
<p>In the function named <code>train()</code>, we take
<code>optimizer</code> and <code>loss</code> as two parameters used in
training process. The outputs of this function are loss and accuracy on
both training set and validation set. If we get the data about training
set and validation set, we can draw the curves. If both training and
validation loss values decrease during training process, we can conclude
that our model converges and does not overfit on training set.</p>
<p>The training code is shown as follow:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">self.model.train()<br><span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> self.train_loader:<br>    batch_num += <span class="hljs-number">1</span><br>    optimizer.zero_grad()<br>    rgbs, segs = batch<br>    s, _, m, n = segs.shape<br>    segs = torch.reshape(segs, (s, m, n))<br>    pred_segs = self.model(rgbs).to(self.device)<br>    loss_val = loss(pred_segs, segs)<br>    loss_val.backward()<br>    optimizer.step()<br></code></pre></td></tr></table></figure>
<p>The data collecting code can be written as follow:</p>
<p><strong>Statistic data of training set</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> ... :<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">if</span> batch_num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>            logging.info(<span class="hljs-string">f&quot;batch num <span class="hljs-subst">&#123;batch_num&#125;</span>, loss <span class="hljs-subst">&#123;loss_val&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># delete or add comments when needed</span><br>        train_loss += loss_val<br>        <span class="hljs-comment"># statistic valid classified samples</span><br>        total_pix += s * m * n<br>        idx = torch.argmax(pred_segs, dim=<span class="hljs-number">1</span>)<br>        train_valid_pix += torch.eq(idx, segs).<span class="hljs-built_in">sum</span>().<span class="hljs-built_in">float</span>().item()<br>torch.cuda.empty_cache()<br>epoch_acc = train_valid_pix / total_pix<br>train_epoch_loss.append(train_loss / batch_num)<br>train_epoch_acc.append(epoch_acc)<br></code></pre></td></tr></table></figure>
<p><strong>Statistic data of validation set</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">self.model.<span class="hljs-built_in">eval</span>()<br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> valid_batch <span class="hljs-keyword">in</span> self.valid_loader:<br>        valid_batch_num += <span class="hljs-number">1</span><br>        rgbs, segs = valid_batch<br>        s, _, m, n = segs.shape<br>        segs = torch.reshape(segs, (s, m, n))<br>        pred_segs = self.model(rgbs).to(self.device)<br>        loss_val = loss(pred_segs, segs)<br>        valid_loss += loss_val<br>        valid_total_pix += s * m * n<br>        idx = torch.argmax(pred_segs, dim=<span class="hljs-number">1</span>)<br>        valid_valid_pix += torch.eq(idx, segs).<span class="hljs-built_in">sum</span>().<span class="hljs-built_in">float</span>().item()<br>epoch_acc = valid_valid_pix / valid_total_pix<br>valid_epoch_loss.append(valid_loss / valid_batch_num)<br>valid_epoch_acc.append(epoch_acc)<br></code></pre></td></tr></table></figure>
<p>The point you should pay attention to is that you should use
<code>with torch.no_grad()</code> before you do some work that have no
relation with training process, otherwise your GPU memory will be full
or even overflow.</p>
<h1 id="result">Result</h1>
<p>After a long time training, we get the satisfying result with U-Net
model.</p>
<h2 id="former-model">Former Model</h2>
<p>The "former model" infers the U-Net model, and you will see we use
other upgraded model named "UNet++" which will be introduced later.</p>
<p>We output the segmentation results and their uncertainties.</p>
<figure>
<img src="pic1-unet.png" alt="picture 1 result-UNet" />
<figcaption aria-hidden="true">picture 1 result-UNet</figcaption>
</figure>
<h2 id="model-upgrade">Model Upgrade</h2>
<p>For some reasons, we try another U-Net-like model, Nested UNet,
namely UNet++. It has a nested convolutional blocks like a pyramid and
there is a chain passing connectivity between each convolutional block
every layer.</p>
<figure>
<img src="nested.png" alt="Neseted UNet" />
<figcaption aria-hidden="true">Neseted UNet</figcaption>
</figure>
<p>The black nodes are the same with U-Net model. The green nodes are
what Nested UNet newly added. Both green and blue lines are skip
pathways that pass connectivities from encoder to decoder.</p>
<p>The use of Nested UNet gives us a little improvement on final
results.</p>
<figure>
<img src="pic1-nested.png" alt="pictrue 1 result-Nested UNet" />
<figcaption aria-hidden="true">pictrue 1 result-Nested UNet</figcaption>
</figure>
<h1 id="analysis">Analysis</h1>
<h2 id="u-net">U-Net</h2>
<p>We analyze the loss value and accuracy on both training and
validation set:</p>
<figure>
<img src="unet_loss.png" alt="unet loss" />
<figcaption aria-hidden="true">unet loss</figcaption>
</figure>
<p>We find that after 100 epochs, the model has not convergenced yet,
but the loss on validation decreases to the bottom.</p>
<figure>
<img src="unet_acc.png" alt="unet accuracy" />
<figcaption aria-hidden="true">unet accuracy</figcaption>
</figure>
<p>From the accuracy curves, we find that both training set and
validation set have increasing accuracy, which means our model does not
overfit.</p>
<h2 id="nested-unet">Nested UNet</h2>
<p>Meanwhile, we analyze the loss and accuracy of Nested UNet model on
both training and validation set.</p>
<figure>
<img src="nested_loss.png" alt="nested loss" />
<figcaption aria-hidden="true">nested loss</figcaption>
</figure>
<p>We find that Nested UNet has a faster convergency speed than UNet. It
uses only about 60 epochs. But to our surprise, we find that Neseted
UNet overfit after about only 20 epochs because the validation loss does
not decrease anymore.</p>
<figure>
<img src="nested_acc.png" alt="nested accuracy" />
<figcaption aria-hidden="true">nested accuracy</figcaption>
</figure>
<p>The performance on validation accuracy stays the same with UNet
model.</p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
  </entry>
</search>
