[{"title":"【算法】Algorithm-FFT","url":"/2022/04/06/Algorithm/algorithm-FFT/","content":"\"FFT是我见过最美的算法.\"\r\n\"说的好像你见过很多算法似的.\"\r\n\r\n多项式乘积问题\r\n首先来思考这样的一个问题:\r\n\r\nQuestion 1\r\n你有两个多项式函数:\r\n\\[p(x)=2x^3+x+1\\]\r\n\\[q(x)=x^2+4x+5\\]\r\n应该如何计算它们的乘积?\r\n\r\n当然, 我不是说要用笔算的方式, 而是用计算机.\r\n显然这个问题我们在小学二年级就写过的,\r\n当初正在学习\"数据结构\"这门课, 如果没记错, 应该是用链表实现的.\r\n但是, 就算是用链表实现, 那不也是和手算一样的原理吗?\r\n\r\n将二者相乘\r\n分配律\r\n合并同类项\r\n\r\n例如上面那个例子:\r\n\r\nsolution 1\r\n\\[\r\n\\begin{align*}\r\n    r(x) &amp;= (2x^3+x+1)(x^2+4x+5) \\\\\r\n    &amp;= 2x^5+8x^4+10x^3+x^3+4x^2+5x+x^2+4x+5 \\\\\r\n    &amp;= 2x^5+8x^4+11x^3+5x^2+5x+5\r\n\\end{align*}\r\n\\]\r\n\r\n(???是什么动力让我深夜在这里口算多项式乘法???)\r\n显然, 如果一个 n 次多项式乘上一个 m 次多项式, 在合并同类项前应该有\r\n\\(n\\times m\\) 次多项式, 这谁顶得住?\r\n对于正常人类而言显然顶不住, 对于计算机而言, 时间复杂度是\\(O(n^2)\\), 也是算比较大的开销了吧.\r\n咋办?\r\n点表示法\r\n开始\r\n有谁规定, 我多项式一定是用系数表示的?\r\n好家伙, 你这样说我就摸不着头脑了,\r\n难道除了系数表示还有其他表示方法吗?\r\n首先, 多项式集合其实是构成了一个线性空间, 也就是说,\r\n任意两个多项式进行线性运算 (加法和数乘) 后, 结果仍然是多项式. 事实上\r\n\\[\r\n{1, x, x^2, \\dots, x^n, \\dots}\r\n\\]\r\n构成了该空间的一组基, 将函数展开成 Taylor 级数便用了这组基作为基底,\r\n基前面的系数也就是坐标.\r\n其次, 对于一个 n 次多项式而言, 只要我们确定了它的坐标,\r\n就能唯一确定这个多项式. 现在的问题是不知道坐标,\r\n如何确定多项式. 这里的巧妙之处就在于, 多项式函数是一个映射,\r\n对于一个特定的 x, 总是能给出唯一一个值与之对应, 这不就是一个方程吗?\r\n我给你一个 x, 你输出一个值, 同时由于多项式系数全部未知,\r\n这就是一个关于 \\(n+1\\) 个系数的方程\r\n显然, 我需要 \\(n+1\\)\r\n个不同的点来唯一确定我的系数. 这就是所谓的点表示法. 这样一来, 我们将这\r\n\\(n+1\\) 个方程写成矩阵形式:\r\n\\[\r\n\\begin{bmatrix}\r\np_0 \\\\\r\np_1 \\\\\r\n\\vdots \\\\\r\np_n\r\n\\end{bmatrix}\r\n=\r\n\\begin{bmatrix}\r\n1\\quad &amp; x_0\\quad &amp; \\dots\\quad &amp; x_0^n \\\\\r\n1\\quad &amp; x_1\\quad &amp; \\dots\\quad &amp; x_1^n \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad &amp; \\quad &amp; \\vdots \\\\\r\n1\\quad &amp; x_n\\quad &amp; \\dots\\quad &amp; x_n^n\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nc_0 \\\\\r\nc_1 \\\\\r\n\\vdots \\\\\r\nc_n\r\n\\end{bmatrix}\r\n\\]\r\n看到这里我终于理解了为什么在学高等代数时要突然讲一个范德蒙德(Vandermonde)行列式,\r\n也就是这里的\r\n\\[\r\n\\left[\r\n\\begin{aligned}\r\n1\\quad &amp; x_0\\quad &amp; \\dots\\quad &amp; x_0^n \\\\\r\n1\\quad &amp; x_1\\quad &amp; \\dots\\quad &amp; x_1^n \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad &amp; \\quad &amp; \\vdots \\\\\r\n1\\quad &amp; x_n\\quad &amp; \\dots\\quad &amp; x_n^n\r\n\\end{aligned}\r\n\\right]\r\n\\]\r\n将上述矩阵定义为我们最喜欢的字母\\(A\\).\r\n好, 既然这东西是范德蒙德行列式, 那我们可以知道它行列式\\(|A|=\\prod_{0\\leq j&lt; i\\leq\r\nn}(x_i-x_j)\\)不为 0, 也就是说, 这个矩阵是可逆的, 也就是当我们取\r\n\\(n+1\\) 个不同点时,\r\n确实是可以使方程组有唯一解, 也就是 \\(n+1\\) 个点可以唯一表示一个 n\r\n次多项式.\r\n乘法\r\n问题来了, 如何做乘法?\r\n我们有 n 次多项式和 m 次多项式做乘法, 得到的是一个 \\(n+m\\) 次多项式, 那么我们只要找到 \\(n+m+1\\) 个点即可, 也就是只要在 n 次多项式和\r\nm 次多项式中分别找 \\(n + m + 1\\) 个点,\r\n这些点的横坐标 x 相等, 再将对应的函数值相乘即可.\r\n进一步\r\n现在, 我们知道了如何用点表示多项式, 以及如何用点表示进行乘法运算.\r\n但是仔细一想, 这种方法需要求解线性方程组, 这里的计算复杂度并不低.\r\n也就是从系数表示法到点表示法的转化过程带来的计算复杂度还是很高的.\r\n有什么方法可以进行简化吗?\r\n先等一等, 我们先来梳理我们用点表示求多项式乘法的思路:\r\n\r\nMainIdea\r\n\r\n将 n 次多项式和 m 次多项式分别从系数表示转化为点表示\r\n对应点相乘\r\n将得到的 \\(n+m+1\\)\r\n个点表示的多项式转化为系数表示\r\n\r\n\r\n奇偶\r\n先来考虑简单的情况:\r\n\r\nQuestion 2\r\n多项式\r\n$ p(x) = x^2 $\r\n和多项式\r\n$ q(x)=x^3 $\r\n用点表示法相乘\r\n\r\n那我们当然是按部就班地进行乘法啦~ - 由于结果是 5 次多项式,\r\n因此对\\(p(x)\\)取 5 个点, 对\\(q(x)\\)取 5 个点.\r\n取点, 说得轻巧, 做起来倒是挺犹豫的.\r\n取什么样的点能满足要求呢? 或者得寸进尺地说,\r\n什么样的点能让效率更高呢? 注意到二次函数是对称的,\r\n那我们是不是只要取正的 2 个点, 就能知道负的 2 个点, 另外加一个原点?\r\n确实如此.\r\n那三次多项式呢? 照理来说,\r\n我们同样也是只要取一半的点就能知道另一半点的值(这里的\"一半\"针对正负而言),\r\n只不过要在函数值上添加负号, 何必呢? 还不如干脆 提出一个\r\nx, 然后不也变成了二次函数?\r\n事实上, 一般而言, 我们要用点表示法表示多项式, 可以用如下方法:\r\n\r\nMethod1\r\n\\[\r\np(x)=\\sum_{i=1}^n c_ix^i=P_e(x)+P_o(x)=P_{e1}(x)+xP_{e2}(x)\r\n\\] 其中, \\(P_{ei}(x)\\)表示只含偶次的多项式函数, \\(P_o(x)\\)表示只含奇次的多项式.\r\n\r\n这样, 我们只要在非负轴上取值就可以确定整个多项式, 取点的个数是\r\n原来的一半.\r\n甚至, 这里形成了一个 递归 算法: 分解后的\\(P_{ei}(x)\\)不也是一个关于 x 的多项式吗?!\r\n那我继续啊, 把\\(P_{ei}(x)\\)继续分解啊,\r\n大事化小, 小事化了.\r\n等等!\r\n我们的\\(P_{ei}(x)\\)其实是\\(P_{ei}(x^2)\\), 这里每个\\(x^2\\)都是非负的啊.\r\n未来我们只能在非负轴取值了, 也就是说, 分解为偶次多项式后,\r\n递归停止了.\r\n完蛋.\r\n复数域分解\r\n\"山重水复疑无路, 柳暗花明又一村\"\r\n看到标题就已经知道要怎么做了. 既然在实数域上无法继续分解\\(P_{ei}(x^2)\\),\r\n那为何不去复数域呢?\r\n在复数域上我们可以快乐地进行递归.\r\n如何个快乐法呢? 我们来细品:\r\n\r\n偶次多项式在复平面上的根\r\n为什么突然变成了 求根?\r\n从第二节中\"奇偶\", 我们可以选取对称的点,\r\n来减少选取点的个数(即原来的一半). 接着我们把任意 n\r\n次多项式分解成两个偶次多项式, 偶次多项式的好处在于容易选取对称的点.\r\n但是由于在实数范围内, 在对偶次多项式进行递归时会发生中断,\r\n于是我们扩展至复数域讨论分解.\r\n方便起见: 对于\\(x^0\\), 我们取\\(x=1\\)作为特征点, 对于\\(x^2\\), 我们取\\(x=1, x=-1, x=0\\)作为三个特征点, 那对于\\(x^4\\), 我们应该怎样取点, 抛开\\(x=0\\)不谈, 令\\(x^4=1\\), 由 代数基本定理,\r\n该方程在复数域上有 4 个 根,\r\n对于其它偶次多项式我们以此类推.\r\n就这样, 我们找到了一个简单的方法寻找所有需要的点, 进行递归.\r\n单位根\r\n写到这里, 我也感觉有点吃力, 关键是为什么一定就取了令\\(x^{2k}=1\\)呢?\r\n虽然但是, 确实是所谓的\"方便起见\", 这是因为, 取了\"1\",\r\n我们可以在复平面上的单位圆上讨论这个问题.\r\n在小学二年级我们就知道,\r\n\\(x^{n}=1\\)的根可以用我们熟悉的\\(\\omega\\)的幂来表示, 即 \\[\r\n\\omega = e^{\\frac{2k\\pi}{n}i}\\qquad(k=0,1,\\dots,n-1)\r\n\\] 这些\\(n\\)个点在复平面单位圆上\r\n对称分布. 每递归一次, 单位根的数量减少一半,\r\n但保持对称性不变.\r\n确实方便.\r\n\r\n快速傅里叶变换(FFT)\r\n终于能正式地介绍世界上最美丽的算法了:\r\n快速傅里叶变换(FFT).\r\nFFT解决的是多项式从系数表示到点表示的过程中, 计算复杂度的问题.\r\n框架\r\n分解:\r\n\\[\r\np(x)=\\sum_{k=0}^nc_kx^k=P_{e1}(x^2)+xP_{e2}(x^2):=[ \\omega^0, \\omega^1,\r\n\\dots, \\omega^n]\r\n\\]\r\n递归:\r\n\\[\r\nP\\_{e1}(x^2) = P^{\\prime}\\_{e1}(x^4)+xP^{\\prime}\\_{e2}(x^4):=[\\omega^0,\r\n\\omega^1, \\dots, \\omega^{n-1}]\r\n\\]\r\n\\[\r\nP\\_{e2}(x^2) = P^{\\prime}\\_{e1}(x^4)+xP^{\\prime}\\_{e2}(x^4):=[\\omega^0,\r\n\\omega^1, \\dots, \\omega^{n-1}]\r\n\\]\r\n加和: \\[\r\nP(\\omega^j)=P\\_{e1}(\\omega^{j})+\\omega^jP\\_{e2}(\\omega^j)\r\n\\]\r\n\\[\r\nP(\\omega^{j+n/2})=P\\_{e1}(\\omega^{j+n/2})+\\omega^{j+n/2}P\\_{e2}(\\omega^{j+n/2})\r\n\\]\r\n\\(j\\in[0,1,\\dots, n/2+1]\\)\r\n返回\\(p(x)\\)\r\n时间复杂度为: \\(O(nlog_2n)\\)\r\n一些数学\r\n\r\n\\[\r\n\\left[\r\n\\begin{aligned}\r\np_0 \\\\\r\np_1 \\\\\r\n\\vdots \\\\\r\np_n\r\n\\end{aligned}\\right]\r\n=\r\n\\left[\r\n\\begin{aligned}\r\n1\\quad &amp; x_0\\quad &amp; \\dots\\quad &amp; x_0^n \\\\\r\n1\\quad &amp; x_1\\quad &amp; \\dots\\quad &amp; x_1^n \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad &amp; \\quad &amp; \\vdots \\\\\r\n1\\quad &amp; x_n\\quad &amp; \\dots\\quad &amp; x_n^n\r\n\\end{aligned}\r\n\\right]\r\n\\left[\r\n\\begin{aligned}\r\nc_0 \\\\\r\nc_1 \\\\\r\n\\vdots \\\\\r\nc_n\r\n\\end{aligned}\\right]\r\n\\]\r\n我们在复数域上考虑, 令 \\[\r\nx_k=\\omega^k,\\quad where\\ \\ \\omega=e^{\\frac{2k\\pi}{n}}\r\n\\] (这是因为, 我们希望多项式在复数域上考虑时,\r\n我们可以在单位圆周上讨论. 其中\\(x_k\\)表示我们取的第 k 个点, 刚好与 \\(\\omega^k\\)是对应的.)\r\n则线性方程组可以化为:\r\n\\[\r\n\\left[\r\n\\begin{aligned}\r\np_0 \\\\\r\np_1 \\\\\r\n\\vdots \\\\\r\np_n\r\n\\end{aligned}\\right]\r\n=\r\n\\left[\r\n\\begin{aligned}[c]\r\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp;\r\n\\dots\\quad &amp; 1 \\\\\r\n1\\quad      &amp; \\omega\\quad   &amp; \\omega^2\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^n \\\\\r\n1\\quad      &amp; \\omega^2\\quad &amp; \\omega^4\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^{2n} \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad   &amp;\r\n\\vdots\\quad       &amp;            &amp; \\vdots \\\\\r\n1\\quad      &amp; \\omega^n\\quad &amp; \\omega^{2n}\\quad  &amp; \\dots\\quad\r\n&amp; \\omega^{n\\times n}\r\n\\end{aligned}\r\n\\right]\r\n\\left[\r\n\\begin{aligned}\r\nc_0 \\\\\r\nc_1 \\\\\r\n\\vdots \\\\\r\nc_n\r\n\\end{aligned}\\right]\r\n\\]\r\n其中\r\n\\[\r\n\\left[\r\n\\begin{aligned}[c]\r\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp;\r\n\\dots\\quad &amp; 1 \\\\\r\n1\\quad      &amp; \\omega\\quad   &amp; \\omega^2\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^n \\\\\r\n1\\quad      &amp; \\omega^2\\quad &amp; \\omega^4\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^{2n} \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad   &amp;\r\n\\vdots\\quad       &amp;            &amp; \\vdots \\\\\r\n1\\quad      &amp; \\omega^n\\quad &amp; \\omega^{2n}\\quad  &amp; \\dots\\quad\r\n&amp; \\omega^{n\\times n}\r\n\\end{aligned}\r\n\\right]\r\n\\] 称为离散傅里叶变换矩阵(DFT)显然该矩阵是\r\n对称的 且 可逆, 其逆矩阵为: \\[\r\n\\frac{1}{n}\r\n\\left[\r\n\\begin{aligned}[c]\r\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp;\r\n\\dots\\quad &amp; 1 \\\\\r\n1\\quad      &amp; \\omega^{-1}\\quad   &amp;\r\n\\omega^{-2}\\quad          &amp; \\dots\\quad &amp; \\omega^{-n} \\\\\r\n1\\quad      &amp; \\omega^{-2}\\quad &amp; \\omega^{-4}\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^{-2n} \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad   &amp;\r\n\\vdots\\quad       &amp;            &amp; \\vdots \\\\\r\n1\\quad      &amp; \\omega^{-n}\\quad &amp; \\omega^{-2n}\\quad  &amp;\r\n\\dots\\quad &amp; \\omega^{-n\\times n}\r\n\\end{aligned}\r\n\\right]   \r\n\\]\r\n并且, 该逆矩阵看起来和原矩阵 一模一样! .\r\n\r\n结束了?\r\n当我们乐呵呵地把FFT转化为代码时, 开心的分解多项式, 然后选点, 相乘,\r\n等等! 你还没告诉我, 怎么从点表示转化回系数表示呢!\r\n这就是FFT对称的魅力了. 由点求系数,\r\n不过是矩阵求逆的过程:\r\n\\[\r\n\\left[\r\n\\begin{aligned}\r\nc_0 \\\\\r\nc_1 \\\\\r\n\\vdots \\\\\r\nc_n\r\n\\end{aligned}\\right]\r\n=\r\n\\left[\r\n\\begin{aligned}[c]\r\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp;\r\n\\dots\\quad &amp; 1 \\\\\r\n1\\quad      &amp; \\omega\\quad   &amp; \\omega^2\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^n \\\\\r\n1\\quad      &amp; \\omega^2\\quad &amp; \\omega^4\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^{2n} \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad   &amp;\r\n\\vdots\\quad       &amp;            &amp; \\vdots \\\\\r\n1\\quad      &amp; \\omega^n\\quad &amp; \\omega^{2n}\\quad  &amp; \\dots\\quad\r\n&amp; \\omega^{n\\times n}\r\n\\end{aligned}\r\n\\right]^{-1}\r\n\\left[\r\n\\begin{aligned}\r\np_0 \\\\\r\np_1 \\\\\r\n\\vdots \\\\\r\np_n\r\n\\end{aligned}\\right] \\\\\r\n=\\frac{1}{n}\r\n\\left[\r\n\\begin{aligned}[c]\r\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp;\r\n\\dots\\quad &amp; 1 \\\\\r\n1\\quad      &amp; \\omega^{-1}\\quad   &amp;\r\n\\omega^{-2}\\quad          &amp; \\dots\\quad &amp; \\omega^{-n} \\\\\r\n1\\quad      &amp; \\omega^{-2}\\quad &amp; \\omega^{-4}\\quad          &amp;\r\n\\dots\\quad &amp; \\omega^{-2n} \\\\\r\n\\vdots\\quad &amp; \\vdots\\quad   &amp;\r\n\\vdots\\quad       &amp;            &amp; \\vdots \\\\\r\n1\\quad      &amp; \\omega^{-n}\\quad &amp; \\omega^{-2n}\\quad  &amp;\r\n\\dots\\quad &amp; \\omega^{-n\\times n}\r\n\\end{aligned}\r\n\\right]\r\n\\left[\r\n\\begin{aligned}\r\np_0 \\\\\r\np_1 \\\\\r\n\\vdots \\\\\r\np_n\r\n\\end{aligned}\\right]\r\n\\]\r\n显然, 由于DFT和DFT逆矩阵具有相似的形式,\r\n我们完全可以用同一个函数完成快速傅里叶的正反变换!\r\n后记-\"对称, 万变不离其宗\"\r\n不会真有人会把这个没有图的文章看完吧?\r\n相信我, 日后在这里补充图片的概率为 \\[\r\np=lim_{x\\rightarrow\\infty}xsin (1/x)\r\n\\] (糟糕, 好像出简单了)\r\n另外, 在递归的地方, 觉得并没有讲清楚具体的步骤, 但是思想到位了.\r\n日后也不想改了. 可能以后补一补应用场景之类的, 至于代码, 看情况吧.\r\n","categories":["Algorithm"],"tags":["CS","Algorithm"]},{"title":"【算法】MIT6006:Introduction to Algorithm","url":"/2023/02/27/Algorithm/mit6006-1/","content":"\"算法导论\"\r\n课程地址\r\n\r\n\r\n生日问题:\r\n\r\n在输入\\(n\\)个学生中,\r\n是否有生日相同的两位学生\r\n\r\n\r\n\r\n目标:\r\n\r\n解决计算问题\r\n证明结果的正确性\r\n计算效率\r\n与他人交流\r\n\r\n\r\n\r\n问题:\r\n\r\n是 输入 到 输出 的\r\n二元关系, 可以是多元或单元映射\r\n能够被证明正确与否\r\n\r\n\r\n\r\n算法:\r\n\r\n寻找问题中的映射和输出\r\n正确的算法需要满足输出是正确的 \\(f:I\r\n\\rightarrow O\\)\r\n\r\n\r\n\r\n归纳:\r\n\r\n归纳假设: 例如在生日问题中假设: 如果在前 \\(k\\) 个学生中满足有生日相同的学生pair,\r\n则算法在访问第\\(k+1\\)个学生前返回,\r\n\\(k\\)可以递增到总数\\(n\\); 变量\\(k\\)可以一直递增, 一直到\\(n\\), 需要从 归纳基础\r\n开始进行递增\r\n归纳基础: 对\\(k=0\\)成立\r\n归纳假设正确: 当\\(k\\)成立时, 返回;\r\n否则考察\\(k+1\\)个学生是否有匹配的,\r\n算法遍历所有可能性\r\n\r\n\r\n\r\n算法的效率:\r\n\r\n并不是单纯计算运算时间\r\n而是计算运算所需要的基本操作数量\r\n因为在不同的硬件上, 相同算法相同输入下可能有不同的运算时间\r\n如何度量: 期望效率 (performance) 与输入的大小有关; 用\\(O(\\cdot)\\)表示性能的上限, 用\\(\\Omega(\\cdot)\\)表示性能的下限, 用\\(\\theta(\\cdot)\\)二者都可以表示\r\n\r\n\r\n","categories":["CS"],"tags":["CS","Algorithm","MIT","Lecture"]},{"title":"【算法】MIT6006:Data Structures and Dynamic Arrays","url":"/2023/02/27/Algorithm/mit6006-2/","content":"\"算法导论\"\r\n课程地址\r\n\r\n\r\n接口和数据结构:\r\n\r\n接口表明\"想做什么\", 数据结构表明\"怎样做\"\r\n接口说明了什么数据可以被存储, 数据结构表示数据怎样存储\r\n接口可以对数据进行操作 (支持什么操作),\r\n数据结构给出算法来表示如何支持这些操作\r\n\r\n\r\n\r\n两个主要接口(interfaces):\r\n\r\n集合(set): 关注变量的值, 按照某个键值(key)取值\r\n序列(sequence): 关注序列的本身, 需要按照特定顺序排列\r\n\r\n\r\n\r\n两个主要DS方法\r\n\r\n数组\r\n指针\r\n\r\n\r\n\r\n内存的计算模型\r\n\r\n以字存储, 字长为\\(w\\)\r\n\r\n\r\n\r\n内存的地址分配模型\r\n\r\n为\\(n\\)个元素分配内存的时间为\\(O(n)\\)\r\n\\(space \\geq O(time)\\)\r\n\r\n\r\n\r\n静态数组\r\n提供的接口: 构建build, 遍历get_seq,\r\n根据给定偏移获取元素get_at,\r\n根据给定偏移地址设置元素set_at\r\n\r\n在内存中有连续的内存分配\r\n支持随机访问\r\n\\(O(1)\\), constant time: 获取元素,\r\n设置元素, 获取数组长度\r\n\\(O(n)\\), linear time: 建立数组,\r\n遍历数组\r\n注意: 字长需要满足 \\(w\r\n\\geq lg(n)\\) , 保证\\(n\\)个元素都能在内存中被分配地址\r\n\r\n\r\n\r\n动态操作\r\n在静态数组的基础上提供: 指定位置插入insert_at,\r\n指定位置删除delete_at\r\n\r\n\\(O(n)\\): 指定位置插入或删除元素的\r\n平均性能\r\n\\(O(1)\\):\r\n在数组末尾插入或删除元素\r\n\r\n\r\n\r\n链表\r\n提供上述所有的接口\r\n\r\n\r\n动态操作 (对比)\r\n\r\n\r\n\r\n\r\n静态数组\r\n链表\r\n\r\n\r\n\r\n\r\n插入或删除\r\n\\(O(n)^1\\)\r\n在头节点\\(O(1)\\)\r\n\r\n\r\n获取或设置\r\n\\(O(1)\\)\r\n\\(O(n)\\)\r\n\r\n\r\n\r\n1: 来源于两个部分:\r\n\r\n插入前元素的搬移操作\r\n若后续空间不足(因为需要保持数组的内存分配连续,\r\n需要在原有的空间中往后扩充), 需要向前扩充内存, 或者重新分配内存,\r\n并且都要将所有的元素进行搬移或复制\r\n\r\n\r\n\r\n动态数组 (如Python的list)\r\n\r\n松弛条件(relax constraint): 当创建包含\\(n\\)个元素的数组时, 分配\\(\\theta(n) \\geq n\\)的空间\r\n依然维护 A[i] = x_i\r\n一般情况下插入末尾: 直接添加至数组后面\r\n(因为后面有足够的空间用来存储元素, 不用考虑分配的空间不足问题)\r\n当数组的size == length时, 需要进行空间分配, 分配\\(c \\times size\\)的空间大小, \\(c\\)为大于1的常数\r\n从空数组开始, 不断地向后插入元素, resize所需要的复杂度为\r\n\\(\\theta(1+2+4+ \\cdots) =\r\n\\theta(\\sum_{i=0}^n 2^{n}) = \\theta(2^{lg(n)} = \\theta(n))\\)\r\nAmortization(分摊): operations takes \\(T(n)\\) amortized time, if any \\(k\\) operations take \\(\\leq k \\cdot T(n)\\) time (averaging over\r\noperation sequence)\r\n\r\n\r\n","categories":["CS"],"tags":["CS","Algorithm","MIT","Lecture"]},{"title":"【算法】MIT6006:Hashing","url":"/2023/03/03/Algorithm/mit6006-4/","content":"\"算法导论\"\r\n\r\n\r\n准备: 对于Set,\r\n有无更快的find(k)的算法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n实现类型\r\nbuild(A)\r\nfind(k)\r\ninsert(x)/delete(k)\r\nfind_min()/find_max()\r\n\r\n\r\n\r\n\r\nArray\r\n\\(O(n)\\)\r\n\\(O(n)\\)\r\n\\(O(n)\\)\r\n\\(O(n)\\)\r\n\r\n\r\nSorted Array\r\n\\(O(nlog(n))\\)\r\n\\(log(n)\\)\r\n\\(O(n)\\)\r\n\\(O(1)\\)\r\n\r\n\r\n\r\n\r\n\r\nfind(k)在比较模型中的复杂度为\\(\\Omega(log(n))\\)\r\n比较模型 Comparison Model:\r\n\r\n假设该模型中, 算法只能通过比较来区别items\r\n比较运算符: \\(&gt;,&lt;,=,\\geq,\\leq,\\neq\\),\r\n返回值是布尔值\r\n该模型存储了\\(n\\)个可比较的items,\r\n并且能够支持find(k)\r\n\r\n\r\n","categories":["CS"],"tags":["CS","Algorithm","MIT","Lecture"]},{"title":"【算法】MIT6006:Linear Sort","url":"/2023/03/08/Algorithm/mit6006-5/","content":"\"算法导论\"\r\n\r\n\r\n比较模型\r\n\r\n两个数之间只能通过比较的方式进行区分\r\n\r\n\r\n\r\n比较模型中排序的复杂度下限\r\n\r\n提出决策树概念\r\n\r\n\r\n\r\n决策树\r\n\r\n最好的情况: 所给的序列已经是有序的, 只需要遍历每一个元素,\r\n复杂度为\\(\\Omega(n)\\)\r\n最坏的情况: 复杂度为\\(\\Omega(n\r\nlog(n))\\)\r\n\r\n\r\n","categories":["CS"],"tags":["CS","Algorithm","MIT","Lecture"]},{"title":"【算法】MIT6006:Sets and Sorting","url":"/2023/03/02/Algorithm/mit6006-3/","content":"\"算法导论\"\r\n\r\n\r\n集合Sets\r\n\r\n容器\r\n键值: 每一个元素与一个唯一的键值相关联\r\n支持的操作以及复杂度\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n实现类型\r\nbuild(A)\r\nfind(k)\r\ninsert(x)/delete(k)\r\nfind_min()/find_max()\r\n\r\n\r\n\r\n\r\nArray\r\n\\(O(n)\\)\r\n\\(O(n)\\)\r\n\\(O(n)\\)\r\n\\(O(n)\\)\r\n\r\n\r\nSorted Array\r\n\\(O(nlog(n))\\)\r\n\\(log(n)\\)\r\n\\(O(n)\\)\r\n\\(O(1)\\)\r\n\r\n\r\n\r\n\r\n\r\n排序\r\n\r\n重构型 destructive: 重写整个数组\r\n交换型 in place: 使用\\(O(1)\\)的空间复杂度\r\n\r\n\r\n","categories":["CS"],"tags":["CS","Algorithm","Data Structure"]},{"title":"【C++】CMake Tutorial","url":"/2022/08/10/CS/CMakeTutorial/","content":"CMake version: 3.x\r\n\r\nCommand Line\r\n# (configure step) create build dir, and generate build/Makefile -&gt; generate Makefilecmake -B build# (build step) invoke building system and build the project in different OS -&gt; generate executable filecmake --build build -j4# invoke building system to execute target &quot;install&quot;cmake --build build --target install# define configure variables, only use in configure step# use -D# set build type in configure step, the value will remain when invoked the second time unless delete build dircmake -B build -DCMAKE_BUILD_TYPE=Release# Specify generator (generator: generate build system build rule from CMakeLists.txt)# use -G# generator Ninja, faster than Unix Makefile, generate *.ninjacmake -B build -G Ninja\r\nCMakeLists.txt\r\nadd source file\r\n(1). single file: main.cpp\r\nadd_executable(main main.cpp)\r\nor\r\nadd_executable(main)target_sources(main PUBLIC main.cpp)\r\n(2). multiple files: main.cpp | other.cpp | other.h\r\nadd_executable(main)target_sources(main PUBLIC main.cpp other.cpp)\r\nor set a new variable\r\nadd_executable(main)set(sources main.cpp other.cpp other.h)  # other.h can deletetarget_sources(main PUBLIC $&#123;sources&#125;)\r\nor use GLOB to search all files in current dir\r\nadd_executable(main)file(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)  # add CONFIGURE_DEPENDS to detect any change when next buildtarget_sources(main PUBLIC $&#123;sources&#125;)\r\nwhen we have a dir structure:\r\nmylib  +----*.cpp  +----*.h*.cpp*.h\r\nno need to write all files:\r\n# add all file in current dir and mylib diradd_executable(main)aux_source_directory(. sources)aux_source_directory(mylib sources)target_sources(main PUBLIC $&#123;sources&#125;)\r\nor use GLOB_RECURSE to find all files recursely:\r\nadd_executable(main)file(GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h)target_sources(main PUBLIC $&#123;sources&#125;)\r\nERROR: use GLOB_RECURSE will include *.cpp files in\r\nbuild dir.\r\nsolution: Add all source files in a dir named\r\nsrc\r\nConfigure variables\r\nCMAKE_BUILD_TYPE: type of build,\r\nRelease, Debug,\r\nMinSizeRel and RelWithDebInfo,\r\ndefualt: none (debug).\r\nset(CMAKE_BUILD_TYPE Release)\r\nset default build type as Release to reach high performance: in the\r\nfirst three lines:\r\nif (NOT CMAKE_BUILD_TYPE)    set(CMAKE_BUILD_TYPE Release)endif()\r\n# Specify version of cmakecmake_minimum_required(VERSION 3.22)# set c++ standard# don&#x27;t modify CMAKE_CXX_FLAGS to add -std=c++17set(CMAKE_CXX_STANDARD 17)# if use the needed CXX standard defined.set(CMAKE_CXX_STANDARD_REQUIRED ON)  # OFF default# prevent features GCC onlyset(CMAKE_CXX_EXTENSIONS OFF)# set project infoproject(project_name LANGUAGES language_list(such as C CXX ASM...))\r\nLinkable library\r\nadd_executable(main mian.cpp mylib.cpp)\r\nor generate a static library\r\nadd_library(mylib STATIC mylib.cpp)  # create libmylib.aadd_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\r\nor generate dynamic lib\r\nadd_library(mylib SHARED mylib.cpp)add_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\r\nor use object lib, no *.a file, let CMake remember which objects\r\nfiles are created\r\nadd_library(mylib OBJECT mylib.cpp)add_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\r\n静态库问题: GCC会自行剔除没有引用符号的对象, 此时使用对象库避免,\r\n从而不会自动剔除没引用到的对象文件, 绕开编译器不统一问题.\r\n动态库也可以避免剔除没引用的对象文件, 但引入了运行时链接的麻烦.\r\n# no specify variable in add_library()set(BUILD_SHARED_LIBS ON)  # default OFFadd_library(mylib mylib.cpp)\r\nHINT 静态库常常被认为直接链接到可执行文件上.\r\n因此在动态库中不要链接静态库. 很呆. 地址会变.\r\n当然解决方法是: 要么转化为对象库,\r\n要么让静态库变成地址无关的代码PIC\r\n# set global propertyset(CMAKE_POSITION_INDEPENDENT_CODE ON)add_library(otherlib STATIC otherlib.cpp)add_library(mylib SHARED mylib.cpp)target_link_libraries(mylib PUBLIC otherlib)add_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\r\nor set local property\r\n# set local propertyadd_library(otherlib STATIC otherlib.cpp)set_property(TARGET otherlib PROPERTY POSITION_INDEPENDENT_CODE ON)add_library(mylib SHARED mylib.cpp)target_link_libraries(mylib PUBLIC otherlib)add_execuable(main main.cpp)target_link_libraries(main PUBLIC mylib)\r\nAttributes of objects\r\n设置单属性: set_property(TARGET ... PROPERTY ...);\r\n设置多属性:\r\nset_target_properties(file_name PROPERTIES properties_list)\r\nHINT:\r\n以上命令在add_executable后有效.\r\n设置全局属性 (改变属性的默认值): set(CMAKE_XXX),\r\n在add_executable前设置.\r\n\r\n如果需要在Windows下面使用动态库 (Windows对动态链接不友好),\r\n则需要在定义和声明添加: Deffinition: #include &lt;cstdio&gt;#ifdef _MSC_VER__declspec(dllexport)#endifvoid sayy_hello()&#123;&#125;\r\nDeclaration: #pragma once#ifdef _MSC_VER__declspec(dllimport)#endifvoid say_hello(); 然后CMakeLists.txt这样写:\r\n# In Main dircmake_minimum_required(VERSION 3.22)add_subdirectory(mylib)  # add sub moduleadd_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)# In sub module diradd_library(mylib SHARED mylib.cpp mylib.h) 然后Windows极有可能会报错: 运行时找不到dll;\r\n原因是dll和exe不在同一目录 (Windows只会查找exe所在目录和PATH). -\r\n把dll添加到PATH环境变量 - 或者dll和dll其他的所有依赖dll,\r\n全部拷贝到exe同一目录\r\n这是因为CMake把main放在build下, 而mylib放在build/mylib/mylib.dll\r\n\r\n因此重定向输出路径, 改变mylib属性, 让.dll文件输出到\r\nPROJECT_BINARY_DIR 里面. set_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_(DEBUG | RELEASE | NONE) | ARCHIVE_OUTPUT_DIRECTORY | LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_BINARY_DIR&#125;)\r\nExternel library\r\nIn Linux: feel free to link externel libraries. (/usr/lib/...) But\r\nWindows can't. Linux can also include head file directly\r\n(/usr/include/...).\r\nHINT: CMake 的分隔符永远是 \"/\", 即使是Windows,\r\nCMake会自动转化.\r\nMore general method: find_package(package_name REQUIRED)\r\n没听懂, 以后补, 以后也不想补.\r\nVariables and Outputs\r\noutput some log infomation when running cmake -B build,\r\nused for debugging. message(&quot;log info&quot;)\r\nmessage(STATUS &quot;status info&quot;)  # -- prefix\r\nmessage(WARNING &quot;warning info&quot;)  # yellow\r\nmessage(SEND_ERROR &quot;error info&quot;)  # send error log but continue to runmessage(FATAL_ERROR &quot;error info&quot;)  # print error and stop running\r\nVariable and Cache\r\n重复执行cmake -B build: 第一次较慢,\r\n将环境的检测存入缓存, 第二次以及以后直接查看缓存内容.\r\n因此某些错误可以通过删除 ./build/CMakeCache.txt解决.\r\n当然也可以删了整个build文件夹重新编译, 慢一点而已.\r\n","categories":["CS"],"tags":["C++","Programming"]},{"title":"【算法】MIT6046-1:Introduction","url":"/2023/02/27/Algorithm/mit6046/","content":"\"算法设计与分析\"\r\nhttps://www.youtube.com/watch?v=2P-yW7LQr08&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=1\r\n\r\n","categories":["CS"],"tags":["CS","Algorithm","MIT","Lecture"]},{"title":"【算法】排序和分治","url":"/2023/05/30/Algorithm/sort-dc/","content":"\"一个小tutorial\"\r\n\r\nBF\r\n冒泡排序的改进\r\n4，3，2，1，5，6，7，8，9\r\n\r\n当考虑元素4时，从元素5以后不再交换。\r\n改进：记录最后一次发生交换的位置，下次比较时到此结束\r\n对于阶数有无改进：\r\n\r\n从 inversion\r\n的角度：每次比较能消除多少对inversion。改进后消除inversion的速度没有改变。\r\n\r\n\r\nQS\r\n快排的平均时间复杂度\r\n分析输入\\(\\{a_1,a_2,\\cdots,a_n\\}\\)，定义随机变量\\(X_{ij}=\\{a_i\\ compared\\ with\\\r\na_j\\}\\)，则平均时间复杂度为\\(\\sum_{1\\leq i &lt; j \\leq\r\nn}E[X_{ij}]\\)。但具体的概率不易知（由于输入是随机输入）。但计算概率时只需要\r\n遍历所有的发生比较的pair即可。选取\r\n有序 输入，重新分析：输入\\(Z_1&lt;Z_2&lt;\\cdots\r\n&lt;Z_n\\)，对于快排，选取下标为\\(idx\\)的元素作为pivot，对于任意\\(idx&lt;i\\)，对\\(Z_i\\)是否与\\(Z_j\\)发生比较没有影响，而选取\\(i&lt;idx&lt;j\\)时，二者不发生比较，只有选择\\(idx=i\\ or\\\r\nidx=j\\)时，二者才能进行比较，因此\r\n\\[E[X_{ij}]=\\frac{2}{j-i+1}\\]\r\n\\[\\sum_{i}\\sum_{j}E[X_{ij}]=\\sum_{i}\\sum_{j}\\frac{2}{j-i+1}\\]\r\n","categories":["CS"],"tags":["CS","Algorithm","NJU"]},{"title":"【编译原理】中间代码生成","url":"/2023/01/29/CS/Compiler-MeddleCodeGeneration-zh/","content":"\"书接上文\"\r\n\r\n概述\r\n本章将介绍各类语句的翻译\r\n\r\n声明语句\r\n赋值语句\r\n控制语句\r\n过程调用语句\r\n\r\n声明语句的翻译\r\n收集标识符的类型信息,\r\n为每个标识符分配一个相对地址\r\n类型表达式\r\n\r\n基本类型是类型表达式\r\n可以为类型表达式命名, 类型名是类型表达式\r\n将类构造符 (type constructor) 作用于类型表达式可以构成新的类型表达式\r\n\r\n数组构造符array: \r\n指针表达式pointer: pointer(T)是类型表达式,\r\n表示指向类型T的指针类型\r\n笛卡尔乘积构造符\\(\\times\\):\r\n两个类型表达式通过\\(\\times\\)符号运算后仍然是类型表达式\r\n函数构造符\\(\\rightarrow\\):\r\n函数参数的类型表达式的笛卡尔乘积\\(\\rightarrow\\)函数返回值的类型表达式\r\n记录构造符record: \r\n\r\n\r\n局部变量的存储分配\r\n从类型表达式中可以知道 该类型在运行时刻所需要的存储单元数量\r\n(类型的宽度 width) 在 编译时,\r\n可以使用类型的宽度为每一个名字分配一个 相对地址\r\n名字的类型和相对地址保存在相应的 符号表中\r\n变量声明语句的 SDT:\r\n\r\n\r\n变量声明语句的SDT\r\n\r\n例子: 非数组局部变量声明\r\n考虑有输入: real x; int i;\r\n\r\n\r\ndemo-1\r\n\r\n例子: 数组局部变量声明\r\n考虑有输入: int[2][3]\r\n\r\n\r\ndemo-2\r\n\r\n简单赋值语句的翻译\r\n主要任务为 生成对表达式求值的三地址码,\r\n赋值语句的基本文法为:\r\n\r\n\r\n赋值语句文法\r\n\r\n对该文法定义语义规则生成对应的 SDT 如下:\r\n\r\n\r\n赋值语句SDT\r\n\r\n由于这样的操作, 父结点需要赋值子结点的三地址码,\r\n而子结点需要赋值其子结点的三地址码, 会造成消耗空间大的问题, 因此使用\r\n增量翻译, 即修改gen()函数,\r\n使得其在生成三地址码后将新的三地址添加到当前三地址码的最后.\r\n\r\n\r\n增量翻译SDT\r\n\r\n赋值语句的 LR 分析状态机如下:\r\n\r\n\r\n赋值状态机\r\n\r\n\r\n例子 翻译 x=(a+b)*c\r\n初始时刻\r\n栈状态为\r\n\r\n\r\n\r\n0\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\n\r\n\r\n\r\n读头指向x: id 入栈,\r\n对应综合属性lexeme=x; 0 状态遇到 id 转移至 2\r\n状态\r\n栈状态为\r\n\r\n\r\n\r\n0\r\n2\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\n\r\n读头指向=: =入栈; 2\r\n状态遇到=转移至 3 状态\r\n栈状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\n\r\n\r\n读头指向(: (入栈; 3\r\n状态遇到(转移至 6 状态\r\n栈状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n6\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n(\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\n\r\n\r\n\r\n读头指向a: id 入栈,\r\n对应综合属性lexeme=a; 6 状态遇到 id 转移至 7\r\n状态\r\n栈状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n6\r\n7\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n(\r\nid\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\na\r\n\r\n\r\n\r\n读头指向+: 由于 7 状态为归约状态,\r\n且当前读头下为+, 在 产生式 的 FOLLOW 集合中,\r\n因此可以用产生式 6 进行归约, id 和 7 状态出栈; E 入栈, 执行语义动作, 将\r\nid 的lexeme赋值给E.addr; 6 状态遇到 E 转移至\r\n12 状态; +入栈, 12 状态遇到+转移至 9\r\n状态\r\n栈状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n6\r\n12\r\n9\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n(\r\nE\r\n+\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\na\r\n\r\n\r\n\r\n\r\n读头指向b: id 入栈,\r\n对应综合属性lexeme=b; 9 状态遇到id转移至 7\r\n状态\r\n栈状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n6\r\n12\r\n9\r\n7\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n(\r\nE\r\n+\r\nid\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\na\r\n\r\nb\r\n\r\n\r\n\r\n读头指向): 由于 7 状态为归约状态,\r\n且当前读头下为), 在 产生式 的 FOLLOW 集合中,\r\n因此可以用产生式 6 进行归约, id 和 7 状态出栈; E 入栈, 执行语义动作, 将\r\nid 的lexeme赋值给E.addr; 9 状态遇到 E 转移至\r\n13 状态; 13 状态为归约状态, 且当前读头下为), 在产生式的\r\nFOLLOW 集合中, 因此可以用产生式 2 进行归约, E,+,E\r\n和对应的状态出栈; E 入栈, 执行语义动作,\r\n将E.addr设置为中间变量t1,\r\n并且打印三地址码t1=a+b; 6 状态遇到 E 转移至 12 状态;\r\n)入栈, 12 状态遇到)转移至 15 状态\r\n栈 1 状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n6\r\n12\r\n9\r\n13\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n(\r\nE\r\n+\r\nE\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\na\r\n\r\nb\r\n\r\n\r\n\r\n栈 2 状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n6\r\n12\r\n15\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n(\r\nE\r\n)\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\nt1\r\n\r\n\r\n\r\n\r\n生成代码: t1=a+b\r\n读头指向*: 由于 15 状态为归约状态,\r\n且当前读头下为*, 在产生式的 FOLLOW 集合中, 可以用产生式 5\r\n进行归约, (,E,)和对应的状态出栈, 执行语义动作,\r\n将t1赋值给E.addr; E 入栈, 3 状态遇到 E 转移至\r\n4 状态; *入栈, 4 状态遇到*转移至 10\r\n状态\r\n栈 1 状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\n\r\n\r\n\r\n\r\n\r\n\r\nx\r\n\r\n\r\nt1\r\n\r\n\r\n\r\n栈 2 状态为\r\n\r\n\r\n\r\n0\r\n2\r\n3\r\n4\r\n10\r\n\r\n\r\n\r\n\r\n\r\n\r\n$\r\nid\r\n=\r\nE\r\n*\r\n\r\n\r\n\r\n\r\nx\r\n\r\nt1\r\n\r\n\r\n\r\n\r\n后续栈操作类似\r\n\r\n数组引用的翻译\r\n数组引用翻译的关键是 确定数组元素的存放地址\r\n(数组元素的寻址) 考虑如下的文法:\r\n\r\n\r\n数组赋值语句\r\n\r\n数组元素寻址 主要是计算偏移地址, 计算方式如下:\r\n\r\n\r\n数组元素寻址\r\n\r\n例子\r\n\r\n\r\n数组元素寻址例子\r\n\r\n为数组元素设计三个 综合属性\r\n\r\nL.type: L 生成的数组元素类型, 可以逐层传递,\r\n计算偏移地址\r\nL.offset: 计算数组引用的偏移地址, 用于累加\\(i_j\\times w_j\\)\r\nL.array: 数组名在符号表的入口\r\n\r\n如下为数组翻译的SDT\r\n\r\n\r\n数组引用SDT\r\n\r\n控制流语句的SDT\r\n设计控制流语句的SDT的关键在于弄清楚各个条件的出口以及对应的代码块\r\n控制流语句的基本文法为 (举例)\r\n\r\n\r\n控制流语句文法\r\n\r\n在这里需要引入语句的标号: 一个三地址指令对应一个唯一的标号,\r\n用于控制语句寻找入口和出口\r\n为文法符号添加 继承属性\r\n(注意继承属性计算的位置是在其文法符号出现之前)\r\n\r\nS.next: S代码之后的指令标号\r\nB.true: B为真时转向的指令标号\r\nB.false: B为假时转向的指令标号\r\n\r\n\r\n\r\n控制流SDT-1\r\n\r\n之所以要设计newlabel()函数是因为需要在文法符号出现前计算其继承属性,\r\n但此时的对应标号仍然未知, 因此需要一个\"占位符\";\r\n而设计label()函数的目的是在合适的位置及时为继承属性赋值.\r\n注意: 有些时候的跳转指令包含在布尔表达式中,\r\n在下一节提及\r\n条件语句\r\n\\[\r\nS \\rightarrow if\\ B\\ then\\ S_1\\ else\\ S_2\r\n\\]\r\n其代码结构为:\r\n\r\n\r\n代码结构-1\r\n\r\n当B为true的时候进入S1代码块;\r\n当B为false的时候进入S2代码块;\r\n当分支语句对应的代码执行完以后, 其后续待执行代码与S一致\r\n(出口一致), 其SDT如下:\r\n\r\n\r\n条件语句SDT-1\r\n\r\n注意在S1分析结束后生成三地址码goto,\r\n表示转向某个标号\r\n\\[\r\nS \\rightarrow if\\ B\\ then S_1\r\n\\]\r\n其代码结构为:\r\n\r\n\r\n代码结构-2\r\n\r\nSDT为:\r\n\r\n\r\n条件语句SDT-2\r\n\r\n这里的三地址码生成隐藏在布尔表达式中.\r\n循环语句\r\n\\[\r\nS \\rightarrow while\\ B\\ do\\ S\r\n\\]\r\n代码结构如下\r\n\r\n\r\n代码结构-3\r\n\r\nB为false的时候与S出口一致, 即结束循环;\r\nB为true的时候需要执行循环体内部代码; 当循环体内部代码结束后\r\n需要重新回到while语句判断布尔条件是否仍然成立,\r\n因此需要建立一个保存while语句所在标号的属性, 便于跳转,\r\n也因此在S1执行后需要生成三地址码goto\r\n其SDT为:\r\n\r\n\r\n循环语句SDT\r\n\r\n布尔表达式的SDT\r\n布尔表达式翻译时最重要的是\r\n确定布尔表达式的目标跳转地址,\r\n这一节和下一节分别介绍一种方法, 这一节的方法主要是使用\r\n继承属性, 下一节的方法主要使用\r\n综合属性\r\n布尔表达式的文法如下:\r\n\r\n\r\nbool文法\r\n\r\n其中 不包含 &amp;&amp;, ||, !,\r\n因为这些运算符会被翻译为 跳转指令\r\n其SDT为:\r\n\r\n\r\nbool-SDT-1\r\n\r\n||的代码结构为:\r\n\r\n\r\n或结构\r\n\r\n只要B1和B2中有一个为true则B为true\r\n\r\n\r\n或SDT\r\n\r\n&amp;&amp;的代码结构为:\r\n\r\n\r\n与结构\r\n\r\n只要有一个为false, 则B为false\r\n\r\n\r\n与SDT\r\n\r\n综合例子\r\n任何SDT都可以先建立一个语法分析树,\r\n然后按照从左到右深度优先的顺序执行语义动作\r\n布尔表达式的回填\r\n(backpatching)\r\n控制流语句的翻译关键: 跳转语句的目标标号, 但生成跳转指令时,\r\n目标标号不能确定\r\n上一节处理布尔表达式的方法中, 将存放标号的地址作为\r\n继承属性 传递至目标标号生成的位置,\r\n但代码生成后需要再次遍历三地址码, 绑定属性与具体的标号值,\r\n这样做比较麻烦.\r\n这一节介绍 回填 (backpatching):\r\n生成跳转指令时暂时不指定其目标标号, 而是将其放入队列中,\r\n同一个队列中的所有跳转指令具有相同的目标标号, 待目标标号最终确定时,\r\n再填充.\r\n这里的关键点在于, 使用队列统一管理后, 属性是\r\n综合属性\r\n\r\nB.truelist:\r\n该列表中的所有目标标号出口就是B为真时的出口\r\nB.falselist:\r\n该列表中所有目标标号出口就是B为假时的出口\r\n\r\n需要用到的一些函数:\r\n\r\n\r\n回填函数\r\n\r\n修改后的SDT如下:\r\n\r\n\r\n回填SDT-1\r\n\r\n\r\n\r\n回填SDT-2\r\n\r\n\r\n\r\n回填SDT-3\r\n\r\n\r\n\r\n回填SDT-4\r\n\r\n\r\n\r\n回填SDT-5\r\n\r\n\r\n\r\n回填SDT-6\r\n\r\n\r\n\r\n回填SDT-7\r\n\r\n最后等所有的出口确定后进行回填\r\n控制流语句的回填\r\n添加综合属性:\r\n\r\nS.nextlist:\r\n该列表中的所有目标标号出口是紧跟在S代码之后的指令的标号.\r\n\r\nSDT修改如下:\r\n\r\n\r\n控制回填SDT-1\r\n\r\n\r\n\r\n控制回填SDT-2\r\n\r\n\r\n\r\n控制回填SDT-3\r\n\r\n\r\n\r\n控制回填SDT-5\r\n\r\n\r\n\r\n控制回填SDT-6\r\n\r\nSwitch语句的翻译\r\n\r\n\r\nswitch-sdt-1\r\n\r\n可以将每一个case中的判断代码放入一个代码块中\r\n\r\n\r\nswitch-sdt-2\r\n\r\n二者的不同点还包括, label 的数量不同, 前者是\\(L_{n-1}\\)个, 后者是\\(L_n\\)个\r\n过程调用语句的翻译\r\n过程调用的文法为:\r\n\r\n\r\n过程调用\r\n\r\n参数列表可以 统一使用队列存储\r\n其SDD如下:\r\n\r\n\r\n过程调用SDD\r\n\r\n\r\n\r\n过程调用例子\r\n\r\n","categories":["CS"],"tags":["CS","Compiler"]},{"title":"【编译原理】语义分析","url":"/2023/01/03/CS/Compiler-SemanticAnalysis-zh/","content":"\"书接上文\"\r\n\r\n概述\r\n语义翻译: 语义分析和中间代码生成一起实现.\r\n语法制导翻译: 在语法分析时实现语义翻译.\r\n使用上下文无关文法(CFG)来引导对语言的翻译, 是一种面向文法的翻译技术.\r\n基本思想\r\n语义属性: 在 CFG 中为文法符号设置语义属性,\r\n表示语法成分对应的语义信息.\r\n如何计算:\r\n\r\n用文法符号所在的产生式相关联的语义规则计算\r\n\r\n语法制导定义(SDD):\r\n\r\n将每个文法符号和一个语义属性集合相关联\r\n将每个产生式和一组语义规则相关联,\r\n这些规则用于计算产生式中各个文法符号的属性值\r\n注意: 同一个产生式出现相同符号时, 需要以下标区分,\r\n因为有不同的语义含义\r\n注意: 语义规则可以是一些 副作用 如打印等等\r\n\r\n例子:\r\n\r\n\r\n\r\n产生式\r\n语义规则\r\n\r\n\r\n\r\n\r\n\\(D \\rightarrow T\\ L\\)\r\n\\(L.inh = T.type\\)\r\n\r\n\r\n\\(T \\rightarrow int\\)\r\n\\(T.type = int\\)\r\n\r\n\r\n\\(T \\rightarrow real\\)\r\n\\(T.type = real\\)\r\n\r\n\r\n\\(L \\rightarrow L_1, id\\)\r\n\\(L_1.inh = L.inh\\)\r\n\r\n\r\n\r\n语法制导翻译方案(SDT)\r\n\r\n在产生式右部嵌入程序片段 (语义动作)\r\n\r\n例子:\r\n\r\n\r\n\r\n\\(D \\rightarrow T\\ \\{L.inh = T.type\\}\\\r\nL\\)\r\n\r\n\r\n\r\n\\(T \\rightarrow int\\ \\{T.type =\r\nint\\}\\)\r\n\r\n\r\n\r\n\\(T \\rightarrow real\\ \\{T.type =\r\nint\\}\\)\r\n\r\n\r\n\r\n\\(L \\rightarrow \\{L_1.inh = L.inh\\}\\ L_1,\r\nid\\)\r\n\r\n\r\n\r\n\r\n语义动作在产生式的位置决定了动作的执行时刻:\r\n例如第一个产生式, 在分析出\\(T\\)后,\r\n可以根据语义动作, 将后面的\\(L\\)的语义属性赋值\r\n语法制导定义 SDD\r\n分为 综合属性 和 继承属性\r\n综合属性(Synthesized\r\nattribute)\r\n在分析树上的结点\\(N\\)的\r\n非终结符 \\(A\\)的综合属性只能通过\\(N\\)的子节点或本身的属性值来定义.\r\n\r\n\r\n综合属性例子\r\n\r\n\r\n\r\n综合属性例子\r\n\r\n继承属性(Inherited attribute)\r\n在分析树上的结点\\(N\\)的\r\n非终结符 \\(A\\)的继承属性只能通过\\(N\\)的父节点,\r\n兄弟结点或本身结点的属性值来定义.\r\n\r\n\r\n继承属性例子\r\n\r\n\r\n\r\n继承属性例子\r\n\r\n\r\n终结符只有综合属性,\r\n原因是其综合属性指向的是符号表序号(或者说是词法分析器提供的词法值),\r\n不论其父结点怎么变, 终结符的属性都不会变, 因此不能存在继承属性. \\(SDD\\)中也没有计算终结符属性值的语义规则.\r\n\r\n注释分析树(Annotated parse\r\ntree)\r\n在分析树中标明语义值.\r\nSDD 的求值顺序\r\n在对语法分析树的一个结点求属性值之前, 应该\r\n先求出它所依赖的所有属性值\r\n依赖图(Dependency graph)\r\n\r\n如果\\(X.a\\)的值\r\n依赖于 属性\\(Y.b\\)的值, 则依赖图中有一条 从 Y.b\r\n指向 X.a 的有向边. 方便起见, 可以将\r\n综合属性放在结点的右边, 继承属性放在左边.\r\n注意: 如果语义规则中含有副作用 (即调用了某个函数,\r\n函数中用到了语义属性), 则为它创建一个 虚拟结点,\r\n如下所示\r\n\r\n\r\n\r\n虚拟结点\r\n\r\n可行的求值顺序: 拓扑排序,\r\n依赖者的序号大于被依赖者的序号.\r\n\r\n只有综合属性的 SDD, 可以按照任意自底向上的顺序计算它们的值\r\n同时具有综合属性和继承属性的 SDD,\r\n不能保证存在应该顺序对各个结点上的属性进行求值\r\n依赖图中没有环, 则至少存在一个拓扑排序\r\n\r\n给定一个 SDD, 很难确定是否存在某个语法树, 使得依赖图无环, 但存在\r\n\\(L\\)-属性定义 和\r\n\\(S\\)-属性定义\r\n保证每个语法分析树都存在求值顺序, 依赖图无环.\r\n\\(S\\)-属性定义\r\n仅使用综合属性的 SDD, 可以在\r\n自底向上 的语法分析过程中实现\r\n\\(L\\)-属性定义\r\n在一个产生式所关联的各属性之间, 依赖图的边 可以从左到右,\r\n但不能从右到左. 正式定义为: 一个 SDD 是\\(L\\)-属性定义, 当且仅当它的每个属性要么\r\n是一个综合属性 要么\r\n是满足如下条件的继承属性\r\n\r\n假设存在一个产生式\\(A \\rightarrow\r\nX_1X_2\\cdots X_n\\), 其右部符号\\(X_i\\)的继承属性仅依赖于\r\n\r\n\\(A\\)的继承属性\r\n(不能依赖于父结点的综合属性,\r\n因为父结点的综合属性可能依赖子结点的继承属性, 会导致循环依赖)\r\n产生式中\\(X_i\\)左边的符号的属性\r\n(包括综合属性和继承属性)\r\n\\(X_i\\)本身的属性, 但\\(X_i\\)的全部属性不能在依赖图中形成环路\r\n\r\n\r\n\r\n每个\\(S\\)-属性定义都是\\(L\\)-属性定义\r\n\r\n语法制导翻译方案 SDT\r\n以下两种 SDD 对应的 SDT 可以在语法分析过程中实现\r\n\r\n\\(LR\\)分析, \\(SDD\\)是\\(S\\)属性的\r\n\\(LL\\)分析, \\(SDD\\)是\\(L\\)属性的\r\n\r\nS-SDD: 转化为 SDT 时, 将每个语义动作放在产生式的最后\r\nL-SDD: 转化为 SDT 时\r\n\r\n计算继承属性的动作插入到非终结符的前面\r\n计算综合属性的动作放在产生式的最后\r\n\r\n在非递归的预测分析过程中进行翻译\r\n一个非终结符的继承属性和综合属性在分析过程中的计算时间是不一样的\r\n\r\n继承属性的计算在该非终结符出现之前,\r\n综合属性的计算在该非终结符的所有子结点分析结束之后\r\n\r\n为非终结符的综合属性单独创建一个元素Xsyn,\r\n存放终结符 X 的综合属性, 此时在分析栈中, 包含三种类型的元素:\r\n\r\n\\(action\\):\r\n用于存放执行语义动作的代码指针\r\n\\(A\\): 非终结符\\(A\\)的继承属性\r\n\\(Asyn\\): 非终结符\\(Asyn\\)的综合属性\r\n\r\n分析时的基本原则是 综合记录出栈时,\r\n要将综合属性值复制给后面特定的语义动作,\r\n变量本身的记录出栈时 (发生推导的时候), 如果含有继承属性,\r\n则将其值复制给后面的特定语义动作\r\n具体例子见 非递归翻译例子\r\n在递归预测过程中进行翻译\r\n将每个非终结符实现为一个函数,\r\n该非终结符的每个继承属性是该函数的一个形参,\r\n返回值是该非终结符的综合属性\r\n\r\n\r\n递归翻译\r\n\r\nL-属性定义的自底向上翻译\r\n自底向上翻译要求翻译动作在 归约后调用, 但 L-SDD\r\n中有一部分语义动作处于产生式的中间, 因此使用自底向上翻译时, 需要添加\r\n标记非终结符, 代表 产生式中间的语义动作,\r\n即继承属性对应的语义动作\r\n\r\n\r\nL-属性自底向上翻译-标记非终结符\r\n\r\n其中\\(M,\r\nN\\)位于实际待求继承属性非终结符的左侧, 因此 \\(M,\r\nN\\)的综合属性是后续非终结符的继承属性\r\n\r\n上述文法所对应的\\(SLR\\)自动机如下:\r\n\r\n\r\nL-属性自底向上例子-SLR\r\n\r\n考虑输入串\r\n\\[\r\n3 * 5\r\n\\]\r\n具体见视频讲解: L-属性自底向上例子\r\n\r\n","categories":["CS"],"tags":["CS","Compiler"]},{"title":"【编译原理】存储分配","url":"/2023/02/13/CS/Compiler-StorageAllocation-zh/","content":"\"书接上回\"\r\n\r\n概述\r\n编译器工作时需要为源程序中出现的数据对象分配存储空间.\r\n\r\n静态存储空间: 编译时刻\r\n就可以确定大小的数据对象, 可以在编译时刻确定他们的存储空间,\r\n动态存储空间: 编译时刻不能完全确定对象的大小,\r\n编译时仅产生一些必要的信息, 在 运行时刻\r\n再动态分配存储空间.\r\n\r\n栈式存储分配\r\n堆式存储分配\r\n\r\n\r\n内存划分如下图所示:\r\n\r\n\r\n内存划分\r\n\r\n在栈中存放了一种特殊的数据结构 活动记录\r\n\r\n过程: 即函数, 方法.\r\n若某种语言使用过程让用户自定义动作单元, 则编译器通常\r\n以过程为单位分配存储空间\r\n活动: 过程体的每次执行\r\n活动记录: 过程体每执行一次\r\n\r\n","categories":["Compiler"],"tags":["CS","Compiler"]},{"title":"【CG】GAMES101-Rasterization-1","url":"/2023/03/17/CS/Rasterization-1/","content":"\"看上去是对的，那就是对的\"\r\n\r\n\r\n在进行 Viewing Transformation 后, 所有的物体都变换到了 \\([-1,1]^3\\) 中\r\n\r\n\r\n几个概念\r\n\r\n垂直视角 Field of View\r\n宽高比 aspect ratio\r\n\r\n\r\n\r\n几个概念\r\n\r\n\r\n视口变换 Viewport\r\nTransformation\r\n\r\n屏幕建模\r\n\r\n像素的二维数组\r\n数组的大小称为分辨率\r\n光栅成像设备 (将物体画在屏幕上)\r\n\r\n\r\n\r\n屏幕空间\r\n\r\n由不同的定义方式\r\n坐标的原点在 数组的左下角\r\n向右为\\(x\\)轴, 向上为\\(y\\)轴\r\n像素的中心为\\((x+0.5,y+0.5)\\)\r\n\r\n\r\n\r\n视口变换\r\n\r\n将\\([-1,1]^3\\)变换到屏幕\\([0,width]\\times[0,height]\\)上\r\n先考虑\\(xy\\)两个维度, 不考虑\\(z\\)的深度, 变换矩阵为\r\n\r\n\\[\r\nM=\r\n\\begin{bmatrix}\r\n    \\frac{width}{2} &amp; 0 &amp; 0 &amp; \\frac{width}{2}  \\\\\r\n    0 &amp; \\frac{height}{2} &amp; 0 &amp; \\frac{height}{2} \\\\\r\n    0 &amp; 0 &amp; 1 &amp; 0 \\\\\r\n    0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n\r\n光栅化 Rasiterization\r\n\r\n三角形 Triangle\r\n\r\n最基本的多边形, 所有多边形可以拆分成三角形\r\n唯一确定一个平面\r\n能定义三角形的内外\r\n能比较好地在顶点间进行插值\r\n因此可以使用三角形组合去表示任意物体\r\n\r\n\r\n\r\n采样 Sampling\r\n\r\n采样是将函数离散化的过程\r\n\r\n\r\nfor (auto x &#123;0&#125;; x &lt; x_max; ++x) &#123;    output[x] = f(x);&#125;\r\n\r\n\r\n在图形学中, 用像素中心对屏幕进行采样\r\n可以定义如下函数输出像素点与某个三角形的内外关系\r\n\r\n\r\nint inside(const &amp;Triangle t, const &amp;Point (x, y)) &#123;    return ((x,y) in t)? 1 : 0;&#125;for (auto x &#123;0&#125;; x &lt; x_max; ++x) &#123;    for (auto y &#123;0&#125;; y &lt; y_max; ++y) &#123;        image[x][y] = inside(triangle, (x + 0.5, y + 0.5));    &#125;&#125;\r\n\r\ninside()函数的具体实现: 向量叉积\r\n\r\n\\(\\bigtriangleup ABC\\) 与平面内的点\r\n\\(P\\) 的关系:\r\n若 \\(\\vec{AB}, \\vec{BC}, \\vec{CA}\\)\r\n与 \\(P\\) 的叉积结果\r\n同向 则 \\(P\\)\r\n在三角形内部, 反之在外部\r\n\r\n\r\n\r\n考虑遍历像素的效率问题\r\n\r\n没必要对一个三角形遍历每一个像素\r\n寻找三角形的包围盒 Bounding Box (轴向, 简称 AABB)\r\n确定x_min, x_max,\r\ny_min和y_max为三角形对应的最小,\r\n最大坐标值\r\n\r\n另一种方法:\r\n\r\n对每一行取最值为遍历的范围\r\n\r\n\r\n","categories":["CS"],"tags":["CS","CG","GAMES101"]},{"title":"【CG】GAMES101-Transformation-1","url":"/2023/03/14/CS/Transformation-1/","content":"\"看上去对的, 那它就是对的\"\r\n\r\n缩放 scale\r\n\r\n\r\nscale-1\r\n\r\n\r\n缩放矩阵\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n    x^{\\prime} \\\\\r\n    y^{\\prime}\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n    s_x &amp; 0 \\\\\r\n    0 &amp; s_y\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n    x \\\\\r\n    y\r\n\\end{bmatrix}\r\n\\]\r\n切变 shear\r\n\r\n\r\nshear-1\r\n\r\n\r\n原点水平方向移动为 \\(0\\)\r\n左上角水平方向移动为 \\(a\\)\r\n纵向不移动\r\n\r\n\r\n切变矩阵\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n    x^{\\prime} \\\\\r\n    y^{\\prime}\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n    1 &amp; a \\\\\r\n    0 &amp; 1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n    x \\\\\r\n    y\r\n\\end{bmatrix}\r\n\\]\r\n旋转 rotation\r\n\r\n\r\nrotate-1\r\n\r\n\r\n默认逆时针旋转为正\r\n\r\n\r\n旋转矩阵\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n    x^{\\prime} \\\\\r\n    y^{\\prime}\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n    cos(\\theta) &amp; -sin(\\theta) \\\\\r\n    sin(\\theta) &amp; cos(\\theta)\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n    x \\\\\r\n    y\r\n\\end{bmatrix}\r\n\\]\r\n齐次坐标 homogeneous\r\ncoordinates\r\n\r\n平移 translation 非线性\r\n\r\n\r\n\r\ntranslation-1\r\n\r\n\r\n仿射变换\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n    x^{\\prime} \\\\\r\n    y^{\\prime}\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n    a &amp; b \\\\\r\n    c &amp; d\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n    x \\\\\r\n    y\r\n\\end{bmatrix}+\r\n\\begin{bmatrix}\r\n    t_x \\\\\r\n    t_y\r\n\\end{bmatrix}\r\n\\]\r\n\r\n增加维度\\(\\rightarrow\\)齐次坐标:\r\n\r\n二维点表示: \\((x,y)\\rightarrow(x,y,1)\\)\r\n二维向量表示: \\((x,y)\\rightarrow(x,y,0)\\)\r\n\r\n\r\n\r\n齐次坐标的平移矩阵\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n    x^{\\prime} \\\\\r\n    y^{\\prime} \\\\\r\n    w^{\\prime}\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n    1 &amp; 0 &amp; t_x \\\\\r\n    0 &amp; 1 &amp; t_y \\\\\r\n    0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n    x \\\\\r\n    y \\\\\r\n    1\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n    x+t_x \\\\\r\n    y+t_y \\\\\r\n    1\r\n\\end{bmatrix}\r\n\\]\r\n\r\n注意表示点的时候第三维是1\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n    x^{\\prime} \\\\\r\n    y^{\\prime} \\\\\r\n    w^{\\prime}\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n    a &amp; b &amp; t_x \\\\\r\n    c &amp; d &amp; t_y \\\\\r\n    0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n    x \\\\\r\n    y \\\\\r\n    1\r\n\\end{bmatrix}\r\n\\]\r\n\r\n只有二维仿射变换, 最后一行才是\\((0,0,1)\\)\r\n\r\n\r\n齐次坐标表示下, 先进行线性变换, 再平移\r\n\r\n组合 composition\r\n\r\n左乘变换矩阵表示在上一次变换的结果上进行变换\r\n\r\n逆 inverse\r\n变换的逆即矩阵的逆\r\n\r\n旋转的逆\r\n\r\n旋转\\(\\theta\\)角度\r\n\\[\r\nR_{\\theta}=\r\n\\begin{bmatrix}\r\n    cos(\\theta) &amp; -sin(\\theta) \\\\\r\n    sin(\\theta) &amp; cos(\\theta)\r\n\\end{bmatrix}\r\n\\]\r\n旋转\\(-\\theta\\)角度\r\n\\[\r\nR_{-\\theta}=\r\n\\begin{bmatrix}\r\n    cos(\\theta) &amp; sin(\\theta) \\\\\r\n    -sin(\\theta) &amp; cos(\\theta)\r\n\\end{bmatrix}\r\n\\]\r\n可以发现 \\(R_{-\\theta}=R_{\\theta}^T\\), 满足\r\n正交性\r\n三维情况\r\n\r\n齐次坐标\r\n\r\n点: \\((x,y,z,1)^T\\)\r\n向量: \\((x,y,z,0)^T\\)\r\n\r\n\r\n\r\n绕轴旋转\r\n\r\n\\[\r\nR_x=\r\n\\begin{bmatrix}\r\n    cos(\\alpha) &amp; -sin(\\alpha) &amp; 0 &amp; 0 \\\\\r\n    sin(\\alpha) &amp; cos(\\alpha) &amp; 0 &amp; 0 \\\\\r\n    0 &amp; 0 &amp; 1 &amp; 0 \\\\\r\n    0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\quad\r\nR_y=\r\n\\begin{bmatrix}\r\n    cos(\\alpha) &amp; 0 &amp; sin(\\alpha) &amp; 0 \\\\\r\n    0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n    -sin(\\alpha) &amp; 0 &amp; cos(\\alpha) &amp; 0 \\\\\r\n    0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\quad\r\nR_z=\r\n\\begin{bmatrix}\r\n    1 &amp; 0 &amp; 0 &amp; 0 \\\\\r\n    0 &amp; cos(\\alpha) &amp; -sin(\\alpha) &amp; 0 \\\\\r\n    0 &amp; sin(\\alpha) &amp; cos(\\alpha) &amp; 0 \\\\\r\n    0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\\quad\r\n\\]\r\n\r\n三维任意旋转\r\n\r\n欧拉角 Euler Angle: 绕\\(x, y,\r\nz\\)轴旋转的角度分别为\\(\\alpha, \\beta,\r\n\\gamma\\)\r\n\r\n\r\n\r\nRodrigues' Rotation Formula\r\n\r\n给定旋转轴\\(n\\)和旋转角度\\(\\alpha\\)\r\n注意: 旋转轴的起点默认为 原点\r\n若旋转轴起点不在原点, 则平移至原点, 变换后再平移至原处\r\n\r\n\r\n\\[\r\nR(n, \\alpha)=cos(\\alpha)I+(1-cos(\\alpha))nn^T+sin(\\alpha)\r\n\\begin{bmatrix}\r\n    0 &amp; -n_z &amp; n_y \\\\\r\n    n_z &amp; 0 &amp; -n_x \\\\\r\n    -n_y &amp; n_x &amp; 0\r\n\\end{bmatrix}\r\n\\]\r\n\r\n如何证明\r\n\r\n","categories":["CS"],"tags":["CS","CG","GAMES101"]},{"title":"【CG】GAMES101-Transformation-2","url":"/2023/03/15/CS/Transformation-2/","content":"\"看上去对的, 那它就是对的\"\r\n\r\n视图变换 View/Camera\r\nTransformstion\r\n\r\n三维物体投影至相机的二维平面上\r\n\r\nMVP变换: Model (将模型放置好), View (确定相机位置), Projection\r\n(三维投影至二维)\r\n\r\n\r\n\r\n相机建模\r\n\r\n位置 Position \\(\\vec{e}\\)\r\n朝向 Gaze derection \\(\\widehat{g}\\)\r\n向上方向 Up derection \\(\\widehat{t}\\)\r\n\r\n\r\n\r\n如何进行视图变换\r\n\r\n只要保持所有物体和相机的相对位置不变, 相机拍摄的结果不变\r\n将相机固定 (放在原点, 向\\(-z\\)方向看, 向上方向为\\(y\\)轴为标准位置)\r\n其他物体进行相应变换\r\n\r\n\r\n\r\n相机的变换\r\n\r\n\\(\\vec{e}\\)平移至原点\r\n\\(\\widehat{g}\\)旋转至\\(-z\\)方向\r\n\\(\\widehat{t}\\)旋转至\\(y\\)方向\r\n\r\n\r\n\r\n相机变换的矩阵形式\r\n\r\n先做平移矩阵\\(T\\)\r\n再做旋转矩阵\\(R\\)\r\n注意旋转矩阵可以考虑 逆旋转 即\r\n坐标轴的旋转, 将得到的矩阵求逆 (正交) 即可\r\n\r\n\r\n\r\n事实上按上述变换操作后, 物体和相机都已经处于对应位置上, 称为\r\nModelView Transformation\r\n\r\n投影变换 Projection\r\nTransformation\r\n\r\n正交投影 Orthographic Projection\r\n透视投影 Perspective Projection\r\n\r\n\r\n\r\nprojection-1\r\n\r\n\r\n透视投影假设相机为一个点, 在空间中形成一个四棱锥,\r\n相机可以将四棱锥的两个深度间 (frustum) 的物体显示到近处的平面上\r\n正交投影假设相机处于无穷远, 此时前后两个平面显示在近处平面时,\r\n大小保持\r\n\r\n\r\n正交投影通俗做法\r\n\r\n相机处于标准位置\r\n将\\(z\\)坐标舍去 (即投影至\\(Oxy\\)平面)\r\n将\\(Oxy\\)的投影面变换至\\([-1,1]^2\\) (方便后续计算)\r\n\r\n\r\n\r\n正交投影标准定义\r\n\r\n将三维空间中的立方体 cube \\([l,r]\\times[b,t]\\times[f,n]\\), 映射到标准\r\ncanonical 立方体 \\([-1,1]^3\\) 中\r\n\r\n\r\n\r\northograph-1\r\n\r\n这里会导致物体发生拉伸等形变, 以后还会进行视口变换(Viewport\r\ntransformation)\r\n物体正交投影的变换矩阵为\r\n\\[\r\nM=\r\n\\begin{bmatrix}\r\n    \\frac{2}{l+r} &amp; 0 &amp; 0 &amp; 0 \\\\\r\n    0 &amp; \\frac{2}{b+t} &amp; 0 &amp; 0 \\\\\r\n    0 &amp; 0 &amp; \\frac{2}{n+f} &amp; 0 \\\\\r\n    0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n    1 &amp; 0 &amp; 0 &amp; -\\frac{l+r}{2} \\\\\r\n    0 &amp; 1 &amp; 0 &amp; -\\frac{b+t}{2} \\\\\r\n    0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\\r\n    0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n\r\n\r\n透视投影的坐标基础\r\n\r\n在齐次坐标中, 每一维同乘 \\(z(z\\neq\r\n0)\\) 得到 \\((xz,yz,z^2,z)^T\\)\r\n表示的仍然是三维点 \\((x,y,z)\\)\r\n\r\n\r\n\r\n透视投影的方法\r\n\r\n\r\nperspective\r\n\r\n\r\n将 frustum 映射为 cuboid\r\n保持 远近平面 上\\(z\\)坐标不变\r\n保持远处平面的中点映射为自己\r\n近平面上所有点都映射为本身\r\n\r\n\r\n\r\n透视投影的变换矩阵\r\n计算可以得到 frustum 中的任意点映射后的 \\(x,y\\) 坐标分别为 \\(x^{\\prime}=\\frac{n}{z}x,\r\ny^{\\prime}=\\frac{n}{z}y\\)\r\n因此对于\\(x,y\\)坐标而言, \\((x,y,z,1)^T \\rightarrow (\\frac{nx}{z},\r\n\\frac{yn}{z}, unknown, 1)^T \\rightarrow (nx, ny, unknown,\r\nz)^T\\)\r\n可以得到映射矩阵:\r\n\\[\r\nM=\r\n\\begin{bmatrix}\r\n    n &amp; 0 &amp; 0 &amp; 0 \\\\\r\n    0 &amp; n &amp; 0 &amp; 0 \\\\\r\n    ? &amp; ? &amp; ? &amp; ? \\\\\r\n    0 &amp; 0 &amp; 1 &amp; 0\r\n\\end{bmatrix}\r\n\\]\r\n下面求矩阵 \\(M\\) 的第三行:\r\n由远近平面上的 \\(z\\) 坐标不变\r\n(其中近平面的点映射为自己) 和中点不变两个性质, 对于近平面的点 \\((x,y,n,1)^T\\) , 根据齐次坐标, 映射后应该为\r\n\\((nx,ny,n^2,n)^T\\), 得到方程 \\[\r\nAn + B = n^2\r\n\\]\r\n同理对于远处平面的中点 \\((x,y,f,1)^T\\) 映射为 \\((nx,ny,f^2,f)^T\\), 得到方程 \\[\r\nAf + B = f^2\r\n\\]\r\n解得 \\(A=n+f, B=-nf\\)\r\n因此 由透视投影转换为正交投影的 矩阵为\r\n\\[\r\nM=\r\n\\begin{bmatrix}\r\n    n &amp; 0 &amp; 0 &amp; 0 \\\\\r\n    0 &amp; n &amp; 0 &amp; 0 \\\\\r\n    0 &amp; 0 &amp; n+f &amp; -nf \\\\\r\n    0 &amp; 0 &amp; 1 &amp; 0\r\n\\end{bmatrix}\r\n\\]\r\n\r\n","categories":["CS"],"tags":["CS","CG","GAMES101"]},{"title":"【C++编程】类模板","url":"/2023/02/28/CS/cppStudy-1/","content":"\"C++17类模板\"\r\n\r\n\r\n编译器用于创建类的模板: 自动生成类\r\n\r\n标准库\r\n类模板不是类, 是创建类的一种方式\r\n\r\n\r\n\r\n实例\r\n\r\n编译器从类模板中生成的类, 在第一次使用模板类型声明变量是,\r\n会创建类模板的一个实例, 以后定义同类型的变量时,\r\n会使用已创建的第一个实例. 在创建类模板时, 也可以不同时声明变量.\r\n数据的组织 独立于 对象类型\r\n\r\n\r\n类模板的定义\r\ntemplate&lt;typename T1, typename T2, Type Arg1&gt;class ClassName &#123;    // template class definition&#125;;\r\n\r\n模板参数\r\n\r\n类型参数 typename\r\n\r\n实参总是类型: int, float...\r\n\r\n非类型参数 Type\r\n\r\n实参是整数类型的字面量: 200, 10...\r\n整数常量表达式\r\n指向对象的指针或引用, 函数指针或空指针\r\n\r\n模板\r\n\r\n实参是类模板的一个实例\r\n\r\n\r\n\r\n\r\n在模板定义中, 不需要使用完整的ID, 例如构造函数\r\nClassName&lt;T1&gt;();可以写成ClassName();\r\n不过在模板体的外部标识模板, 则必须使用模板ID\r\n(即在模板类外定义模板中的成员函数时需要显式写出ID)\r\n\r\n一个例子\r\ntemplate&lt;typename T1&gt;class PythonList &#123;private:    int len_;    int size_;    T1* elements_;public:    explicit PythonList&lt;T1&gt;(size_t list_len);    PythonList&lt;T1&gt;(const PythonList&lt;T1&gt;&amp; python_list);    ~PythonList();    T1&amp; operator[](size_t index);    const T1&amp; operator[](size_t index) const;    PythonList&lt;T1&gt;&amp; operator=(const PythonList&lt;T1&gt;&amp; rhs_list);    size_t get_len() const &#123; return len_; &#125;    void allocate_double();&#125;;\r\n类模板成员函数的定义\r\n\r\n若在模板类的内部定义, 实则为 内联\r\n\r\n\r\n如何理解该语法\r\n\r\n类模板的成员函数的外部定义本身就是函数模板,\r\n即使成员函数不依赖类型参数.\r\n若函数没有在类内定义, 则它需要一个模板定义.\r\n定义函数模板中的参数列表必须与类模板参数列表相同.\r\n\r\n\r\n例如\r\n// 析构函数template &lt;typename T1&gt;PythonList&lt;T1&gt;::~PythonList&lt;T1&gt;() &#123;    delete [] elements_;&#125;// 构造函数template &lt;typename T1&gt;PythonList&lt;T1&gt;::PythonList(size_t list_len)    : len_(list_len), size_(FOLD * list_len), elements_(new T1(list_len)) &#123;&#125;template &lt;typename T1&gt;PythonList&lt;T1&gt;::PythonList(const PythonList&lt;T1&gt; &amp;python_list)    : PythonList&#123;python_list.len_&#125; &#123;  for (size_t i&#123;&#125;; i &lt; len_; ++i) &#123;    elements_[i] = python_list.elements_[i];  &#125;&#125;// 下标运算符template &lt;typename T1&gt; T1 &amp;PythonList&lt;T1&gt;::operator[](size_t index) &#123;  if (index &gt;= len_) &#123;    throw std::out_of_range&#123;&quot;Index out of range: &quot; + std::to_string(index)&#125;;  &#125;  return elements_[index];&#125;template &lt;typename T1&gt;const T1 &amp;PythonList&lt;T1&gt;::operator[](size_t index) const &#123;  if (index &gt;= len_) &#123;    throw std::out_of_range&#123;&quot;Index out of range: &quot; + std::to_string(index)&#125;;  &#125;  return elements_[index];&#125;// 赋值运算符template &lt;typename T1&gt;PythonList&lt;T1&gt; PythonList&lt;T1&gt;::operator=(const PythonList&lt;T1&gt;&amp; rhs_list) &#123;    if (&amp;rhs_list != this) &#123;        delete [] elements_;        len_ = rhs_list.len_;        size_ = rhs_list.size_;        elements_ = new T1[len_];        for (size_t i &#123;&#125;; i &lt; size_; ++i) &#123;            elements_[i] = rhs_list.elements_[i];        &#125;    &#125;    return *this;&#125;\r\n\r\n第一行说明该函数为模板函数; 在限定成员函数时,\r\n作用域需要带上模板ID\r\n有时候需要提供自己的拷贝构造(或析构),\r\n因为涉及到动态内存分配时, 默认拷贝构造(或析构)有可能会出现负面效应\r\n在赋值重载时, 需要 检查左右操作数是否相等,\r\n否则会释放this指向的对象后再进行复制.\r\n\r\n代码重复\r\n\r\n在上述的定义中,\r\nconst的重载和非const的重载模板函数代码重复,\r\n代码重复不利于后续的维护\r\n\r\n对抗重复的方法: 函数, 模板, 基类\r\n\r\n\r\n传统方法:\r\n用const实现非const\r\ntemplate &lt;typename T1&gt;T1&amp; PythonList&lt;T1&gt;::operator[](size_t index) &#123;    return const_cast&lt;T1&amp;&gt;(static_cast&lt;const PythonList&lt;T1&gt;&amp;&gt;(*this) [index]);&#125;\r\nC++17:\r\nstd::as_const()(utility头文件)\r\ntemplate &lt;typename T1&gt;T1&amp; PythonList&lt;T1&gt;::operator[](size_t index) &#123;    return const_cast&lt;T1&amp;&gt;(std::as_const(*this)[index]);&#125;\r\n异常安全性\r\n\r\n在赋值运算符重载的时候, 由于使用了new,\r\n可能会出现std::bad_alloc异常\r\n在elements_[i] = rhs_list.elements_[i];可能会出现关于类型T1的赋值异常\r\n\r\n\r\n当声明了noexcept后, 表示代码内部不发生异常,\r\n使得编译器能做更多的优化,\r\n例如大部分析构都隐式声明了noexcept cppreference noexcept\r\n\r\n\r\n在以上的赋值运算符中使用 复制后交换\r\n\r\n定义模板类注意\r\n\r\n\r\n成员函数模板与类模板的定义放在同一个文件中: 当编译器生成类模板时,\r\n需要去使用函数模板, 所以在使用模板的源文件中,\r\n这些成员函数的定义必须可用.\r\n\r\n\r\n类模板实例化\r\nPythonList&lt;double&gt; data &#123;10&#125;;\r\n\r\n编译器只编译程序使用的成员函数,\r\n不会为某个模板参数的实例而一次性编译整个类:\r\n例如上述代码编译后的类中只有构造函数和析构函数.\r\n\r\n\r\n声明对象类型的指针 不会 创建模板实例:\r\nPythonList&lt;std::string&gt;* data_p;\r\n\r\n非类型的类模板参数\r\n\r\n主要用于定义指定容器有效的值, 如数组的维数\r\n\r\n非类型参数只能是整数类型 (size_t,\r\nlong), 枚举类型, 对象的指针或引用, 函数的指针或引用,\r\n类成员的指针\r\n当作常量\r\n\r\n\r\ntemplate&lt;typename T1, size_t size&gt;class ClassName &#123;    // definition&#125;;// 还有一些比较无语的template&lt;typename T1, T1 value&gt; ... // 此时T1只能是模板的非类型参数所允许的类型\r\n\r\n注意\r\n只有模板参数完全相同的情况下, 编译器才不会再次编译模板类;\r\n任意一个不同, 编译器都会认为是不同的类, 后果是代码膨胀\r\n\r\n解决方法 (待定)\r\n\r\n\r\n模板参数的默认值\r\n\r\n与函数的默认参数类似\r\n\r\n如果某个模板参数有默认值, 则后续的参数也必须有默认值\r\n如果某个模板参数的实参被省略, 则后续的所有实参也必须省略\r\n不需要在成员函数的模板中指定默认值\r\n\r\n\r\ntemplate&lt;typename T1 = int, int value = 10&gt; ...\r\n模板的显式实例化\r\ntemplate class ClassName&lt;T1, 10, ...&gt;\r\n\r\n编译器会从模板中实例化所有的成员函数, 无论是否调用\r\n\r\n类模板特化\r\n模板的使用中有时候只对 某些类型 有用,\r\n而不支持其他类型; 因此使用 特化 来处理某些特殊情况.\r\n例如整型变量的相等和浮点型的比较并不相同,\r\n这时可以使用模板的特化来处理.\r\n\r\n对于类模板中的成员函数:\r\n\r\n如果成员函数是在类模板的外部定义的, 而不是在类模板体中定义的,\r\n则可以提供函数模板的特化\r\n\r\n\r\n全特化\r\n即规定模板实现的所有模板参数\r\ntemplate&lt;&gt;class PythonList&lt;const char*&gt;&#123;&#125;;\r\n\r\n特化的定义必须放在原有的定义或声明后面.\r\n因为指定了所有参数, 所以是 全特化\r\n\r\n偏特化\r\n即只规定模板参数列表中的一部分模板参数\r\ntemplate&lt;Type value&gt;class PythonList&lt;const char*, value&gt; &#123;&#125;;\r\n\r\ntemplate后的参数列表包含的是为这个模板特化的实例所指定的参数,\r\n即实例化时需要指定value\r\n模板名后面的尖括号指定原有类模板定义中的参数如何特化.\r\n该参数列表必须与原来未特化的类模板个数相同\r\n\r\n\r\n指针类型的偏特化\r\n例如下面代码: template的第一个参数仍是T1,\r\n但模板名后面可以跟着T*\r\n\r\ntemplate&lt;typename T1, Type value&gt;class ClassName&lt;T1*, value&gt; &#123;&#125;;\r\n\r\n特化的选择\r\n当匹配给定特化的每个实参匹配多个特化时, 编译器会选择\r\n最特殊 的一个特化.\r\n\r\n特殊是指有多个匹配, 如果符合A特化, 也符合B特化, 但反过来不行时,\r\n则A比B更特殊 (A含于B)\r\n\r\n\r\n在类模板中使用static_assert()\r\nstatic_assert()接受两个参数,\r\n第一个参数为false时, 输出第二个参数指定的消息.\r\n第一个实参使用type_traits.h中的模板\r\n\r\n\r\ntype_traits\r\n\r\n类模板的友元\r\n对于友元函数和友元类的情况与一般情况相同\r\n\r\n模板友元\r\n\r\n类模板的参数列表一般包含定义友元模板的所有参数\r\n如果类模板的一些参数在友元模板中没有,\r\n则友元模板的实例会用于类模板的几个实例\r\n普通类若有友元模板, 则友元的每一个实例都是这个类的友元\r\n\r\n\r\n","categories":["CS"],"tags":["CS","C++"]},{"title":"【操作系统】Overview","url":"/2023/05/17/CS/os-1/","content":"\"计算机三大浪漫之一\"\r\n\r\n什么是操作系统\r\n\r\nA body of software, in fact, that is responsible for making it easy\r\nto run programs (even allowing you to seemingly run many at the same\r\ntime), allowing programs to share memory, enabling programs to interact\r\nwith devices, and other fun stuff like that. (OSTEP)\r\n\r\n操作系统是如何从一开始变成这样的\r\n三个线索\r\n\r\n计算机（硬件）\r\n程序（软件）\r\n操作系统（管理软件的软件）\r\n\r\n对单一计算机硬件系统作出抽象、支撑程序执行的软件系统（狭义）\r\n\r\n\r\n\r\n1940s：第一台计算机\r\n\r\n计算机系统 = 状态机\r\n标准的Mealy型数字电路（ENIAC-1946-2-14）\r\n\r\n延迟线存储器\r\n图灵机\r\n没有操作系统（运行程序需要接线，对，物理意义的接线）\r\n\r\n\r\n1950s：更快更小的逻辑门，磁芯内存，IO设备（1953年出现中断）\r\n1957：Fortran\r\n\r\n操作系统的概念开始形成：管理多个程序依次排队运行的库函数和调度器，需求是多用户排队共享计算机\r\n\r\n操作（operate）任务（jobs）的系统（system）\r\n批处理系统 = 程序的自动切换（换卡）+ 库函数API\r\nDISK Operating System\r\n(DOS)：开始出现设备，文件，任务等对象和API\r\n\r\n\r\n1960s：集成电路，总线开始出现，更大的内存（支持把多个程序一起放在内存里）\r\n\r\n能同时载入多个程序到内存且灵活调度它们的管理程序，包括程序可以调用的API\r\n有了进程（progress）的概念\r\n进程执行IO时，将CPU让给其他进程：在多个地址空间隔离的程序之间切换\r\n\r\n既然操作系统可以实现程序的切换，不如让它们能够定时切换\r\n\r\n基于中断机制：使程序在执行时，异步地插入函数调用，由操作系统决定（调度策略）是否应该切换到另一个程序执行\r\nMultics(MIT,1965):现代操作系统诞生\r\n\r\n1970s+：集成电路空前发展，PC，CISC,\r\n中断，IO，异常，MMU，网络，PASCAL, C\r\n\r\n分时系统成熟，UNIX（单用户系统）诞生和完善\r\n1973：管道（对象），信号API，grep（应用程序）\r\n1983：BSD socket（对象）\r\n1984：procfs（对象）\r\nUNIX衍生家族：1BSD, GNU, MacOS, Minix, Windows, Linux0.01...\r\n\r\n\r\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Multi-prossesor","url":"/2023/05/23/CS/os-3/","content":"\"计算机的三大浪漫之一\"\r\n\r\n多处理器编程\r\n\r\n并发 concurrent: existing, happening, or done\r\nat the same time. In computer science, concurrency refers to the ability\r\nof different parts or units of a program, algorithm, or problem to be\r\nexecuted out-of-order or in partial order, without affecting the final\r\noutcome\r\n\r\n有共享内存的执行流\r\n\r\n执行流有独立的堆栈和寄存器\r\n共享所有的内存（指针可以互相引用）\r\n从状态机视角：每个执行流有独立的stack\r\nframes链表，但是共享全局变量和堆。处理器每次选择其中一个执行流执行（状态转移为被执行的执行流以及相应的内存发生改变，其余执行流不变）\r\n\r\n最早的并发程序：系统调用的代码（操作系统）\r\n\r\njyy的线程库，编译时要加上-lpthread\r\n\r\n创建一个线程：\r\n\r\n入口函数是fn的线程，立即开始执行\r\n语义：在状态机中新增stack\r\nframe链表并初始化为fn(tid)\r\n\r\nvoid create(void *fn) &#123;  assert(tptr - tpool &lt; NTHREAD);  *tptr = (struct thread) &#123;    .id = tptr - tpool + 1,    .status = T_LIVE,    .entry = fn,  &#125;;  pthread_create(&amp;(tptr-&gt;thread), NULL, wrapper, tptr);  ++tptr;&#125;\r\n等待线程结束：\r\n\r\n等待所有运行线程的fn返回\r\n在有其他线程未执行完时死循环，否则返回（while(other threads not return);）\r\n\r\nvoid join() &#123;  for (int i = 0; i &lt; NTHREAD; i++) &#123;    struct thread *t = &amp;tpool[i];    if (t-&gt;status == T_LIVE) &#123;      pthread_join(t-&gt;thread, NULL);      t-&gt;status = T_DEAD;    &#125;  &#125;&#125;\r\n\r\n如何理解【等待】\r\n当某一个状态执行的线程\r\nT1执行join后，后续每一个状态：若处理器选择执行\r\nT1，则回到当前原状态，直到所有其他进程都返回了。\r\n\r\n\r\n操作系统会自动把不同的线程放在不同的处理器上面，后台运行发现CPU的使用率超过100%\r\n\r\n\r\n证明线程会共享内存\r\n\r\n可以设置全局变量\r\n\r\n如果内存是共享的，某个线程改变全局变量时，其他线程都能看到\r\n\r\n创建多个线程，线程内去修改或查看全局变量\r\n\r\n\r\n\r\n证明线程可以有独立的堆栈\r\n\r\n__thread 可以将变量声明为 thread local\r\n的，线程内部可见\r\n\r\n\r\n\r\n查看创建线程的系统调用\r\n\r\nstrace\r\nclone是用于创建线程的系统调用\r\n\r\n\r\n\r\n原子性：一段代码执行独占整个计算机系统\r\n\r\n单处理器多线程：线程运行时可能被中断，切换到另一个线程执行\r\n多处理器多线程：线程并行执行\r\n\r\n\r\n\r\n实现原子化\r\n\r\n唔...不理解\r\n\r\n\r\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Program","url":"/2023/05/17/CS/os-2/","content":"\"计算机的三大浪漫之一\"\r\n\r\n什么是程序\r\n\r\n源代码视角\r\n\r\n程序也是状态机（数字系统是状态机，程序运行在数字系统上）\r\nC程序也是状态机 应该落实到可执行的语句\r\n\r\n状态 = 栈 + 堆（stack frame的列表，每个frame有PC，全局变量）\r\n初始状态：main函数执行的第一条语句，全局变量初始化\r\n迁移：执行一条简单语句（top stack frame的PC的语句），PC++\r\n函数调用：将栈帧压栈\r\n函数返回：将栈帧出栈\r\n\r\n\r\n\r\n\r\n二进制视角\r\n\r\n还是状态机，状态 = 内存M + 寄存器R\r\n操作系统上的程序：所有的指令都只能做计算。这些指令无法使程序停下来。(M,R)-&gt;(M',R')，纯计算\r\n调用操作系统syscall：把（M,R）完全交给操作系统，任其修改，OS可以自己决定返回（M',R'），可以实现与操作系统中其他对象的交互：读写文件/操作系统状态，改变进程（运行中的状态机）状态（创建进程，销毁自己）\r\n程序是计算 + syscall\r\n\r\n\r\n\r\n如何在程序的两个视角之间切换\r\n\r\n编译器Compiler：源代码S（状态机） -&gt; 二进制代码C（状态机），C =\r\ncompile(S)\r\n正确的编译（优化）：S与C的可观测行为严格一致（S中不可优化的内容在C中必须一致，包括system\r\ncalls, volatile, variable loads/stores,\r\ntermination）。Trivially正确的实现：直接翻译/解释执行S的语义\r\n\r\n\r\n\r\n操作系统中的一般程序\r\n\r\n程序 = 计算 -&gt; system -&gt; 计算 -&gt; ...\r\n操作系统收编了所有的软硬件资源，只能用操作系统的允许方式访问系统的对象（能够管理多个状态机）\r\n【面试题】二进制程序状态机的第一条指令是什么（一个简单的Hello World\r\nC程序执行的第一条指令在哪里。）：用gdb -&gt;\r\nstarti，或者查看进程信息info proc &#123;mappings&#125;（因为它也是状态机，所以有OS给的初始状态）（如果想改的话就去改elf二进制文件）\r\n【面试题】main函数在执行前、中、后发生了哪些操作系统的API调用。用trace（linux里面的工具是strace）可以查看system\r\ncall，当然第一句是execve。本质上所有的程序和HelloWorld类似：\r\n\r\n被OS加载：通过另一个进程执行execve设置为初始状态\r\n状态机执行：进程管理（fork, execve, exit,\r\n...），文件/设备管理（open, close, read, write, ...），存储管理（mmap,\r\nbrk, ...）\r\n直到 _exit(exit_group)退出\r\n\r\n\r\n\r\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Concurrency Program","url":"/2023/05/23/CS/os-4/","content":"\"计算机的三大浪漫之一\"\r\n\r\n如何理解并发程序的执行\r\n\r\n也就是画状态机：把所有可能状态都画出来\r\n\r\n\r\n互斥mutual exclusion：\r\n保证两个代码不能同时执行一段代码\r\n\r\n假设基本操作为读写原子的，如何实现共享内存上的互斥\r\n\r\n处理器不是原子地处理load和store的\r\n\r\n\r\nPeterson算法（谦让）\r\n\r\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【讲座纪要】Abording Information","url":"/2023/01/05/Life/Abording/","content":"\"讲座记录\"\r\n\r\nUseful(?) Websites\r\n\r\n\r\nwebsites\r\n\r\nThe British\r\n\r\n\r\nbritish-level\r\n\r\n越早申请越好\r\nDurham University\r\nUniversity of Edinburgh\r\nHerior-Watt University\r\nThe US\r\n\r\n\r\nfee\r\n\r\n\r\n\r\nUS-level\r\n\r\n申请直博免学费?\r\n加拿大备选, 工资不高\r\n\r\n套磁时会比较尴尬, 老师回面试说科研问题, 最好有实习, 专业方向的经历,\r\n体现专业能力\r\nHong Kong\r\n\r\n\r\nHongKong-level\r\n\r\nSingapore\r\n\r\n\r\nSingapore-level\r\n\r\nCanada\r\n\r\n\r\nCanada-level\r\n\r\nEurope\r\n\r\n\r\nEurope-level\r\n\r\n","categories":["Life"],"tags":["Lecture","Life","Abording"]},{"title":"【第一篇博客】Baby Blog","url":"/2022/01/11/Life/BabyBlog/","content":"Finished! My First Blog!\r\nAfter a long time deploying my blog webpage and a lot of other\r\nborthering settings, I finally finished it! I mean, FINALLY!!!\r\n:laughing: :laughing: :laughing:\r\n\r\nOriginal Intention\r\nCan a programmer has no personal blog? I have seen many blogers\r\nwriting their own blogs no metter answering a question or just taking\r\nnotes from time to time on websites such as zhihu and csdn, but among which I prefer is to\r\nestablish a personal website where I can put my blogs on.\r\nSo, at first I have no intention about what to do with my site, maybe\r\nI just feel that it's really cool to have such a lovely home for oneself\r\nto \"lie down and rest\".\r\nBut when it was finally established by myself, experencing a lot of\r\nconfusing problems and taking amount of time to debug, I must to say\r\nthat, I love here, and I believe I will take after it like taking after\r\na baby, a baby who are growing up. :blush:\r\nThanks\r\nI would not finish my work without the help of JerryYang, whose\r\nhelpful blog is the guidance of mine (though there are still some\r\nmistakes maybe? :dizzy_face:). Based on it, I have known some basic\r\ncommand with Linux, Git and Github,\r\nwhich is also beneficial for my lessons next term. Except him I want to\r\nlink some videos there to thank for another ups from bilibili:\r\nusing\r\nhexo to start blog\r\nhow\r\nto writing blogs\r\n","categories":["Life"],"tags":["Life","Blog"]},{"title":"【数学杂记】空间杂谈","url":"/2022/03/20/Math/%E7%A9%BA%E9%97%B4%E6%9D%82%E8%B0%88/","content":"\"内积空间和度量空间有什么区别? Hilbert空间是什么?\r\n它与线性空间的关系是什么?\"\r\n\"我已经晕了.\"\r\n\r\n数域\r\n\\(P\\)是包含0, 1的数集, 且对 \\(P\\)中任意两个数的加减乘除运算封闭, 则称\r\n\\(P\\)是一个数域.\r\n线性空间\r\n在数域的基础上, 我们提出线性空间的概念:\r\n给定数域 \\(P\\) , 和集合 \\(V\\). 有如下映射: \\[\r\n+:V\\times V\\rightarrow V\r\n\\] \\[\r\n\\cdot:P\\times V\\rightarrow V\r\n\\] 且 (\\(V, P, +, \\)) 满足八条基本性质,\r\n则\\(V\\)称为一个线性空间.\r\n赋范空间\r\n赋范空间是定义在线性空间之上的.\r\n定义在数域 \\(P\\) 的线性空间 \\(V\\) 存在如下映射: \\[\r\n||\\cdot||:  V\\rightarrow R\r\n\\] 且该映射满足: 正定, 齐次, 三角不等式. 则 \\(V\\) 是一个赋范空间,\r\n其中映射 \\(||||\\) 称为范数.\r\n内积空间\r\n内积空间是定义在线性空间之上的.\r\n定义在数域 \\(P\\) 的线性空间 \\(V\\) 存在如下映射: \\[\r\n\\cdot:  V\\times V\\rightarrow R\r\n\\] 则 \\(V\\) 是一个内积空间.\r\n定义了内积后, 我们可以讨论向量 (即线性空间的元素) 间的长度和夹角,\r\n并进一步讨论正交性等.\r\n注意: 内积本身具有自然定义的范数, 即内积可以诱导出范数, \\(||x||=\\),\r\n因此内积空间含于赋范空间.\r\n度量空间\r\n度量空间是某个具有距离函数的集合. 该函数定义的是集合内所有元素的距离,\r\n即集合上的某种度量, 即:\r\n给定集合\\(V\\), 有映射: \\[\r\nd:V\\times V\\rightarrow \\mathbf{R}\r\n\\] 满足:\r\n\r\n[\r\n\\[\\begin{aligned}\r\n&amp;d(x,y)\\geq0\\quad (d(x,y)=0\\Leftrightarrow x=0,y=0)\\\\\r\n&amp;d(x,y)=d(y,x)\\\\\r\n&amp;d(x,y)\\leq d(x,z)+d(z,y)\r\n\\end{aligned}\\]\r\n]\r\n\r\n注意: 此处并未要求线性结构.\r\n注意: 赋范空间一定可以诱导出度量空间,\r\n因此赋范空间含于度量空间\r\n完备空间\r\n完备空间又称 Cauchy 空间. 完备空间是定义在度量空间之上的.\r\n若度量空间 \\(M\\) 中所有的柯西序列都收敛在 \\(M\\) 中的一点, 则 \\(M\\)\r\n是一个完备空间.\r\nHilbert空间\r\n在内积空间的基础上增添完备性条件,\r\n即得到Hilbert空间.\r\n总结\r\n范数运算+向量空间=(线性)赋范空间\r\n(线性)赋范空间 + 内积运算=内积空间\r\n(线性)赋范空间 + 完备性 = Banach 空间\r\n内积空间 + 完备性 = Hilbert 空间\r\n内积空间 + 完备性 + 有限维 = Euclidean 空间\r\nReferences\r\nzhihu:\r\nhttps://www.zhihu.com/question/332144499/answer/731866608\r\nhttps://www.zhihu.com/question/42312263/answer/699451330\r\nwikipedia:\r\nhttps://en.wikipedia.org/wiki/Complete_metric_space\r\nhttps://en.wikipedia.org/wiki/Metric_space\r\nhttps://en.wikipedia.org/wiki/Cauchy_sequence\r\nhttps://en.wikipedia.org/wiki/Cauchy_sequence\r\nhttps://en.wikipedia.org/wiki/Cauchy_sequence\r\nhttps://en.wikipedia.org/wiki/Normed_vector_space\r\n","categories":["Math"],"tags":["Math"]},{"title":"【日常】今天又是码代码的一天呢","url":"/2022/10/12/Life/code/","content":"\"正如标题所言\"\r\n\r\n2022年秋\r\nDisk上的矩阵乘法\r\n\r\n10/16\r\ndiscription: 由于矩阵太大, 不能一次性load进内存, 希望研究缓存大小,\r\n对矩阵乘法效率的影响.\r\nlang: Cpp\r\nproject: 暂未完成\r\n\r\n本来以为挺简单的一个作业, 没想到这么复杂, 10%的时间在写矩阵乘法,\r\n自以为是地写了个指定嵌套顺序的for循环,\r\n然后发现难点在于文件的读取和写入.\r\n问题 1: 写入时覆盖\r\n由于缓存大小有限, 并且对于特定的for循环顺序,\r\n矩阵可能需要以列的方式写入, 这时候如何定位指针的顺序?\r\n问题 2: 读取时返回\r\n意思是我需要的矩阵的绝对坐标小于此坐标在缓存上的相对坐标(即相对坐标小于0),\r\n这时候需要返回去读取, 但是如果从头开始读取, miss hit 的数目会陡然增加,\r\n如果从当前位置读取, 需要知道上一次指针的位置,\r\n然而上一次的指针已经被更新了, 并且更新的时间不在同一个生命周期.\r\n问题 3: 以上两种情况有可能在读取和写入时都出现\r\n问题 4: 写入时返回需要先读取再写入,\r\n直到下标符合条件\r\n外部快排\r\n\r\n10/9\r\ndiscription: use interval heap to realize the priority double ended\r\nqueue (PDEQ); use PDEQ to do external sort.\r\nlang: Cpp\r\nproject: ExternalQuickSort\r\n\r\n说实话还是第一次写一个六百多行的代码.\r\n虽然不知道用六百行实现一个简单的外部快速排序是否比较能令人接受,\r\n但我还是从中学到了很多东西.\r\n使用STL\r\n以前一般是说说要用STL比较高效, 不过自己看了一些教程以后,\r\n也一直没有什么用武之地, 所以很多东西经常会忘.\r\n然后这份代码里就用了很多的诸如std::deque,\r\nstd::vector等一些简单的STL, 当然,\r\n期间还用了一些std::priority_queue,\r\n但是发现并不能实现自己的目标 (能以\\(O(1)\\)效率返回最大值和最小值),\r\n所以就基于std::deque做了一个interval heap.\r\n官网DOC\r\n以前不太习惯在这里参考资料,\r\n但是终于对网上那些复制粘贴的, 没有思考的blog忍无可忍了,\r\n于是转身求助官网.\r\nCMake\r\n之前自己学了CMake, 这次终于用上了. yysy,\r\nCLion的CMake及时更新还挺好的.\r\nMain\r\n说说主要内容.\r\n这里主要是针对内存大小有限, 希望能对硬盘上的大量数据排序.\r\n\r\n人为定义宏来规定当前的内存大小 (只关心待排序的数据,\r\n不考虑中间变量)\r\n将内存划分为 Input, Small, Large 和 Middle 四个区. Middle\r\n相当于快排里的pivot, 然后递归对Small和Large排序,\r\n这里使用循环+栈的方式实现递归.\r\n文件读写, 我认为的本项目最繁琐的操作之一. 因为当缓冲区满了以后,\r\n再次写入时, 可能需要保留上一次写入的末尾位置,\r\n所以我新定义了一个栈用来存末尾指针.\r\n\r\n","categories":["Life"],"tags":["Life","Dairy"]},{"title":"【人工智能】人智导论复习","url":"/2023/01/05/ML/IntroductionToAI/","content":"\"复习课的主旨\"\r\n\"去看GZQ的PPT\"\r\n\r\n然后Jerry告诉了我一些考题,\r\n我的评价是\"xx\"\r\n道听途说的题目归纳\r\n\r\n什么是人工智能\r\n\r\n答4个定义, 越多越好\r\n\r\n\r\n\r\n默写BN范式\r\n\r\n? 有病\r\n\r\n\r\n\r\n考离散里面的等价公式 (包括他们的名称)\r\n\r\n\r\n计算贝叶斯, 以及贝叶斯网这个图里面元素的意义\r\n\r\n绪论:\r\n什么是人工智能, 给出功能模块和实现方法\r\n基本概念\r\n\r\n\r\n像人一样思考的系统\r\n理性地思考的系统\r\n像人一样行动的系统\r\n理性的行动的系统\r\n\r\n\r\n\r\n\r\n理性Agent方法: Agent 是某种能够行动的东西.\r\nRational Agent 可以通过自己的行动获得\r\n最佳的结果 或者在不确定的情况下获得\r\n最佳期望\r\n功能有 能做正确的推论, 若没有能证明正确性的事情,\r\n但是必须 有所行动.\r\n\r\n\r\n\r\n部分完成理性行动的方法和推论过程无关 (如反射活动)\r\n\r\n\r\n图灵测试\r\n\r\n\r\n理性的好处:\r\n\r\n比\"思维法则\"方法通用, 正确的推论只是实现理性的方法之一\r\n比人类思维更经得起科学的考验 (可以证伪)\r\n\r\n\r\n\r\n功能模块: 也就是说, 作为人工智能,\r\n你觉得计算机应该需要哪些模块\r\n\r\n自然语言处理: 计算机可以用各种语言成功交流\r\n知识表示: 储存计算机所知道的信息\r\n自动推理: 用于回答问题和提取新的结论\r\n机器学习 (即归纳推理): 能适应新环境, 并能检测和推断新模式\r\n计算机视觉: 可以感知物体\r\n机器人技术: 可以操作物体\r\n\r\n\r\n\r\n实现方法: 从组成架构需要哪些模块,\r\n和训练Agent的途径回答\r\n\r\n组成模块: 传感器, 执行器\r\n需要编写Agent程序, 获得Agent函数\r\n可以通过机器学习, 不确定性决策和规划等方法\r\n\r\n\r\n四种定义\r\n\r\n\r\n1. 像人一样思考的系统\r\n\r\n2. 理性思考的系统\r\n\r\n3. 像人一样行动的系统\r\n\r\n4. 理性行动的系统\r\n\r\n图灵测试 (Turing Test)\r\n目的是为智能提供一个满足可操作要求的定义\r\n\r\n如果人类在提出一些书面问题后, 计算回答这些问题,\r\n若无法判断答案是否由人写出, 那么计算机通过了图灵测试\r\n(对于无法给出定义的题目, 应该给出其评价标准)\r\n\r\n理性 Agent 方法\r\n\r\nAgent\r\n是某种能够行动的东西, 可以实现自主控制的操作, 感知环境, 持续能力,\r\n适应变化, 以及有能力承担其他Agent的目标\r\n\r\n要么能做出正确推论, 要么对某件事情有所行动\r\n\r\n\r\n\r\nRational Agent\r\n可以通过自己的行动获得 最佳的结果\r\n或者在不确定的情况下获得 最佳期望的结果\r\n\r\n比思维法则通用\r\n比建立在人类行为, 思维基础上的方法更经得起科学发展的检验\r\n\r\n\r\n\r\n理性\r\n\r\n完美理性:\r\n总能做正确的事情，这在复杂环境下是不可行的。但完美理性是分析的出发点，这样可以简化问题\r\n有限理性: 要求在没有足够计算时间的前提下采取正确的行动\r\n\r\n\r\n智能化Agent:\r\nAgent的架构。并且要理解Agent的任务、环境、评价标准等\r\n从分析Agent、环境、和它们的关系入手。观察到某些Agent比其它Agent更为出色，从而引出理性Agent的概念：行为表现尽可能好的Agent;\r\n对环境进行分类, 说明环境对Agent的影响; 给出部分Agent的架构或体系结构\r\n基本概念\r\n关于智能体, 理性智能体的概念\r\n\r\nAgent\r\n\r\n通过传感器感知所处的环境,\r\n通过执行器对环境产生作用\r\n例子 (人类, 机器人, 软件等)\r\n\r\n\r\n\r\nagent的工作原理,\r\nAgent通过传感器、执行器与环境交互。问号表示从感知到动作的映射函数\r\n\r\n\r\n\r\nAgent和环境\r\n\r\n感知信息: 任何时刻的感知输入\r\n感知序列: 所有的输入数据的完整历史\r\nAgent在任何时刻的行动选择, 取决于到该时刻为止的整个感知序列\r\nAgent函数:\r\n将任意给定感知序列映射到Agent的动作。可以描述Agent的行为。可以用列表表示,\r\n可以通过实验找出感知序列、并记录Agent的行动，来构造该表。Agent函数是抽象的数学表示。Agent程序是具体实现。该程序在Agent自身的结构上运行\r\n理性Agent是做事正确的智能体, 因此需要一些评判标准,\r\n判断智能体做的正确与否\r\n\r\n\r\n\r\n性能度量\r\n\r\nAgent成功程度的标准\r\n具体而言:\r\n当把Agent置于一个环境中后，它将针对收到的感知信息产生动作序列。该动作序列引起环境历经一个状态序列。如果该状态序列是想要的，则Agent的性能良好。\r\n概括来说就是: 智能体在环境中 &gt; 智能体产生动作序列 &gt;\r\n影响环境 &gt; 环境产生状态序列 &gt;\r\n判断状态序列是否为期望的\r\n\r\n\r\n\r\n理性的判断标准\r\n\r\nPPT, 要记\r\n定义成功标准的性能度量\r\nAgent对环境的先验知识\r\nAgent可以执行的动作\r\nAgent的感知序列\r\n\r\n\r\n\r\n理性Agent的标准严谨定义\r\n对于每个可能的感知序列，根据已知的感知序列提供的证据(evidence)和Agent内建的先验知识，理性Agent应该选择期望能使其性能度量最大化的行动。\r\n信息收集是理性的重要部分:\r\n理性Agent需要经常进行观察\r\n理性还要求智能体 从感知的东西中学习\r\n\r\n\r\n理性和全知\r\n全知的智能体, 知道它的动作产生的实际效果, 并且做出相应的动作\r\n理性不等于完美:\r\n理性是使期望的性能最大化。而完美是使实际的性能最大化\r\n\r\n\r\n函数计算: 设计者与Agent是分工和合作的关系\r\n\r\n设计阶段: 设计者完成一些计算\r\n决策阶段: 思考下一步动作时, Agent会做更多的计算\r\n学习阶段: 从经验中学习的时候, Agent会做更多的计算\r\n以决定如何修正自己的行为\r\n\r\n\r\n\r\n学习和自主性\r\n理性Agent是自主的, 会尽可能学习以弥补不全面, 不正确的先验知识.\r\n学习是Agent自适应性的基础\r\n\r\n关于环境的概念\r\n\r\n任务环境(PEAS)\r\n包括 性能度量Performance, 环境Environment, 执行器Actuators,\r\n传感器Sensors\r\n\r\n\r\nPEAS举例\r\n\r\n属性集: 完全可观察的、部分可观察的; 确定的、随机的; 情节的、连续的;\r\n静态的、动态的;离散的、连续的; 单Agent、多Agent\r\n\r\nAgent的类型\r\nAI的任务是设计Agent程序, 实现感知信息映射到动作的Agent函数. Agent =\r\n程序 + 体系结构.\r\n\r\nAgent程序\r\n具有相同的框架：从传感器得到当前感知信息作为输入，返回一个动作交给执行器\r\n\r\n\r\nagent的工作原理,\r\nAgent通过传感器、执行器与环境交互。问号表示从感知到动作的映射函数\r\n\r\n\r\n\r\nAgent程序和Agent函数的区别\r\n程序: 以当前的感知作为输入\r\n函数: 以整个感知历史作为输入\r\n\r\n\r\n表驱动的Agent\r\nAgent程序 &gt; 感知新的信息 &gt; 记录感知序列 &gt;\r\n使用感知序列作为索引，到动作表里查询以决策该做什么 &gt;\r\n动作表明确表示了Agent程序实现的Agent函数。\r\n存在的问题: 没空间, 没时间, 没指导.\r\n\r\n因此可以对Agent进行一些限制, 以满足日常的需求: 不同的Agent区别在于:\r\nAgent函数不一样\r\n\r\n先画图, 再解释\r\n\r\n简单反射型Agent :\r\n简单反射型Agent基于当前的感知选择行动，忽略其余的感知历史。\r\n可以建造一个通用的 条件-行动 规则解释器.\r\n(不包含历史信息, 只根据当天的环境).\r\n条件-行动规则解释器又称 如果-那么规则, 产生式\r\n\r\n\r\nagent-type-1\r\n\r\n\r\n一些缺点\r\n只有在可以仅根据当前感知信息来完成决策的情况下才能工作。只有环境完全可观察的情况下，即使有少量不可观测的情况也会引起严重问题\r\n在部分可观察的环境中，简单的反射型Agent可能陷入无限循环\r\n随机化\r\n随机化可以部分避免无限循环的问题。随机的简单反射Agent其表现可能胜过确定性的简单反射Agent\r\n\r\n\r\n举例\r\n人脸识别、语音识别等是简单反射型Agent\r\n\r\n基于模型的反射型Agent\r\n包含历史信息, 状态信息.\r\n\r\n内部状态包括: 世界如何独立于Agent而发展的信息;\r\nAgent自身的动作如何影响世界的信息\r\n\r\n\r\n\r\nagent-type-2\r\n\r\n\r\n举例\r\n深度学习中的LSTM、和注意力机制等属于基于模型的反射型Agent\r\n\r\n基于目标的Agent\r\n不仅需要采用行动, 还需要规定相应的目标.\r\n既要追踪记录世界的状态，又要记录要达到的目标集，并选择能（最终）达到目标的动作\r\n\r\n\r\nagent-type-3\r\n\r\n判断执行的动作会不会使得自己离目标更近\r\n\r\n注意基于目标和基于条件-行动规则有根本的不同\r\n\r\n\r\n举例\r\n路径规划、8数码问题等属于基于目标的Agent\r\n\r\n基于效用的Agent\r\n单靠目标难以在多数环境中产生更好的行为, 需要更快, 更安全, 更可靠等;\r\n如果一个世界状态比另一个更受偏好，则对Agent来说有更高的效用（utility）\r\n\r\n效用函数: 描述Agent与状态相关的偏好程度,\r\n在目标不充分的情况下有助于理性决策\r\n\r\n多目标: 加权\r\n存在冲突目标: 折中\r\n拥有显式的效用函数的Agent可以做出理性决策\r\n\r\n\r\n\r\n\r\nagent-type-4\r\n\r\n\r\n结果的获得\r\n最佳期望效用是通过计算所有可能结果状态的加权平均值得到，其权值由结果的概率确定\r\n\r\n\r\n举例\r\n机场选址、雄安新区、高铁路线等决策，属于基于效用Agent\r\n\r\n学习Agent\r\n\r\n学习元件: 负责改进, 利用来自评价原件的反馈, 评价Agent做得如何,\r\n并决定应该如何修改执行元件以在未来做得更好\r\n执行元件: 负责选择外部动作\r\n评价元件: 评价Agent做得如何\r\n问题产生器: 负责提议可以产生新的, 有启发式价值的经验和动作\r\n\r\n\r\n\r\nagent-type-5\r\n\r\n\r\n例子: 西洋跳棋, 强化学习\r\n\r\n逻辑Agent\r\n\r\n命题逻辑的语法\r\n推理模式, 方法\r\n怪兽世界的推理 (\\(R_1-R_{10}\\)的证明, \\(R_{11}-R_{15}\\)将句子转化成合取范式,\r\n然后基于归结或反证法的证明)\r\n理解推理规则和公理, 用于命题逻辑的推理\r\n命题逻辑的连接符及语义\r\n\r\n\r\n什么是逻辑Agent\r\n\r\n研究可表示世界的Agent。采用推理过程以得到关于世界的新表示，并且用这些新表示来推导下一步做什么\r\n讨论知识的表示与推理过程\r\n\r\n\r\n\r\n推理\r\n\r\n可以产生新的知识，可以增强感知能力，尤其在部分可观察的环境中\r\n只有推理才能够处理部分可观察的环境。推理包括演绎推理、归纳推理等。归纳推理就是机器学习\r\n\r\n\r\n\r\n逻辑\r\n知识库由语句构成; 用 语法来表达语句;\r\n还要定义语义,\r\n语义必须和语句的“含义”有关。语言的语义定义了每个语句关于每个可能世界的真值。\r\n\r\n基于知识的Agent\r\n具有灵活性, 能通过被告知, 主动学习环境的新知识从而快速获得能力,\r\n并可以通过相关知识以适应环境的变化\r\n核心构件是 知识库(Knowledge base, KB),\r\n知识库是语句(sentence)的集合.\r\n\r\n知识库的操作有TELL, ASK,\r\nFOLLOW\r\n\r\n每次调用Agent程序, 完成以下内容:\r\n\r\nTELL知识库自己的感知内容\r\nASK知识库应该执行什么动作, 知识库根据当前世界的状态,\r\n可能动作序列的结果进行推理\r\n选择动作后, Agent要TELL知识库,\r\n记录选择的动作并执行\r\n\r\n完全自治的Agent: 为Agent提供某种机制, 使它可以自我学习.\r\n并且学习得到的知识可以并入知识库, 用于决策.\r\n怪兽世界 (Wumpus World)\r\n\r\n怪兽世界\r\n由多个房间组成，由通道连接起来的洞穴。在洞穴的某处隐藏着一只怪兽，它会吃掉进入房间的人。Agent可以射杀怪兽，但是只有一只箭。某些房间内有陷阱，人会被陷阱吞噬。但是怪兽除外。因为它太大。某些房间有金子。\r\n\r\n\r\nWumpus World\r\n\r\nPEAS描述如下:\r\n\r\n性能度量:\r\n捡到金子得+1000，掉进陷阱-1000，被怪兽吃掉-1000，每采用一个动作-1，用掉箭-10\r\n环境: 𝟒×𝟒的房间网格。Agent每次都从标号[1,\r\n1]的方格出发，面向右方。金子和怪兽的位置按均匀分布、随机选择除了起始方格以外的方格。另外，除了起始方格外，任一方格都可能为陷阱，概率为0.2\r\n执行器:\r\nAgent可以向前移动、左转90度、右转90度。如果进入陷阱、或有活着怪兽的方格，将死去。进入有死怪兽的方格，是安全的。尽管很臭。如果Agent前方有墙，则向前移动无效。动作Grab可以捡起Agent所处方格的物体。动作Shoot向Agent正对的方向射出一支箭。Agent只有一支箭，因此只有第一个Shoot动作有效。\r\n传感器:\r\nAgent有5个传感器，每个可以提供单一信息。在怪兽所在之处、以及与之直接相邻（非对角的）方格内，可以感知到臭气。在于陷阱直接相邻的方格内，可以感知到微风。在金子所处的方格内，可以感知到闪闪金光。当Agent撞到墙时，它感知到撞击。当怪兽被杀死时，它发出嚎叫，在洞穴内的任何地方都可以感知到。\r\n\r\n初始化:\r\n感知：臭气、微风、金光、撞击、嚎叫\r\n动作：前移、左转90度、右转90度、捡起物体、射箭\r\n初始状态：[1, 1]，且是安全的。方向：朝右\r\n\r\n\r\nAgent比较保守, 总是选择已经标注为OK的方格前进\r\n\r\n\r\n\r\n\r\n怪兽世界中Agent采取的第一步行动。(a)感知到[None,\r\nNone, None, None, None]后的初始情形。(b)移动一步以后，感知为[None,\r\nBreeze, None, None,\r\nNone]。有微风，意味着相邻单元至少有一个有陷阱。\r\n\r\n根据[1, 1]没有臭气、微风的事实，Agent可以推断[1, 2]和[2,\r\n1]都没有危险。用一个OK标注该事实。谨小慎微的Agent将只移动到那些已经明确标志为OK的方格。假设Agent决定向前移动到[2,\r\n1]\r\nAgent在[2,\r\n1]检测到微风，因此在相邻的某个方格中必然有一个陷阱。根据游戏规则，陷阱不可能在[1,\r\n1]，陷阱必然在[2, 2]、[3, 1]、或两者都有.\r\n图中符号?表示在这些方格中可能存在陷阱。此刻标注为OK且未被访问的方格仅有一个。因此这个Agent会转身返回[1,\r\n1]，接着前进到[1, 2]。\r\n\r\n\r\nAgent取得进展的两个后续阶段。(a)第三步移动之后，感知为[Stench,\r\nNone, None, None, None] 。(b)第五步移动之后，感知为[Stench, Breeze,\r\nGlitter, None, None]\r\n\r\n[1, 2]的新感知为[Stench, None, None, None,\r\nNone]。造成如图7.4(a)所示的知识状态。在[1,\r\n2]中的臭气意味着附近必定有怪兽。但是根据游戏规则，怪兽不可能在[1,\r\n1]。而且也不可能在[2, 2]。否则在[2,\r\n1]时应该可以检测到臭气。因而，能够推断怪兽在[1,\r\n3]。用符号W!标识。此外[1, 2]中没有微风，暗示着[2,\r\n2]不存在陷阱。然而已经推断出[2, 2]或[3,\r\n1]中必定有一个陷阱，因此该陷阱在[3, 1]。\r\n到目前为止，Agent已经证明[2,\r\n2]中没有陷阱、没有怪兽，因此它的标注为OK，可以安全地移动过去。将不显示Agent在[2,\r\n2]的知识状态，只是假设Agent转身并移动到[2, 3]。\r\nAgent在[2, 3]检测到金光，因此捡起金子、游戏结束。\r\n\r\n\r\n在每种情况下，Agent根据可用的信息得出结论。如果信息正确，那么结论保证是正确的。这是逻辑推理的基本性质。\r\n\r\n命题逻辑语法\r\n逻辑蕴涵(entailment): \\(\\alpha \\models \\beta\\)\r\n\r\n语句\\(\\alpha\\)蕴涵语句\\(\\beta\\)当且仅当在\\(\\alpha\\)为真的每个模型中, \\(\\beta\\)也为真 (\\(\\alpha\\)为真, \\(\\beta\\)也为真)\r\n模型的意思相当于赋值\r\n\r\n\r\n\r\nentailment-例子-1\r\n\r\n对于Agent回到(1,1)后, 一共有8种赋值情况, 其中, 若做0步推导\r\n(只依靠本身的知识), 则只有3种情况使得KB为真,\r\n若再次基础上提出两个推论:\r\n\r\n\\(\\alpha_1=[1,2]\\)中无陷阱\r\n\\(\\alpha_2=[2,2]\\)中无陷阱\r\n\r\n则有结论: \\(KB \\models \\alpha_1\\),\r\n\\(KB \\nvDash \\alpha_2\\)\r\n\r\n逻辑推理和模型检验\r\n\r\n蕴涵和逻辑推理的区别。蕴涵是通过真值表进行推理，也叫模型检验。而逻辑推理是通过推理规则集进推理\r\n\r\n\r\n推导: \\(KB \\vdash_i\r\n\\alpha\\)\r\n\r\n\\(\\alpha\\)通过推理算法\\(i\\)从KB导出\r\n\\(i\\)从KB导出\\(\\alpha\\)\r\n\r\n\r\n推理的可靠性和完备性\r\n\r\n可靠性: 只导出蕴涵句的推理算法被称为可靠的、或真值保持的推理.\r\n模型检验在可行的情况下是可靠的过程。\r\n完备性: 推理算法是完备的。\r\n\r\n\r\n命题逻辑\r\n\r\n逻辑连接符\r\n\r\n\r\n\r\n连接符\r\n意义\r\n\r\n\r\n\r\n\r\n\r\n\r\n\\(\\neg\\)\r\n非, 否定式\r\n\r\n\r\n\r\n\\(\\wedge\\)\r\n与, 合取式\r\n\r\n\r\n\r\n\\(\\vee\\)\r\n或, 析取式\r\n\r\n\r\n\r\n\\(\\Rightarrow\\)\r\n蕴涵式\r\n\r\n\r\n\r\n\\(\\Leftrightarrow\\)\r\n当且仅当, 双向蕴涵式\r\n\r\n\r\n\r\n\r\n\r\n优先级顺序 (从高到低): \\(\\neg, \\wedge, \\vee, \\Rightarrow,\r\n\\Leftrightarrow\\)\r\n\r\n\r\n命题逻辑的BNF\r\n\r\nSetence -&gt; AtomicSentence | ComplexSentenceAtomicSentence -&gt; True | False | SymbolSymbol -&gt; [A-Z]ComplexSentence -&gt; $neg$ Sentence                |  (Sentence $\\wedge$ Sentence)                |  (Sentence $\\vee$ Sentence)                |  (Sentence $\\Rightarrow$ Sentence)                |  (Sentence $Leftrightarrow$ Sentence)\r\n括号不能省 (除非依赖优先级)\r\n\r\n语义 用于判定关于特定模型的语句真值的规则\r\n\r\n\r\n真值表\r\n\r\n\r\nlogic-1\r\n\r\n\r\n\r\n知识库的构建\r\n考虑怪兽世界: \\(B_{i,j}\\)表示\\((i,j)\\)有微风, \\(P_{i,j}\\)表示\\((i,j)\\)有陷阱, 构建如下的知识库\r\n\r\n\r\n\r\n语句\r\n\r\n\r\n\r\n\r\n\r\n\\(R_1\\)\r\n\\(\\neg P_{1,2}\\)\r\n\r\n\r\n\\(R_2\\)\r\n\\(B_{1,1} \\Leftrightarrow (P_{1,2} \\vee\r\nP_{2,1})\\)\r\n\r\n\r\n\\(R_3\\)\r\n\\(B_{2,1} \\Leftrightarrow (P_{1,1} \\vee\r\nP_{2,2} \\vee P_{3,1})\\)\r\n\r\n\r\n\\(R_4\\)\r\n\\(\\neg B_{1,1}\\)\r\n\r\n\r\n\\(R_5\\)\r\n\\(B_{2,1}\\)\r\n\r\n\r\n\r\n于是知识库可以为\\(R_1 \\wedge R_2 \\wedge R_3\r\n\\wedge R_4 \\wedge R_5\\);\r\n知识库可以看成单一语句，也可以看成多个语句的合取。只是看问题的角度不同而已\r\n\r\n\r\n逻辑推理的目标是判断某些语句\\(\\alpha\\), \\(KB\r\n\\models \\alpha\\)是否成立\r\n\r\n推理模式, 推理方法\r\n\r\n画真值表 (不推荐, 繁琐)\r\n运用公式法则 (重要, 要记)\r\n\r\n\r\n\r\nformula\r\n\r\n\r\n\r\nlogic-2\r\n\r\n\r\n\r\nlogic-3\r\n\r\n\r\n重言式 (合法的)\r\n\r\n在所有的模型中都为真\r\n\r\n\r\n\r\n可满足性\r\n\r\n在某些模型中为真\r\n\r\n\r\n\r\n反证法\r\n\\(\\alpha \\models \\beta \\Leftrightarrow\r\n(\\alpha \\wedge \\neg \\beta)\\)是不可满足的\r\n\r\n\r\n推理模式\r\n用一些标准模式推导出结论链, 假设横线上方的公式为真,\r\n推导出下方的东西也为真\r\n\r\n\r\n分离规则(Modus Ponens)\r\n\\(\\frac{\\alpha \\models \\beta,\r\n\\alpha}{\\beta}\\)\r\n\r\n\r\n消去规则\r\n\\(\\frac{\\alpha \\wedge\r\n\\beta}{\\alpha}\\)\r\n\r\n\r\n所有逻辑等价都可以作为推理规则\r\n\r\n\r\n\r\n\r\n证明\r\n\r\n推理规则的应用序列\r\n有两种证明方法，真值表和推理。显然：真值表是正确且完备的，但效率低。而推理的效率高，但是推理规则集可能正确、但不完备\r\n\r\n\r\n\r\n单元归结规则\r\n\\(\\frac{l_1 \\vee \\cdots \\vee l_k \\quad\r\nm}{l_1 \\vee \\cdots \\vee l_{i-1} \\vee l_{i+1} \\vee \\cdots \\vee\r\nl_k}\\)\r\n\r\n其中 \\(l_i\\)与\\(m\\)互补\r\n\r\n\r\n\r\n全归结规则(长度为2)\r\n\\(\\frac{l_1 \\vee l_2 \\quad \\neg l_2 \\vee\r\nl_3}{l_1 \\vee l_3}\\)\r\n\r\n\r\n归并\r\n\r\n合并文字的多余副本\r\n即 \\(A \\vee A \\Leftrightarrow\r\nA\\)\r\n\r\n\r\n\r\n归结: 只能取一项进行归结, 不能同时取很多项,\r\n只用于文字的析取式\r\n\r\n\r\n合取范式(CNF): 文字析取式的合取形式, CNF,\r\n如何转化\r\n\r\n\\((l_1 \\vee \\cdots \\vee l_{a}) \\wedge\r\n\\cdots l_1 \\vee \\cdots \\vee l_{b}) \\wedge \\cdots\\)\r\n\r\n\r\n\r\nHorn子句\r\n\r\n最多只有一个正文字\r\n\r\n\r\n知识表示\r\n\r\n\r\n情景演算, 情景, 流, 前提条件公理 (可能性公理), 效应公理等概念\r\n(背)\r\n本体论, 类别, 对象, 举例说明 (背)\r\n\r\n\r\n\r\n讨论的是 如何表示世界的事实,\r\n着重于在不同领域都会出现的通用概念, 如动作, 时间, 物理对象, 信念,\r\n表示这样的抽象概念是 本体论工程(en?)\r\n\r\n\r\n把世界上的所有事物组织到一个有层次的分类中。着重于不同领域中都会出现的通用概念——事件，时间，物理对象和信念等.\r\n本体论工程就是表示这些抽象概念。\r\n\r\n本体论工程(Ontology Engineer)\r\n\r\n主要着重于在不同领域都会出现的通用概念，包括表示动作, 时间, 物理对象,\r\n信念等抽象概念称为 本体论工程\r\n可以留下一些占位符, 使任何领域的知识都能填入\r\n概念的通用框架称为 上层本体\r\n可以用树型结构表示, 弧下面的概念是上面概念的一个特殊化\r\n\r\n\r\n专用本体和通用本体的区别\r\n\r\n通用本体应该或多或少应用于专用领域（附加必要的领域特定公理)\r\n在任何足够苛刻的域，不同领域的知识必须统一起来，因为推理和问题求解可能会同时涉及多个领域\r\n\r\n\r\n类别和对象\r\n将对象组织成类别是知识表示中的重要部分。虽然世界上的相互关系发生在对象层次上，但是多数推理发生在类别层次上,\r\n类别和对象是认知世界的基础\r\n从感知输入推断某些对象的存在，从对象的可感知属性推断其类别归属，然后用这些类别信息对这些对象做出预测。\r\n\r\n\r\n类别\r\n\r\n\r\n类别, 子类, 对象和集合论\r\n\r\n对象组织成类别\r\n类别可以作为另一个类别的对象, 称为子类\r\n类别可以通过继承来简化和组织知识库\r\n子类关系将类别用 分类法 (分类层次) 组织起来\r\n\r\n\r\n\r\n对象, 类别, 属性\r\n\r\n对象是类别的成员\r\n类别是另一个类别的子类\r\n一个类别的所用成员拥有某种属性\r\n类别的成员可以通过某种属性来识别\r\n一个类别作为整体拥有某种属性\r\n\r\n\r\n\r\n不相交\r\n\r\n没有公共成员\r\n\r\n\r\n\r\n完全分解\r\n\r\n并集为全集\r\n\r\n\r\n\r\n划分\r\n\r\n互不相交且并集为全集\r\n一个不相交的完全分解称为划分\r\n\r\n\r\n\r\n物质成分\r\n\r\n某个对象是另一个对象的一部分\r\n\r\n\r\n\r\n部分划分\r\n\r\n\r\n堆\r\n\r\n有确定的部分却没有特定结构的复合对象\r\n\r\n\r\n\r\n逻辑最小化\r\n\\(\\forall y (\\forall x \\in s \\Rightarrow\r\nPartOf(x,y) \\Rightarrow PartOf(BunchOf(s), y))\\)\r\n\r\n\r\n事物(Stuff)和物体(Thing)的区别\r\n事物由大量的原始对象组成, 并且没有明显的个性化, 例子: 黄油,\r\n黄油的任何一部分仍是黄油, 除非分解成非常小的部分\r\n物体, 例子: 小狗, 小狗的任何一部分不是小狗\r\n\r\n动作, 情景, 事件, 流\r\n\r\n动作\r\n\r\n对动作结果的推理是基于知识的Agent运作的中心问题\r\n\r\n\r\n\r\n情景\r\n\r\n实施动作产生的状态\r\n指一些逻辑项，由初始情景（常称为\\(𝑺_𝟎\\)）和所有在某个情景上应用一个动作后生成的情景组成\r\n\r\n避免公理的多个副本的明显方法就是简单地在时间轴上进行量化\r\n\r\n\r\n情景演算\r\n\r\n将对时刻的讨论转换为对情景的讨论\r\n是一种用一阶逻辑，将线性时间的概念用分支情景的概念替换的表达方法\r\n\r\n\r\n\r\n\r\n情景演算\r\n\r\n\r\n流\r\n\r\n流（fluent）指的是使情景从一个变换到下一个的函数和谓词\r\n流是函数和谓词，强调情景的变换。情景是流的最后一个参数\r\n\r\n\r\n\r\n可能性公理 (前提条件公理 Possibility)\r\n\r\n表述动作的前提, 说明什么时候可以执行该动作\r\n可能性公理陈述了一个Agent能够在相邻位置间移动，能够在当前位置抓住一块金子，也能够放开它持有的一些金子\r\n\r\n\r\n\r\n效应公理 (effect)\r\n\r\n表述某个可能的动作被执行后会发生什么\r\n如果一个动作是可能的，那么在执行此动作而产生的情景中某些属性（流）会成立\r\n说明了什么会被改变, 却没说什么东西不变\r\n\r\n\r\n\r\n\r\n公理\r\n\r\n\r\n框架公理\r\n\r\n需要明确说明哪些一直保持不变\r\n\r\n\r\n概率推理\r\n\r\n贝叶斯网络的定义, 语义\r\n给定贝叶斯网络, 写出相应的联合概率分布\r\n针对书中的盗贼警报任务, 理解贝叶斯网络的精确推理,\r\n并能够在给定证据的情况下进行推理\r\n\r\n贝叶斯网络的定义和语义\r\n\r\n贝叶斯网络的定义\r\n\r\n有向无环图\r\n每个节点都标注了定量概率信息\r\n包含随机变量集组成的网络节点\r\n包含连接节点的有向边集合\r\n每个节点都有一个条件概率分布 \\(P(X_i |\r\nParent(X_i))\\), 用来量化父节点对该节点的影响\r\n\r\n\r\n独立性, 条件独立性, 不确定域中的知识表示\r\n\r\n贝叶斯网络的语义\r\n\r\n将贝叶斯网络视为对联合概率分布的表示。用于构造网络\r\n将其视为对条件依赖性语句集合的编码。用于设计推理过程.\r\n(条件独立)\r\n\r\n\r\n\\[\r\nP(x_1, \\cdots, x_n) = \\prod_{i=1}^n P(x_i | parents(X_i))\r\n\\]\r\n\r\n例子\r\n计算报警器响了，但没有盗贼闯入，也没有发生地震，同时John和Marry都给你打电话的概率。\r\n\r\n\r\n一个典型的贝叶斯网络，显示了其拓扑结构和条件概率表（CPT）。在CPT中，字母B、E、A、J、M分别表示Burglary（盗贼）、Earthquake（地震）、Alarm（警报）、JohnCalls（John打电话）、MarryCalls（Marry打电话\r\n\r\n\\[\r\n\\begin{align}\r\np(a,\\neg b, \\neg e, j ,m) &amp;= p(a | \\neg b, \\neg e)p(\\neg b)p(\\neg\r\ne)p(j | a)p(m | a) \\\\\r\n&amp;= 0.001 \\times 0.999 \\times 0.998 \\times 0.9 \\times 0.7\r\n\\end{align}\r\n\\]\r\n\r\n\r\n条件独立关系\r\n\r\n给定父节点，一个节点与它的非后代节点是条件独立的\r\n给定一个节点的父节点、子节点、以及子节点的父节点。也就是说，给定它的马尔可夫覆盖（Markov\r\nblanket），则这个节点和其它所有节点都是条件独立的\r\n\r\n\r\n\r\n减少了所需定义的概率数目\r\n\r\n\r\n精确推理\r\n在给定某个已观察事件，也就是一组证据变量的某个赋值后，概率推理系统的基本任务都是要计算一组查询变量的后验概率分布。\r\n\r\n指定简单决策\r\n\r\n理解什么是偏好, 效用, 最大期望效用原则 (计算期望)\r\n理解决策网络, 尤其是网络中的结点类型\r\n给定网络, 计算不同动作的期望效用, 并选具有最大期望效用的动作\r\n\r\n\r\n效用\r\n\r\n将状态映射到实数的函数\r\n\r\n\r\n\r\n效用函数\r\n\r\n在世界状态之间的偏好采用效用函数表示。这个效用函数分配一个数值来表达对某个状态的愿望度。效用与动作的结果概率相结合，提供了每个动作的期望效用\r\n\r\n\r\n\r\n偏好\r\n\r\n某个状态的愿望度\r\n\r\n\r\n\r\n最大期望效用MEU\r\n\r\n表达指出理性Agent应该选择能最大化该Agent的期望效用的那个动作\r\n\r\n\r\n\r\n决策网络\r\n\r\n决策网络表示下述信息：Agent的当前状态、其可能动作、Agent的动作所产生的状态、以及状态的效用\r\n\r\n\r\n例题\r\nhttps://blog.csdn.net/weixin_44340586/article/details/109224994\r\n在不确定性环境下结合信度和愿望\r\n\r\n\r\nexpectation-1\r\n\r\n","tags":["ML","AI","Review"]},{"title":"【深度学习】Image Semantic Segmentation based on UNet","url":"/2022/08/21/ML/UNet/","content":"\"Semantic segmentation of images, use UNet model.\"\r\n\r\nAbstract\r\nIn this project, we realize an basic UNet model and UNet++ model,\r\nthen we apply them on image semantic segmentation. We show our basic\r\ntheory of UNet and an improvement of it, and we provide main code of\r\nthis program. Finally, we give the result of segmentation images,\r\nloss-curve and accuracy-curve on both training and validation set.\r\nThe copyright of this program is owned by our team mentioned on the\r\nend of this blog.\r\nUNet Structure\r\nThe paper published in\r\n2015 propose a noval network structure, whose shape is similar with the\r\ncaptal \"U\". The idea comes from FCNN. U-Net is one of the classes of\r\n\"Encoder-Decoder\" structure.\r\n\r\n\r\nU-Net Structure\r\n\r\nThe front half of the network is \"encoder\". The input image passes\r\ncovolutional kernel, and then passes the pooling layer (or other\r\ndimension-decreasing layer). The opposite of that is the back part of\r\nUNet, the \"decoder\". The input of decoder is a sequence of feature maps\r\nwith highly contracted pixels. The output of the decoder (or the whole\r\nnetwork) is an image with the same shape of input image, where each\r\npixel has its own class.\r\nIn this project, we decrease the number of convolutional layers so\r\nthat there are only two convolutional layers in each convolutional\r\nkernel as the dataset includes images with shape \\(128\\times 256\\).\r\nOperator Definitions\r\nConvolutional Kernel:\r\nWe define the basic convolutional kernel as follow:\r\nself.layer = nn.Sequential(    # in_channel, out_channel, kernel_size, stride, padding    # batch size * channel * height * weight    nn.Conv2d(C_in, C_out, kernel_size=(3, 3), stride=(1, 1), padding=1),  # 64 64 128 256    nn.BatchNorm2d(C_out),    nn.Dropout(0.2),    nn.LeakyReLU(),    nn.Conv2d(C_out, C_out, kernel_size=(3, 3), stride=(1, 1), padding=1),  # 64 64 128 256    nn.BatchNorm2d(C_out),    nn.Dropout(0.5),    nn.LeakyReLU(),\r\nIt includes two convolution operations.\r\nDown Sampling Kernel:\r\nAs for downsampling kernel, we replace conditional pooling layer to\r\nconvolutional layer with stride equaling to 2, which means the shape\r\nwill be shrunk to \\(\\frac{1}{2}\\) while\r\nremaining the same channels.\r\nself.Down = nn.Sequential(    nn.Conv2d(C, C, kernel_size=(3, 3), stride=(2, 2), padding=1),  # 64 64 64 128    nn.LeakyReLU()        )\r\nUp Sampling Kernel:\r\nThe basic structure of up-sampling contains only one convolutional\r\nlayer with \\(1\\times 1\\) convolutional\r\nkernel size and half out-channel. The feature map should pass an\r\ninterpolation layer before getting into the convolutional layer.\r\ndef __init__(self, C):    super(UpSampling, self).__init__()    # out-channel = 1/2 in-channel    self.Up = nn.Conv2d(C, C // 2, kernel_size=(1, 1), stride=(1, 1))    def forward(self, x, r):    # neighbor interpolation    up = F.interpolate(x, scale_factor=2, mode=&quot;nearest&quot;)    x = self.Up(up)    # concatenate the feature map in encoder and     # the feature map in corrsponding decoder layer, in channel dimension    res = torch.cat((x, r), 1)    return res\r\nThe interpolation mode we choose is \"nearest\". The function\r\ntorch.cat(dim=1) is used to concatenate two feature maps in\r\nchannel dimension.\r\nNetwork Definition\r\nBased on the operators defined above, we link these blocks together\r\nlike UNet structure.\r\ndef __init__(self):    super(UNet, self).__init__()    # down sampling    self.C1 = Conv(3, 64)    self.D1 = DownSampling(64)    self.C2 = Conv(64, 128)    self.D2 = DownSampling(128)    self.C3 = Conv(128, 256)    self.D3 = DownSampling(256)    self.C4 = Conv(256, 512)    self.D4 = DownSampling(512)    self.C5 = Conv(512, 1024)    # up sampling    self.U1 = UpSampling(1024)    self.C6 = Conv(1024, 512)    self.U2 = UpSampling(512)    self.C7 = Conv(512, 256)    self.U3 = UpSampling(256)    self.C8 = Conv(256, 128)    self.U4 = UpSampling(128)    self.C9 = Conv(128, 64)    self.C10 = torch.nn.Conv2d(64, 3, kernel_size=(3, 3), stride=(1, 1), padding=1)    self.pred = torch.nn.Conv2d(3, 34, kernel_size=(1, 1), stride=(1, 1))    self.Th = torch.nn.Sigmoid()\r\nLike U-Net mentioned in that paper, we designed 4 layer deep\r\nnetwork.\r\ndef forward(self, x):        # part 1: down sampling, decreasing dimension        R1 = self.C1(x)        R2 = self.C2(self.D1(R1))        R3 = self.C3(self.D2(R2))        R4 = self.C4(self.D3(R3))        Y1 = self.C5(self.D4(R4))        # part 2: up sampling, connect priori knowledge        O1 = self.C6(self.U1(Y1, R4))        O2 = self.C7(self.U2(O1, R3))        O3 = self.C8(self.U3(O2, R2))        O4 = self.C9(self.U4(O3, R1))        # part 3: active function        return self.Th(self.pred(self.C10(O4)))\r\nAs you can see, the difference between U-Net and other networks\r\nbefore U-Net is that U-Net conbines the former information from encoder\r\nand current information from decoder.\r\nCode\r\nDuring the training process, we want to keep some information of loss\r\nvalues and accuracy values on training set and validation set so that we\r\ncan analyze the variance.\r\nIn the function named train(), we take\r\noptimizer and loss as two parameters used in\r\ntraining process. The outputs of this function are loss and accuracy on\r\nboth training set and validation set. If we get the data about training\r\nset and validation set, we can draw the curves. If both training and\r\nvalidation loss values decrease during training process, we can conclude\r\nthat our model converges and does not overfit on training set.\r\nThe training code is shown as follow:\r\nself.model.train()for batch in self.train_loader:    batch_num += 1    optimizer.zero_grad()    rgbs, segs = batch    s, _, m, n = segs.shape    segs = torch.reshape(segs, (s, m, n))    pred_segs = self.model(rgbs).to(self.device)    loss_val = loss(pred_segs, segs)    loss_val.backward()    optimizer.step()\r\nThe data collecting code can be written as follow:\r\nStatistic data of training set\r\nfor ... :    with torch.no_grad():        if batch_num % 5 == 0:            logging.info(f&quot;batch num &#123;batch_num&#125;, loss &#123;loss_val&#125;&quot;)        # delete or add comments when needed        train_loss += loss_val        # statistic valid classified samples        total_pix += s * m * n        idx = torch.argmax(pred_segs, dim=1)        train_valid_pix += torch.eq(idx, segs).sum().float().item()torch.cuda.empty_cache()epoch_acc = train_valid_pix / total_pixtrain_epoch_loss.append(train_loss / batch_num)train_epoch_acc.append(epoch_acc)\r\nStatistic data of validation set\r\nself.model.eval()with torch.no_grad():    for valid_batch in self.valid_loader:        valid_batch_num += 1        rgbs, segs = valid_batch        s, _, m, n = segs.shape        segs = torch.reshape(segs, (s, m, n))        pred_segs = self.model(rgbs).to(self.device)        loss_val = loss(pred_segs, segs)        valid_loss += loss_val        valid_total_pix += s * m * n        idx = torch.argmax(pred_segs, dim=1)        valid_valid_pix += torch.eq(idx, segs).sum().float().item()epoch_acc = valid_valid_pix / valid_total_pixvalid_epoch_loss.append(valid_loss / valid_batch_num)valid_epoch_acc.append(epoch_acc)\r\nThe point you should pay attention to is that you should use\r\nwith torch.no_grad() before you do some work that have no\r\nrelation with training process, otherwise your GPU memory will be full\r\nor even overflow.\r\nResult\r\nAfter a long time training, we get the satisfying result with U-Net\r\nmodel.\r\nFormer Model\r\nThe \"former model\" infers the U-Net model, and you will see we use\r\nother upgraded model named \"UNet++\" which will be introduced later.\r\nWe output the segmentation results and their uncertainties.\r\n\r\n\r\npicture 1 result-UNet\r\n\r\nModel Upgrade\r\nFor some reasons, we try another U-Net-like model, Nested UNet,\r\nnamely UNet++. It has a nested convolutional blocks like a pyramid and\r\nthere is a chain passing connectivity between each convolutional block\r\nevery layer.\r\n\r\n\r\nNeseted UNet\r\n\r\nThe black nodes are the same with U-Net model. The green nodes are\r\nwhat Nested UNet newly added. Both green and blue lines are skip\r\npathways that pass connectivities from encoder to decoder.\r\nThe use of Nested UNet gives us a little improvement on final\r\nresults.\r\n\r\nAnalysis\r\nU-Net\r\nWe analyze the loss value and accuracy on both training and\r\nvalidation set:\r\n\r\n\r\nunet loss\r\n\r\nWe find that after 100 epochs, the model has not convergenced yet,\r\nbut the loss on validation decreases to the bottom.\r\n\r\n\r\nunet accuracy\r\n\r\nFrom the accuracy curves, we find that both training set and\r\nvalidation set have increasing accuracy, which means our model does not\r\noverfit.\r\nNested UNet\r\nMeanwhile, we analyze the loss and accuracy of Nested UNet model on\r\nboth training and validation set.\r\n\r\n\r\nnested loss\r\n\r\nWe find that Nested UNet has a faster convergency speed than UNet. It\r\nuses only about 60 epochs. But to our surprise, we find that Neseted\r\nUNet overfit after about only 20 epochs because the validation loss does\r\nnot decrease anymore.\r\n\r\n\r\nnested accuracy\r\n\r\nThe performance on validation accuracy stays the same with UNet\r\nmodel.\r\n","categories":["ML"],"tags":["CS","Deep Learning"]}]