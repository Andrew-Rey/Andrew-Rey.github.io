<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMake Tutorial</title>
    <url>/2022/08/10/CS/CMakeTutorial/</url>
    <content><![CDATA[<p>CMake version: 3.x</p>
<span id="more"></span>
<h1 id="command-line">Command Line</h1>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (configure step) create build dir, and generate build/Makefile -&gt; generate Makefile</span></span><br><span class="line">cmake -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># (build step) invoke building system and build the project in different OS -&gt; generate executable file</span></span><br><span class="line">cmake --build build -j4</span><br><span class="line"></span><br><span class="line"><span class="comment"># invoke building system to execute target &quot;install&quot;</span></span><br><span class="line">cmake --build build --<span class="keyword">target</span> <span class="keyword">install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define configure variables, only use in configure step</span></span><br><span class="line"><span class="comment"># use -D</span></span><br><span class="line"><span class="comment"># set build type in configure step, the value will remain when invoked the second time unless delete build dir</span></span><br><span class="line">cmake -B build -DCMAKE_BUILD_TYPE=Release</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify generator (generator: generate build system build rule from CMakeLists.txt)</span></span><br><span class="line"><span class="comment"># use -G</span></span><br><span class="line"><span class="comment"># generator Ninja, faster than Unix Makefile, generate *.ninja</span></span><br><span class="line">cmake -B build -G Ninja</span><br></pre></td></tr></table></figure>
<h1 id="cmakelists.txt">CMakeLists.txt</h1>
<p><strong>add source file</strong></p>
<p>(1). single file: main.cpp</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC main.cpp)</span><br></pre></td></tr></table></figure>
<p>(2). multiple files: main.cpp | other.cpp | other.h</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC main.cpp other.cpp)</span><br></pre></td></tr></table></figure>
<p>or <strong>set</strong> a new variable</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">set</span>(sources main.cpp other.cpp other.h)  <span class="comment"># other.h can delete</span></span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>or use <strong>GLOB</strong> to search all files in current dir</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)  <span class="comment"># add CONFIGURE_DEPENDS to detect any change when next build</span></span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>when we have a dir structure:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mylib</span><br><span class="line">  +----*.cpp</span><br><span class="line">  +----*.h</span><br><span class="line">*.cpp</span><br><span class="line">*.h</span><br></pre></td></tr></table></figure>
<p>no need to write all files:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add all file in current dir and mylib dir</span></span><br><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(. sources)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(mylib sources)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>or use <strong>GLOB_RECURSE</strong> to find all files recursely:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>ERROR</strong>: use GLOB_RECURSE will include *.cpp files in
build dir.</p>
<p><strong>solution</strong>: Add all source files in a dir named
src</p>
<h2 id="configure-variables">Configure variables</h2>
<p><strong>CMAKE_BUILD_TYPE</strong>: type of build,
<strong>Release</strong>, <strong>Debug</strong>,
<strong>MinSizeRel</strong> and <strong>RelWithDebInfo</strong>,
defualt: none (debug).</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br></pre></td></tr></table></figure>
<p>set default build type as Release to reach high performance: in the
first three lines:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Specify version of cmake</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set c++ standard</span></span><br><span class="line"><span class="comment"># don&#x27;t modify CMAKE_CXX_FLAGS to add -std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use the needed CXX standard defined.</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)  <span class="comment"># OFF default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prevent features GCC only</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set project info</span></span><br><span class="line"><span class="keyword">project</span>(project_name LANGUAGES language_list(such as C CXX ASM...))</span><br></pre></td></tr></table></figure>
<h2 id="linkable-library">Linkable library</h2>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main mian.cpp mylib.cpp)</span><br></pre></td></tr></table></figure>
<p>or generate a static library</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib STATIC mylib.cpp)  <span class="comment"># create libmylib.a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>
<p>or generate dynamic lib</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>
<p>or use object lib, no *.a file, let CMake remember which objects
files are created</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib OBJECT mylib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>
<p>静态库问题: GCC会自行剔除没有引用符号的对象, 此时使用对象库避免,
从而不会自动剔除没引用到的对象文件, 绕开编译器不统一问题.
动态库也可以避免剔除没引用的对象文件, 但引入了运行时链接的麻烦.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># no specify variable in add_library()</span></span><br><span class="line"><span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">ON</span>)  <span class="comment"># default OFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(mylib mylib.cpp)</span><br></pre></td></tr></table></figure>
<p><strong>HINT</strong> 静态库常常被认为直接链接到可执行文件上.
因此在动态库中不要链接静态库. 很呆. 地址会变.
当然<strong>解决方法</strong>是: 要么转化为对象库,
要么让静态库变成地址无关的代码PIC</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set global property</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>
<p>or set local property</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set local property</span></span><br><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> otherlib PROPERTY POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"></span><br><span class="line">add_execuable(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>
<h2 id="attributes-of-objects">Attributes of objects</h2>
<p>设置单属性: <code>set_property(TARGET ... PROPERTY ...)</code>;</p>
<p>设置多属性:
<code>set_target_properties(file_name PROPERTIES properties_list)</code></p>
<p><strong>HINT</strong>:
以上命令在<code>add_executable</code>后有效.</p>
<p>设置全局属性 (改变属性的默认值): <code>set(CMAKE_XXX)</code>,
在<code>add_executable</code>前设置.</p>
<blockquote>
<p>如果需要在Windows下面使用动态库 (Windows对动态链接不友好),
则需要在定义和声明添加: <strong>Deffinition:</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">__declspec(dllexport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayy_hello</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<strong>Declaration:</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">__declspec(dllimport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure> 然后CMakeLists.txt这样写:
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># In Main dir</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib)  <span class="comment"># add sub module</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In sub module dir</span></span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp mylib.h)</span><br></pre></td></tr></table></figure> 然后Windows极有可能会报错: 运行时找不到dll;
原因是dll和exe不在同一目录 (Windows只会查找exe所在目录和PATH). -
把dll添加到PATH环境变量 - 或者dll和dll其他的所有依赖dll,
全部拷贝到exe同一目录</p>
<p>这是因为CMake把main放在build下, 而mylib放在build/mylib/mylib.dll</p>
</blockquote>
<p>因此重定向输出路径, 改变mylib属性, 让.dll文件输出到
<strong>PROJECT_BINARY_DIR</strong> 里面. <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_(DEBUG | RELEASE | NONE) | ARCHIVE_OUTPUT_DIRECTORY | LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="externel-library">Externel library</h2>
<p>In Linux: feel free to link externel libraries. (/usr/lib/...) But
Windows can't. Linux can also include head file directly
(/usr/include/...).</p>
<p><strong>HINT:</strong> CMake 的分隔符永远是 "/", 即使是Windows,
CMake会自动转化.</p>
<p>More general method: <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(package_name REQUIRED)</span><br></pre></td></tr></table></figure></p>
<p>没听懂, 以后补, 以后也不想补.</p>
<h2 id="variables-and-outputs">Variables and Outputs</h2>
<p>output some log infomation when running <code>cmake -B build</code>,
used for debugging. <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;log info&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;status info&quot;</span>)  <span class="comment"># -- prefix</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;warning info&quot;</span>)  <span class="comment"># yellow</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(SEND_ERROR <span class="string">&quot;error info&quot;</span>)  <span class="comment"># send error log but continue to run</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;error info&quot;</span>)  <span class="comment"># print error and stop running</span></span><br></pre></td></tr></table></figure>
<h2 id="variable-and-cache">Variable and Cache</h2>
<p>重复执行<code>cmake -B build</code>: 第一次较慢,
将环境的检测存入缓存, 第二次以及以后直接查看缓存内容.
因此某些错误可以通过删除 <strong>./build/CMakeCache.txt</strong>解决.
当然也可以删了整个build文件夹重新编译, 慢一点而已.</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>Algorithm-FFT</title>
    <url>/2022/04/06/Algorithm/Algorithm-FFT/</url>
    <content><![CDATA[<p>"FFT是我见过最美的算法."</p>
<p>"说的好像你见过很多算法似的."</p>
<span id="more"></span>
<h1 id="多项式乘积问题">多项式乘积问题</h1>
<p>首先来思考这样的一个问题:</p>
<hr />
<h3 id="question-1">Question 1</h3>
<p>你有两个多项式函数:</p>
<p><span class="math display">\[p(x)=2x^3+x+1\]</span></p>
<p><span class="math display">\[q(x)=x^2+4x+5\]</span></p>
<p>应该如何计算它们的乘积?</p>
<hr />
<p>当然, 我不是说要用笔算的方式, 而是用<strong>计算机</strong>.
显然这个问题我们在<a
href="https://space.bilibili.com/254463269/?spm_id_from=333.999.0.0">小学二年级</a>就写过的,
当初正在学习"数据结构"这门课, 如果没记错, 应该是用链表实现的.</p>
<p>但是, 就算是用链表实现, 那不也是和手算一样的原理吗?</p>
<ul>
<li>将二者相乘</li>
<li>分配律</li>
<li>合并同类项</li>
</ul>
<p>例如上面那个例子:</p>
<hr />
<h3 id="solution-1">solution 1</h3>
<p><span class="math display">\[
\begin{align*}
    r(x) &amp;= (2x^3+x+1)(x^2+4x+5) \\
    &amp;= 2x^5+8x^4+10x^3+x^3+4x^2+5x+x^2+4x+5 \\
    &amp;= 2x^5+8x^4+11x^3+5x^2+5x+5
\end{align*}
\]</span> ----</p>
<p>(<strong>???是什么动力让我深夜在这里口算多项式乘法???</strong>)</p>
<p>显然, 如果一个 n 次多项式乘上一个 m 次多项式, 在合并同类项前应该有
<span class="math inline">\(n\times m\)</span> 次多项式, 这谁顶得住?
对于正常人类而言显然顶不住, 对于计算机而言, 时间复杂度是<span
class="math inline">\(O(n^2)\)</span>, 也是算比较大的开销了吧.</p>
<p>咋办?</p>
<h1 id="点表示法">点表示法</h1>
<h2 id="开始">开始</h2>
<p>有谁规定, 我多项式一定是用系数表示的?</p>
<p>好家伙, 你这样说我就摸不着头脑了,
难道除了系数表示还有其他表示方法吗?</p>
<p>首先, 多项式集合其实是构成了一个<strong>线性空间</strong>, 也就是说,
任意两个多项式进行线性运算 (加法和数乘) 后, 结果仍然是多项式. 事实上</p>
<p><span class="math display">\[
{1, x, x^2, \dots, x^n, \dots}
\]</span></p>
<p>构成了该空间的一组基, 将函数展开成 Taylor 级数便用了这组基作为基底,
基前面的系数也就是<strong>坐标</strong>.</p>
<p>其次, 对于一个 n 次多项式而言, 只要我们确定了它的坐标,
就能唯一确定这个多项式. <strong>现在的问题是不知道坐标,
如何确定多项式.</strong> 这里的巧妙之处就在于, 多项式函数是一个映射,
对于一个特定的 x, 总是能给出唯一一个值与之对应, 这不就是一个方程吗?</p>
<p>我给你一个 x, 你输出一个值, 同时由于多项式系数全部未知,
这就是一个关于 <span class="math inline">\(n+1\)</span> 个系数的方程</p>
<p>显然, 我需要 <span class="math inline">\(n+1\)</span>
个不同的点来唯一确定我的系数. 这就是所谓的点表示法. 这样一来, 我们将这
<span class="math inline">\(n+1\)</span> 个方程写成矩阵形式:</p>
<p><span class="math display">\[
\begin{bmatrix}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{bmatrix}
=
\begin{bmatrix}
1\quad &amp; x_0\quad &amp; \dots\quad &amp; x_0^n \\
1\quad &amp; x_1\quad &amp; \dots\quad &amp; x_1^n \\
\vdots\quad &amp; \vdots\quad &amp; \quad &amp; \vdots \\
1\quad &amp; x_n\quad &amp; \dots\quad &amp; x_n^n
\end{bmatrix}
\begin{bmatrix}
c_0 \\
c_1 \\
\vdots \\
c_n
\end{bmatrix}
\]</span></p>
<p>看到这里我终于理解了为什么在学高等代数时要突然讲一个<strong>范德蒙德(Vandermonde)行列式</strong>,
也就是这里的</p>
<p><span class="math display">\[
\left[
\begin{aligned}
1\quad &amp; x_0\quad &amp; \dots\quad &amp; x_0^n \\
1\quad &amp; x_1\quad &amp; \dots\quad &amp; x_1^n \\
\vdots\quad &amp; \vdots\quad &amp; \quad &amp; \vdots \\
1\quad &amp; x_n\quad &amp; \dots\quad &amp; x_n^n
\end{aligned}
\right]
\]</span></p>
<p>将上述矩阵定义为我们最喜欢的字母<span
class="math inline">\(A\)</span>.</p>
<p>好, 既然这东西是范德蒙德行列式, 那我们可以知道它行列式<span
class="math inline">\(|A|=\prod_{0\leq j&lt; i\leq
n}(x_i-x_j)\)</span>不为 0, 也就是说, 这个矩阵是可逆的, 也就是当我们取
<span class="math inline">\(n+1\)</span> 个不同点时,
确实是可以使方程组有唯一解, 也就是 <strong><span
class="math inline">\(n+1\)</span> 个点可以唯一表示一个 n
次多项式.</strong></p>
<h2 id="乘法">乘法</h2>
<p><strong>问题来了, 如何做乘法?</strong></p>
<p>我们有 n 次多项式和 m 次多项式做乘法, 得到的是一个 <span
class="math inline">\(n+m\)</span> 次多项式, 那么我们只要找到 <span
class="math inline">\(n+m+1\)</span> 个点即可, 也就是只要在 n 次多项式和
m 次多项式中分别找 <span class="math inline">\(n + m + 1\)</span> 个点,
<strong>这些点的横坐标 x 相等</strong>, 再将对应的函数值相乘即可.</p>
<h2 id="进一步">进一步</h2>
<p>现在, 我们知道了如何用点表示多项式, 以及如何用点表示进行乘法运算.
但是仔细一想, 这种方法需要求解线性方程组, 这里的计算复杂度并不低.
也就是从系数表示法到点表示法的转化过程带来的计算复杂度还是很高的.</p>
<p>有什么方法可以进行简化吗?</p>
<p>先等一等, 我们先来梳理我们用点表示求多项式乘法的思路:</p>
<hr />
<h3 id="mainidea">MainIdea</h3>
<ul>
<li>将 n 次多项式和 m 次多项式分别从系数表示转化为点表示</li>
<li>对应点相乘</li>
<li>将得到的 <span class="math inline">\(n+m+1\)</span>
个点表示的多项式转化为系数表示</li>
</ul>
<hr />
<h2 id="奇偶">奇偶</h2>
<p>先来考虑简单的情况:</p>
<hr />
<h3 id="question-2">Question 2</h3>
<p>多项式</p>
<p>$ p(x) = x^2 $</p>
<p>和多项式</p>
<p>$ q(x)=x^3 $</p>
<p>用点表示法相乘</p>
<hr />
<p>那我们当然是按部就班地进行乘法啦~ - 由于结果是 5 次多项式,
因此对<span class="math inline">\(p(x)\)</span>取 5 个点, 对<span
class="math inline">\(q(x)\)</span>取 5 个点.</p>
<p><strong>取点</strong>, 说得轻巧, 做起来倒是挺犹豫的.
取什么样的点能满足要求呢? 或者<del>得寸进尺地</del>说,
什么样的点能让效率更高呢? <strong>注意到二次函数是对称的</strong>,
那我们是不是只要取正的 2 个点, 就能知道负的 2 个点, 另外加一个原点?</p>
<p>确实如此.</p>
<p>那三次多项式呢? 照理来说,
我们同样也是只要取一半的点就能知道另一半点的值(这里的"一半"针对正负而言),
只不过要在函数值上添加负号, 何必呢? 还不如干脆 <strong>提出一个
x</strong>, 然后不也变成了二次函数?</p>
<p>事实上, 一般而言, 我们要用点表示法表示多项式, 可以用如下方法:</p>
<hr />
<h3 id="method1">Method1</h3>
<p><span class="math display">\[
p(x)=\sum_{i=1}^n c_ix^i=P_e(x)+P_o(x)=P_{e1}(x)+xP_{e2}(x)
\]</span> 其中, <span
class="math inline">\(P_{ei}(x)\)</span>表示只含偶次的多项式函数, <span
class="math inline">\(P_o(x)\)</span>表示只含奇次的多项式.</p>
<hr />
<p>这样, 我们只要在非负轴上取值就可以确定整个多项式, 取点的个数是
<strong>原来的一半</strong>.</p>
<p>甚至, 这里形成了一个 <strong>递归</strong> 算法: 分解后的<span
class="math inline">\(P_{ei}(x)\)</span>不也是一个关于 x 的多项式吗?!
那我继续啊, 把<span class="math inline">\(P_{ei}(x)\)</span>继续分解啊,
<strong>大事化小, 小事化了.</strong></p>
<p><strong>等等!</strong></p>
<p>我们的<span class="math inline">\(P_{ei}(x)\)</span>其实是<span
class="math inline">\(P_{ei}(x^2)\)</span>, 这里每个<span
class="math inline">\(x^2\)</span>都是<strong>非负的</strong>啊.
未来我们只能在非负轴取值了, 也就是说, 分解为偶次多项式后,
<strong>递归停止了</strong>.</p>
<p>完蛋.</p>
<h1 id="复数域分解">复数域分解</h1>
<p>"山重水复疑无路, 柳暗花明又一村"</p>
<p>看到标题就已经知道要怎么做了. 既然在实数域上无法继续分解<span
class="math inline">\(P_{ei}(x^2)\)</span>,
那为何不去<strong>复数域</strong>呢?</p>
<p>在复数域上我们可以快乐地进行递归.</p>
<p>如何个快乐法呢? 我们来细品:</p>
<hr />
<h3 id="偶次多项式在复平面上的根">偶次多项式在复平面上的根</h3>
<p>为什么突然变成了 <strong>求根</strong>?</p>
<p>从第二节中"奇偶", 我们可以选取对称的点,
来减少选取点的个数(即原来的一半). 接着我们把任意 n
次多项式分解成两个偶次多项式, 偶次多项式的好处在于容易选取对称的点.
但是由于在实数范围内, 在对偶次多项式进行递归时会发生中断,
于是我们扩展至复数域讨论分解.</p>
<p><strong>方便起见</strong>: 对于<span
class="math inline">\(x^0\)</span>, 我们取<span
class="math inline">\(x=1\)</span>作为特征点, 对于<span
class="math inline">\(x^2\)</span>, 我们取<span
class="math inline">\(x=1, x=-1, x=0\)</span>作为三个特征点, 那对于<span
class="math inline">\(x^4\)</span>, 我们应该怎样取点, 抛开<span
class="math inline">\(x=0\)</span>不谈, 令<span
class="math inline">\(x^4=1\)</span>, 由 <strong>代数基本定理</strong>,
该方程在复数域上有 4 个 <strong>根</strong>,
对于其它偶次多项式我们以此类推.</p>
<p>就这样, 我们找到了一个简单的方法寻找所有需要的点, 进行递归.</p>
<h3 id="单位根">单位根</h3>
<p>写到这里, 我也感觉有点吃力, 关键是为什么一定就取了令<span
class="math inline">\(x^{2k}=1\)</span>呢?</p>
<p>虽然但是, 确实是所谓的"<strong>方便起见</strong>", 这是因为, 取了"1",
我们可以在复平面上的单位圆上讨论这个问题.</p>
<p>在<a
href="https://space.bilibili.com/254463269/?spm_id_from=333.999.0.0">小学二年级</a>我们就知道,
<span class="math inline">\(x^{n}=1\)</span>的根可以用我们熟悉的<span
class="math inline">\(\omega\)</span>的幂来表示, 即 <span
class="math display">\[
\omega = e^{\frac{2k\pi}{n}i}\qquad(k=0,1,\dots,n-1)
\]</span> 这些<span class="math inline">\(n\)</span>个点在复平面单位圆上
<strong>对称分布</strong>. 每递归一次, 单位根的数量减少一半,
但保持对称性不变.</p>
<p>确实方便.</p>
<hr />
<h1 id="快速傅里叶变换fft">快速傅里叶变换(FFT)</h1>
<p>终于能正式地介绍世界上最美丽的算法了:
<strong>快速傅里叶变换(FFT)</strong>.
FFT解决的是多项式从系数表示到点表示的过程中, 计算复杂度的问题.</p>
<h2 id="框架">框架</h2>
<p><strong>分解:</strong></p>
<p><span class="math display">\[
p(x)=\sum_{k=0}^nc_kx^k=P_{e1}(x^2)+xP_{e2}(x^2):=[ \omega^0, \omega^1,
\dots, \omega^n]
\]</span></p>
<p><strong>递归:</strong></p>
<p><span class="math display">\[
P\_{e1}(x^2) = P^{\prime}\_{e1}(x^4)+xP^{\prime}\_{e2}(x^4):=[\omega^0,
\omega^1, \dots, \omega^{n-1}]
\]</span></p>
<p><span class="math display">\[
P\_{e2}(x^2) = P^{\prime}\_{e1}(x^4)+xP^{\prime}\_{e2}(x^4):=[\omega^0,
\omega^1, \dots, \omega^{n-1}]
\]</span></p>
<p><strong>加和:</strong> <span class="math display">\[
P(\omega^j)=P\_{e1}(\omega^{j})+\omega^jP\_{e2}(\omega^j)
\]</span></p>
<p><span class="math display">\[
P(\omega^{j+n/2})=P\_{e1}(\omega^{j+n/2})+\omega^{j+n/2}P\_{e2}(\omega^{j+n/2})
\]</span></p>
<p><span class="math inline">\(j\in[0,1,\dots, n/2+1]\)</span></p>
<p><strong>返回</strong><span class="math inline">\(p(x)\)</span></p>
<p>时间复杂度为: <span class="math inline">\(O(nlog_2n)\)</span></p>
<h2 id="一些数学">一些数学</h2>
<hr />
<p><span class="math display">\[
\left[
\begin{aligned}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{aligned}\right]
=
\left[
\begin{aligned}
1\quad &amp; x_0\quad &amp; \dots\quad &amp; x_0^n \\
1\quad &amp; x_1\quad &amp; \dots\quad &amp; x_1^n \\
\vdots\quad &amp; \vdots\quad &amp; \quad &amp; \vdots \\
1\quad &amp; x_n\quad &amp; \dots\quad &amp; x_n^n
\end{aligned}
\right]
\left[
\begin{aligned}
c_0 \\
c_1 \\
\vdots \\
c_n
\end{aligned}\right]
\]</span></p>
<p>我们在复数域上考虑, 令 <span class="math display">\[
x_k=\omega^k,\quad where\ \ \omega=e^{\frac{2k\pi}{n}}
\]</span> (这是因为, 我们希望多项式在复数域上考虑时,
我们可以在单位圆周上讨论. 其中<span
class="math inline">\(x_k\)</span>表示我们取的第 k 个点, 刚好与 <span
class="math inline">\(\omega^k\)</span>是对应的.)</p>
<p>则线性方程组可以化为:</p>
<p><span class="math display">\[
\left[
\begin{aligned}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{aligned}\right]
=
\left[
\begin{aligned}[c]
1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;
\dots\quad &amp; 1 \\
1\quad      &amp; \omega\quad   &amp; \omega^2\quad          &amp;
\dots\quad &amp; \omega^n \\
1\quad      &amp; \omega^2\quad &amp; \omega^4\quad          &amp;
\dots\quad &amp; \omega^{2n} \\
\vdots\quad &amp; \vdots\quad   &amp;
\vdots\quad       &amp;            &amp; \vdots \\
1\quad      &amp; \omega^n\quad &amp; \omega^{2n}\quad  &amp; \dots\quad
&amp; \omega^{n\times n}
\end{aligned}
\right]
\left[
\begin{aligned}
c_0 \\
c_1 \\
\vdots \\
c_n
\end{aligned}\right]
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\left[
\begin{aligned}[c]
1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;
\dots\quad &amp; 1 \\
1\quad      &amp; \omega\quad   &amp; \omega^2\quad          &amp;
\dots\quad &amp; \omega^n \\
1\quad      &amp; \omega^2\quad &amp; \omega^4\quad          &amp;
\dots\quad &amp; \omega^{2n} \\
\vdots\quad &amp; \vdots\quad   &amp;
\vdots\quad       &amp;            &amp; \vdots \\
1\quad      &amp; \omega^n\quad &amp; \omega^{2n}\quad  &amp; \dots\quad
&amp; \omega^{n\times n}
\end{aligned}
\right]
\]</span> 称为<strong>离散傅里叶变换矩阵(DFT)</strong>显然该矩阵是
<strong>对称的</strong> 且 <strong>可逆</strong>, 其逆矩阵为: <span
class="math display">\[
\frac{1}{n}
\left[
\begin{aligned}[c]
1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;
\dots\quad &amp; 1 \\
1\quad      &amp; \omega^{-1}\quad   &amp;
\omega^{-2}\quad          &amp; \dots\quad &amp; \omega^{-n} \\
1\quad      &amp; \omega^{-2}\quad &amp; \omega^{-4}\quad          &amp;
\dots\quad &amp; \omega^{-2n} \\
\vdots\quad &amp; \vdots\quad   &amp;
\vdots\quad       &amp;            &amp; \vdots \\
1\quad      &amp; \omega^{-n}\quad &amp; \omega^{-2n}\quad  &amp;
\dots\quad &amp; \omega^{-n\times n}
\end{aligned}
\right]   
\]</span></p>
<p>并且, 该逆矩阵看起来和原矩阵 <strong>一模一样!</strong> .</p>
<hr />
<h2 id="结束了">结束了?</h2>
<p>当我们乐呵呵地把FFT转化为代码时, 开心的分解多项式, 然后选点, 相乘,
<strong>等等!</strong> 你还没告诉我, 怎么从点表示转化回系数表示呢!</p>
<p>这就是FFT<strong>对称</strong>的魅力了. 由点求系数,
不过是矩阵求逆的过程:</p>
<p><span class="math display">\[
\left[
\begin{aligned}
c_0 \\
c_1 \\
\vdots \\
c_n
\end{aligned}\right]
=
\left[
\begin{aligned}[c]
1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;
\dots\quad &amp; 1 \\
1\quad      &amp; \omega\quad   &amp; \omega^2\quad          &amp;
\dots\quad &amp; \omega^n \\
1\quad      &amp; \omega^2\quad &amp; \omega^4\quad          &amp;
\dots\quad &amp; \omega^{2n} \\
\vdots\quad &amp; \vdots\quad   &amp;
\vdots\quad       &amp;            &amp; \vdots \\
1\quad      &amp; \omega^n\quad &amp; \omega^{2n}\quad  &amp; \dots\quad
&amp; \omega^{n\times n}
\end{aligned}
\right]^{-1}
\left[
\begin{aligned}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{aligned}\right] \\
=\frac{1}{n}
\left[
\begin{aligned}[c]
1\quad      &amp; 1\quad        &amp; 1\quad                 &amp;
\dots\quad &amp; 1 \\
1\quad      &amp; \omega^{-1}\quad   &amp;
\omega^{-2}\quad          &amp; \dots\quad &amp; \omega^{-n} \\
1\quad      &amp; \omega^{-2}\quad &amp; \omega^{-4}\quad          &amp;
\dots\quad &amp; \omega^{-2n} \\
\vdots\quad &amp; \vdots\quad   &amp;
\vdots\quad       &amp;            &amp; \vdots \\
1\quad      &amp; \omega^{-n}\quad &amp; \omega^{-2n}\quad  &amp;
\dots\quad &amp; \omega^{-n\times n}
\end{aligned}
\right]
\left[
\begin{aligned}
p_0 \\
p_1 \\
\vdots \\
p_n
\end{aligned}\right]
\]</span></p>
<p>显然, 由于DFT和DFT逆矩阵具有相似的形式,
我们完全可以用<strong>同一个函数</strong>完成快速傅里叶的正反变换!</p>
<h1 id="后记-对称-万变不离其宗">后记-"对称, 万变不离其宗"</h1>
<p>不会真有人会把这个没有图的文章看完吧?</p>
<p>相信我, 日后在这里补充图片的概率为 <span class="math display">\[
p=lim_{x\rightarrow\infty}xsin (1/x)
\]</span> (糟糕, 好像出简单了)</p>
<p>另外, 在递归的地方, 觉得并没有讲清楚具体的步骤, 但是思想到位了.
日后也不想改了. 可能以后补一补应用场景之类的, 至于代码, 看情况吧.</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>中间代码生成</title>
    <url>/2023/01/29/CS/Compiler-MeddleCodeGeneration-zh/</url>
    <content><![CDATA[<p>"书接上文"</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p>本章将介绍各类语句的翻译</p>
<ul>
<li>声明语句</li>
<li>赋值语句</li>
<li>控制语句</li>
<li>过程调用语句</li>
</ul>
<h2 id="声明语句的翻译">声明语句的翻译</h2>
<p>收集标识符的<strong>类型信息</strong>,
为每个标识符分配一个<strong>相对地址</strong></p>
<p><strong>类型表达式</strong></p>
<ul>
<li>基本类型是类型表达式</li>
<li>可以为类型表达式命名, 类型名是类型表达式</li>
<li>将类构造符 (type constructor) 作用于类型表达式可以构成新的类型表达式
<ul>
<li>数组构造符<code>array</code>: <img src="数组类型构造符.jpg"
alt="array数组构造符" /></li>
<li>指针表达式<code>pointer</code>: <code>pointer(T)</code>是类型表达式,
表示指向类型<code>T</code>的指针类型</li>
<li>笛卡尔乘积构造符<span class="math inline">\(\times\)</span>:
两个类型表达式通过<span
class="math inline">\(\times\)</span>符号运算后仍然是类型表达式</li>
<li>函数构造符<span class="math inline">\(\rightarrow\)</span>:
函数参数的类型表达式的笛卡尔乘积<span
class="math inline">\(\rightarrow\)</span>函数返回值的类型表达式</li>
<li>记录构造符<code>record</code>: <img src="记录构造符.jpg"
alt="record记录构造符" /></li>
</ul></li>
</ul>
<p><strong>局部变量的存储分配</strong></p>
<p>从类型表达式中可以知道 <strong>该类型在运行时刻所需要的存储单元数量
(类型的宽度 <em>width</em>)</strong> 在 <strong>编译时</strong>,
可以使用类型的宽度为每一个名字分配一个 <strong>相对地址</strong>
名字的类型和相对地址保存在相应的 <strong>符号表中</strong></p>
<p>变量声明语句的 SDT:</p>
<figure>
<img src="变量声明语句的SDT.jpg" alt="变量声明语句的SDT" />
<figcaption aria-hidden="true">变量声明语句的SDT</figcaption>
</figure>
<h3 id="例子-非数组局部变量声明">例子: 非数组局部变量声明</h3>
<p>考虑有输入: <code>real x; int i;</code></p>
<figure>
<img src="demo-1.jpg" alt="demo-1" />
<figcaption aria-hidden="true">demo-1</figcaption>
</figure>
<h3 id="例子-数组局部变量声明">例子: 数组局部变量声明</h3>
<p>考虑有输入: <code>int[2][3]</code></p>
<figure>
<img src="demo-2.jpg" alt="demo-2" />
<figcaption aria-hidden="true">demo-2</figcaption>
</figure>
<h2 id="简单赋值语句的翻译">简单赋值语句的翻译</h2>
<p>主要任务为 <strong>生成对表达式求值的三地址码</strong>,
赋值语句的基本文法为:</p>
<figure>
<img src="赋值语句文法.jpg" alt="赋值语句文法" />
<figcaption aria-hidden="true">赋值语句文法</figcaption>
</figure>
<p>对该文法定义语义规则生成对应的 SDT 如下:</p>
<figure>
<img src="赋值语句SDT.jpg" alt="赋值语句SDT" />
<figcaption aria-hidden="true">赋值语句SDT</figcaption>
</figure>
<p>由于这样的操作, 父结点需要赋值子结点的三地址码,
而子结点需要赋值其子结点的三地址码, 会造成消耗空间大的问题, 因此使用
<strong>增量翻译</strong>, 即修改<code>gen()</code>函数,
使得其在生成三地址码后将新的三地址</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分析</title>
    <url>/2023/01/03/CS/Compiler-SemanticAnalysis-zh/</url>
    <content><![CDATA[<p>"书接上文"</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<p><strong>语义翻译</strong>: 语义分析和中间代码生成一起实现.</p>
<p><strong>语法制导翻译</strong>: 在语法分析时实现语义翻译.
使用上下文无关文法(CFG)来引导对语言的翻译, 是一种面向文法的翻译技术.</p>
<h2 id="基本思想">基本思想</h2>
<p><strong>语义属性</strong>: 在 CFG 中为文法符号设置语义属性,
表示语法成分对应的语义信息.</p>
<p>如何计算:</p>
<ul>
<li>用文法符号所在的产生式相关联的<strong>语义规则</strong>计算</li>
</ul>
<p><strong>语法制导定义(SDD)</strong>:</p>
<ul>
<li>将<strong>每个文法符号</strong>和一个<strong>语义属性集合</strong>相关联</li>
<li>将<strong>每个产生式</strong>和<strong>一组语义规则</strong>相关联,
这些规则用于计算产生式中各个文法符号的属性值</li>
<li>注意: 同一个产生式出现相同符号时, 需要以下标区分,
因为有不同的语义含义</li>
<li>注意: 语义规则可以是一些 <strong>副作用</strong> 如打印等等</li>
</ul>
<p>例子:</p>
<table>
<thead>
<tr class="header">
<th>产生式</th>
<th>语义规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(D \rightarrow T\ L\)</span></td>
<td><span class="math inline">\(L.inh = T.type\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(T \rightarrow int\)</span></td>
<td><span class="math inline">\(T.type = int\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(T \rightarrow real\)</span></td>
<td><span class="math inline">\(T.type = real\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(L \rightarrow L_1, id\)</span></td>
<td><span class="math inline">\(L_1.inh = L.inh\)</span></td>
</tr>
</tbody>
</table>
<p><strong>语法制导翻译方案(SDT)</strong></p>
<ul>
<li>在产生式右部嵌入程序片段 (<strong>语义动作</strong>)</li>
</ul>
<p>例子:</p>
<table>
<tbody>
<tr class="odd">
<td><span class="math inline">\(D \rightarrow T\ \{L.inh = T.type\}\
L\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(T \rightarrow int\ \{T.type =
int\}\)</span></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(T \rightarrow real\ \{T.type =
int\}\)</span></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(L \rightarrow \{L_1.inh = L.inh\}\ L_1,
id\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>语义动作在产生式的位置决定了动作的执行时刻</strong>:
例如第一个产生式, 在分析出<span class="math inline">\(T\)</span>后,
可以根据语义动作, 将后面的<span
class="math inline">\(L\)</span>的语义属性赋值</p>
<h2 id="语法制导定义-sdd">语法制导定义 SDD</h2>
<p>分为 <strong>综合属性</strong> 和 <strong>继承属性</strong></p>
<h3 id="综合属性synthesized-attribute">综合属性(Synthesized
attribute)</h3>
<p>在分析树上的结点<span class="math inline">\(N\)</span>的
<strong>非终结符</strong> <span
class="math inline">\(A\)</span>的综合属性只能通过<span
class="math inline">\(N\)</span>的<strong>子节点或本身的属性值</strong>来定义.</p>
<figure>
<img src="综合属性.png" alt="综合属性例子" />
<figcaption aria-hidden="true">综合属性例子</figcaption>
</figure>
<figure>
<img src="综合属性2.png" alt="综合属性例子" />
<figcaption aria-hidden="true">综合属性例子</figcaption>
</figure>
<h3 id="继承属性inherited-attribute">继承属性(Inherited attribute)</h3>
<p>在分析树上的结点<span class="math inline">\(N\)</span>的
<strong>非终结符</strong> <span
class="math inline">\(A\)</span>的继承属性只能通过<span
class="math inline">\(N\)</span>的<strong>父节点,
兄弟结点或本身结点的属性值</strong>来定义.</p>
<figure>
<img src="继承属性.png" alt="继承属性例子" />
<figcaption aria-hidden="true">继承属性例子</figcaption>
</figure>
<figure>
<img src="继承属性2.png" alt="继承属性例子" />
<figcaption aria-hidden="true">继承属性例子</figcaption>
</figure>
<hr />
<p>终结符只有综合属性,
原因是其综合属性指向的是符号表序号(或者说是词法分析器提供的词法值),
不论其父结点怎么变, 终结符的属性都不会变, 因此不能存在继承属性. <span
class="math inline">\(SDD\)</span>中也没有计算终结符属性值的语义规则.</p>
<hr />
<h3 id="注释分析树annotated-parse-tree">注释分析树(Annotated parse
tree)</h3>
<p>在分析树中标明语义值.</p>
<h3 id="sdd-的求值顺序">SDD 的求值顺序</h3>
<p>在对语法分析树的一个结点求属性值之前, 应该
<strong>先求出它所依赖的所有属性值</strong></p>
<p><strong>依赖图(Dependency graph)</strong></p>
<ul>
<li>如果<span class="math inline">\(X.a\)</span>的值
<strong>依赖于</strong> 属性<span
class="math inline">\(Y.b\)</span>的值, 则依赖图中有一条 <strong>从 Y.b
指向 X.a 的有向边</strong>. 方便起见, 可以将
<strong>综合属性放在结点的右边, 继承属性放在左边</strong>.</li>
<li>注意: 如果语义规则中含有副作用 (即调用了某个函数,
函数中用到了语义属性), 则为它创建一个 <strong>虚拟结点</strong>,
如下所示</li>
</ul>
<figure>
<img src="虚拟结点.png" alt="虚拟结点" />
<figcaption aria-hidden="true">虚拟结点</figcaption>
</figure>
<p>可行的求值顺序: <strong>拓扑排序</strong>,
依赖者的序号大于被依赖者的序号.</p>
<ul>
<li>只有综合属性的 SDD, 可以按照任意自底向上的顺序计算它们的值</li>
<li>同时具有综合属性和继承属性的 SDD,
不能保证存在应该顺序对各个结点上的属性进行求值</li>
<li><strong>依赖图中没有环, 则至少存在一个拓扑排序</strong></li>
</ul>
<p>给定一个 SDD, 很难确定是否存在某个语法树, 使得依赖图无环, 但存在
<strong><span class="math inline">\(L\)</span>-属性定义</strong> 和
<strong><span class="math inline">\(S\)</span>-属性定义</strong>
保证每个语法分析树都存在求值顺序, 依赖图无环.</p>
<h3 id="s-属性定义"><span class="math inline">\(S\)</span>-属性定义</h3>
<p><strong>仅使用综合属性的 SDD</strong>, 可以在
<strong>自底向上</strong> 的语法分析过程中实现</p>
<h3 id="l-属性定义"><span class="math inline">\(L\)</span>-属性定义</h3>
<p>在一个产生式所关联的各属性之间, 依赖图的边 <strong>可以从左到右,
但不能从右到左</strong>. 正式定义为: 一个 SDD 是<span
class="math inline">\(L\)</span>-属性定义, 当且仅当它的每个属性要么
<strong>是一个综合属性</strong> 要么
<strong>是满足如下条件的继承属性</strong></p>
<ul>
<li>假设存在一个产生式<span class="math inline">\(A \rightarrow
X_1X_2\cdots X_n\)</span>, 其右部符号<span
class="math inline">\(X_i\)</span>的继承属性仅依赖于
<ul>
<li><span class="math inline">\(A\)</span>的继承属性
(不能依赖于父结点的综合属性,
因为父结点的综合属性可能依赖子结点的继承属性, 会导致循环依赖)</li>
<li>产生式中<span class="math inline">\(X_i\)</span>左边的符号的属性
(包括综合属性和继承属性)</li>
<li><span class="math inline">\(X_i\)</span>本身的属性, 但<span
class="math inline">\(X_i\)</span>的全部属性不能在依赖图中形成环路</li>
</ul></li>
</ul>
<hr />
<p>每个<span class="math inline">\(S\)</span>-属性定义都是<span
class="math inline">\(L\)</span>-属性定义</p>
<hr />
<h2 id="语法制导翻译方案-sdt">语法制导翻译方案 SDT</h2>
<p>以下两种 SDD 对应的 SDT 可以在语法分析过程中实现</p>
<ul>
<li><span class="math inline">\(LR\)</span>分析, <span
class="math inline">\(SDD\)</span>是<span
class="math inline">\(S\)</span>属性的</li>
<li><span class="math inline">\(LL\)</span>分析, <span
class="math inline">\(SDD\)</span>是<span
class="math inline">\(L\)</span>属性的</li>
</ul>
<p><strong>S-SDD</strong>: 转化为 SDT 时, 将每个语义动作放在产生式的最后
<strong>L-SDD</strong>: 转化为 SDT 时</p>
<ul>
<li>计算继承属性的动作插入到非终结符的前面</li>
<li>计算综合属性的动作放在产生式的最后</li>
</ul>
<h3
id="在非递归的预测分析过程中进行翻译">在非递归的预测分析过程中进行翻译</h3>
<p><strong>一个非终结符的继承属性和综合属性在分析过程中的计算时间是不一样的</strong></p>
<ul>
<li>继承属性的计算在该非终结符出现之前,
综合属性的计算在该非终结符的所有子结点分析结束之后</li>
</ul>
<p>为非终结符的<strong>综合属性</strong>单独创建一个元素<code>Xsyn</code>,
存放终结符 X 的综合属性, 此时在分析栈中, 包含三种类型的元素:</p>
<ul>
<li><span class="math inline">\(action\)</span>:
用于存放执行语义动作的代码指针</li>
<li><span class="math inline">\(A\)</span>: 非终结符<span
class="math inline">\(A\)</span>的继承属性</li>
<li><span class="math inline">\(Asyn\)</span>: 非终结符<span
class="math inline">\(Asyn\)</span>的综合属性</li>
</ul>
<p>分析时的基本原则是 <strong>综合记录出栈时,
要将综合属性值复制给后面<em>特定</em>的语义动作</strong>,
<strong>变量本身的记录出栈时 (发生推导的时候), 如果含有继承属性,
则将其值复制给后面的<em>特定</em>语义动作</strong></p>
<p>具体例子见 <a
href="https://www.bilibili.com/video/BV1zW411t7YE?p=40&amp;vd_source=698de1256a0048d0fd59d2f1bc3e109b">非递归翻译例子</a></p>
<h3 id="在递归预测过程中进行翻译">在递归预测过程中进行翻译</h3>
<p><strong>将每个非终结符实现为一个函数,
该非终结符的每个继承属性是该函数的一个形参,
返回值是该非终结符的综合属性</strong></p>
<figure>
<img src="递归翻译.jpg" alt="递归翻译" />
<figcaption aria-hidden="true">递归翻译</figcaption>
</figure>
<h3 id="l-属性定义的自底向上翻译">L-属性定义的自底向上翻译</h3>
<p>自底向上翻译要求翻译动作在 <strong>归约后调用</strong>, 但 L-SDD
中有一部分语义动作处于产生式的中间, 因此使用自底向上翻译时, 需要添加
<strong>标记非终结符</strong>, 代表 <strong>产生式中间的语义动作,
即继承属性对应的语义动作</strong></p>
<figure>
<img src="L-属性自底向上-标记非终结符.jpg"
alt="L-属性自底向上翻译-标记非终结符" />
<figcaption
aria-hidden="true">L-属性自底向上翻译-标记非终结符</figcaption>
</figure>
<p>其中<span class="math inline">\(M,
N\)</span>位于实际待求继承属性非终结符的左侧, 因此 <strong><span
class="math inline">\(M,
N\)</span>的综合属性是后续非终结符的继承属性</strong></p>
<blockquote>
<p>上述文法所对应的<span
class="math inline">\(SLR\)</span>自动机如下:</p>
<figure>
<img src="L-属性自底向上SLR" alt="L-属性自底向上例子-SLR" />
<figcaption aria-hidden="true">L-属性自底向上例子-SLR</figcaption>
</figure>
<p>考虑输入串</p>
<p><span class="math display">\[
3 * 5
\]</span></p>
<p>具体见视频讲解: <a
href="https://www.bilibili.com/video/BV1zW411t7YE?p=42&amp;vd_source=698de1256a0048d0fd59d2f1bc3e109b">L-属性自底向上例子</a></p>
</blockquote>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Basic</title>
    <url>/2022/09/01/Android/AndroidBasic/</url>
    <content><![CDATA[<p>"我只是想学kotlin而已"</p>
<p>"我不理解"</p>
<span id="more"></span>
<h1 id="android-studio">Android Studio</h1>
<p>一开始用的是Intelij IDEA, 后来觉得Android Studio挺香的.
当然前提是有JDK, Studio的话, 下载很快, 然后安装路径自选, 但是
<strong>注意在提示没有安装SDK的时候, 选择CANCEL</strong>,
安装完成后直接启动它.</p>
<p>这时候会提示你没有安装SDK, 并且会告诉你安装哪些东西,
只要选择安装路径即可, 等待片刻.</p>
<p>在<code>create device</code>里面, 可以新建<code>device</code>,
然后我新建了一个和我手机屏幕一样大的安卓虚拟机, 内存之类的看情况选,
没什么感觉.</p>
<h1 id="组件">组件</h1>
<h2 id="activity">Activity</h2>
<p>用于显示用户界面, 用户通过Activity交互完成相关操作,
一个APP可以有多个Activity</p>
<h1 id="布局">布局</h1>
<h2 id="linear-layout">Linear Layout</h2>
<p>比较常用的属性:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:id</span><br><span class="line">android:layout_width</span><br><span class="line">android:layout_height</span><br><span class="line">android:background</span><br><span class="line">android:layout_margin</span><br><span class="line">android:layout_padding</span><br><span class="line">android:layout_orientation</span><br><span class="line">android:gravity  <span class="comment">&lt;!--相对位置--&gt;</span></span><br><span class="line">android:layout_weight  <span class="comment">&lt;!--将剩余内容平分--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="relative-layout">Relative Layout</h2>
<p>比较常用的属性:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:layout_toLeftOf</span><br><span class="line">androidLlayout_toRightOf</span><br><span class="line">android:alignBottom</span><br><span class="line">android:alignParentBottom</span><br><span class="line">android:layout_below</span><br></pre></td></tr></table></figure>
<h1 id="控件">控件</h1>
<h2 id="text-view">Text View</h2>
<p>可以实现 <strong>文字大小, 颜色; 显示不下时使用...; 文字加icon;
中划线, 下划线; 跑马灯</strong></p>
<p><code>kotlin</code>实现中划线要重写扩展方法<code>apply()</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">my_text_view.apply &#123;</span><br><span class="line">    paintFlags = paintFlags or Paint.STRIKE_THRU_TEXT_FLAGS or Paint.ANTI_ALIAS_FLAG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="material-button">Material Button</h2>
<p>谷歌给的<code>Button</code>控件, 继承了之前的<code>Button</code></p>
<p>需要在<code>app/build.gradle</code>中添加依赖:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="keyword">group</span>: <span class="string">&#x27;com.google.android.material&#x27;</span>, name: <span class="string">&#x27;material&#x27;</span>, version: <span class="string">&#x27;1.4.0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>还需要更换谷歌它指定的样式主题,
在<code>values/theme.xml</code>中将主题改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Theme.MaterialComponents.Light.NoActionBar</span><br></pre></td></tr></table></figure>
<p>同步后便可以使用谷歌的<code>MaterialButton</code>, 不过为了修改属性,
用到了<code>app</code>和<code>tool</code>,
因此在相应的<code>activity</code>文件头添加:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br></pre></td></tr></table></figure>
<p>以示礼貌</p>
<p><strong>重点</strong></p>
<p>按钮又不是摆设, 所以要设计相应的页面跳转,
也就是需要实现相应的<code>clickListener</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mBtn: MaterialButton</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> onCreate ...</span></span><br><span class="line"></span><br><span class="line">        mBtn = findViewById(R.id.button_name)</span><br><span class="line">        mBtn.setOnClickListener() &#123;</span><br><span class="line">            startActivity(Intent(<span class="keyword">this</span>, OtherActivity::<span class="keyword">class</span>.java))</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>接着是颜值比较高的选择栏设计:</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Android</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>Compiler-zh</title>
    <url>/2022/09/05/CS/Compiler-zh/</url>
    <content><![CDATA[<p>"编译原理网课"</p>
<p>"B站大学不用交学费!!!"</p>
<span id="more"></span>
<h1 id="引论">引论</h1>
<p><strong>编译</strong>: 由高级语言转化为低级语言</p>
<p><strong>解释</strong>: 接受高级语言的 <strong>一个语句输入</strong>,
进行解释并执行, 立刻得到执行结果, 然后再接受下一句.</p>
<ul>
<li>不产生目标文件, 直观易懂, 结构简单, 易于人机对话</li>
<li>但效率低: 没有目标文件, 每次运行相当于要重新解释</li>
</ul>
<p><strong>编译的两个转换形式</strong></p>
<ul>
<li>编译 - 运行
<ul>
<li>先编译产生机器语言, 生成目标文件(.exe), 在运行时添加参数</li>
</ul></li>
<li>编译 - 汇编 - 运行
<ul>
<li>编译后产生汇编语言, 生成目标文件(.obj),
汇编语言汇编后产生机器语言</li>
</ul></li>
</ul>
<p><strong>编译过程</strong></p>
<p>源程序 -&gt; Lexical analyzer -&gt; Syntax analyzer -&gt; Semmantic
Analyzer -&gt; Intermediate code generation -&gt; Optimization -&gt;
Code generation -&gt; Target</p>
<p>symbol table management, error handler</p>
<h2 id="词法分析-lexical-analysis">词法分析 Lexical Analysis</h2>
<p>扫描源程序, 识别一个个 <strong>单词lexeme</strong>, 并进行
<strong>分类token</strong> (包括: keyword, constant, identifier,
operator, separator). 转化后的格式为 &lt;token-name, attr-value&gt;,
前者为token, 后者为 <strong>指向符号表的指针</strong>.</p>
<p>描述词法规则的有效工具是
<strong>正规式</strong>和<strong>有限自动机</strong></p>
<h2 id="语法分析-syntax-analysis">语法分析 Syntax Analysis</h2>
<p>把单词符号组成各类各类的语法单位, 如短语, 句子, 过程, 程序等</p>
<p>方法:</p>
<ul>
<li>derive:
<ul>
<li>最右推导: 每次将最右的部分按照规则进行转化</li>
<li>最左推导:</li>
</ul></li>
<li>reduce: 推导的逆过程
<ul>
<li>最左归约: 最右推导的逆过程</li>
<li>最右归约: 最左推导的逆过程</li>
</ul></li>
</ul>
<p>计算机处理方法: <strong>语法树</strong></p>
<h2 id="语义分析-semmantic-ananlysis">语义分析 Semmantic Ananlysis</h2>
<p>审查源程序有无语义错误, 为代码生成阶段收集类型信息. 重要的一步是
<strong>类型检查</strong></p>
<h2 id="中间代码生成-intermediate-code-generation">中间代码生成
Intermediate Code Generation</h2>
<p>中间代码设计原则</p>
<ul>
<li>容易生成</li>
<li>容易翻译为目标代码</li>
</ul>
<p>中间代码形式: 四元式, 三元式, 逆波兰式</p>
<ul>
<li>四元式: &lt;运算符, 操作数1, 操作数2, 结果&gt;</li>
</ul>
<h2 id="优化-optimization">优化 Optimization</h2>
<p>原则: <strong>等价变换</strong></p>
<p>主要方面: 公共子表达式的提取, 合并已知量, 删除无用语句, 循环优化</p>
<h2 id="目标代码生成-code-generation">目标代码生成 Code Generation</h2>
<p>将经过优化的中间代码转化为特定机器上的低级语言</p>
<p>目标代码的形式:</p>
<ul>
<li>绝对指令代码: 可立即执行的目标代码, 纯粹的0-1代码.</li>
<li>汇编指令代码: 汇编语言程序, 需要通过汇编程序汇编后才能运行,
能和物理机隔离.</li>
<li>可重定位指令代码: 先将各目标模块连接起来, 确定变量,
常数在主存中的位置, 装入主存后才能成为可以运行的绝对指令代码,
而后还需要进行 <strong>链接</strong>.</li>
</ul>
<h2 id="表格管理-symbol-table-management">表格管理 Symbol Table
Management</h2>
<p>用来记录源程序的各种信息和编译过程中的各种状况.</p>
<p>与编译前三段有关的表格有: 符号表, 常数表, 标号表, 分程序入口表,
中间代码表 <!-- 
### 符号表

| name | information |
|------|-------------|
| m | 整型, 变量地址 |
| n | 整型, 变量地址 |

### 常数表

|value|
|-----|
|1|
|4|

### 标号表

|name|information|
|----|-----------|
|xx|某句话|

*某句话是在 --></p>
<h2 id="错误处理-error-handler">错误处理 Error Handler</h2>
<p>如果源程序出错, 编译程序应该设法发现错误, 并报告给用户.</p>
<h2 id="其他概念">其他概念</h2>
<p><strong>趟/遍 pass</strong>: 将源程序从头到尾扫描一遍,
做相应的加工处理, 并生成相应的中间代码和目标代码.
多遍扫描可以节省内存空间, 提高目标代码质量, 使编译的逻辑结构更清楚,
但编译时间长, 因此 no free launch.</p>
<p>因此在一遍编译中:</p>
<p>源程序 -&gt; 编译程序 -&gt; 目标代码</p>
<p><strong>编译程序的编写</strong></p>
<ul>
<li>直接用机器语言</li>
<li>用汇编语言编写, 编译程序的核心部分常用汇编语言编写
<ul>
<li>编译程序怎么生成? 编译程序是用汇编语言编写的,
汇编语言经过汇编后即可生成编译程序(可执行),
再利用这个编译程序将自己的源代码变为目标代码.</li>
</ul></li>
<li>用高级语言编写, 普遍采用的方法.
<ul>
<li>例如用C语言写成的编译程序, 则先用C语言的编译器将C源程序编译为exe,
再用于分析其他语言, 也可以是C语言.</li>
</ul></li>
<li>自编译
<ul>
<li>先编写一个很小的编译程序的核心, 再由这个核心逐渐去分析,
编译其他代码.</li>
</ul></li>
<li>编译工具: LEX(词法分析), YACC(语法分析)</li>
<li>移植: 同种语言的编译程序在不同类型的机器之间移植</li>
</ul>
<h1 id="编译基础">编译基础</h1>
<p>高级语言是一个记号系统.</p>
<ul>
<li>语法</li>
<li>语义</li>
</ul>
<p><strong>语法</strong> 包括 <strong>词法规则</strong> 和
<strong>语法规则</strong></p>
<ul>
<li>词法规则: 判断每一个"单词"是否正确,
规定了哪些符号是是单词符号(最基本结构; 常数, 标识符, 基本字, 算符,
界限符等); 用正规式和有限自动机描述和分析</li>
<li>语法规则: 结合单词是否是语言中的语法单位(表达式),
规定如何用单词形成语法单位, 包括表达式, 子句, 语句, 函数, 过程,
程序等.</li>
</ul>
<p><strong>语义</strong> 给出单词符号和语法符号的意义,
大多数编译程序使用基于属性文法的语法制导翻译方法来分析语义.</p>
<p>重点是正规文法, 上下文无关文法及其对应的有限自动机和下推自动机.</p>
<h2 id="一些概念">一些概念</h2>
<p><strong>字母表</strong>: 符号的非空有穷集合, 用<span
class="math inline">\(V, \Sigma\)</span>表示.
所使用的符号均出自字符表.</p>
<p><strong>符号</strong>: 语言中最基本的不可再分的单位.</p>
<p><strong>符号串</strong>: 字符表中符号组成的有穷序列.
<strong>空串</strong> 用<span
class="math inline">\(\epsilon\)</span>表示.</p>
<p><strong>句子</strong>: 字母表上符合某种规则构成的串</p>
<p><strong>语言</strong>: 字母表上句子的集合</p>
<p>*小写字母表示符号, 大写字母表示集合, 希腊字母表示符号串.</p>
<h3 id="运算">运算</h3>
<p><strong>连接(乘积)运算</strong></p>
<p><span class="math display">\[
\begin{aligned}
  A &amp;= \{\alpha_1, \alpha_2, \cdots\} \\
  B &amp;= \{\beta_1, \beta_2, \cdots\} \\
  def:\quad AB &amp;= \{\alpha \beta | \alpha\in A\ and\ \beta\in B\}
\end{aligned}
\]</span> 其中<span class="math inline">\(A,B\)</span>是串集. 规定:
<span class="math inline">\(A^0=\{\epsilon\}\)</span>. 注意该运算
<strong>非可交换</strong>. 例子: <span
class="math inline">\(\alpha\)</span>表示<code>if ()</code>, <span
class="math inline">\(\beta\)</span>表示<code>then()</code>.</p>
<p><strong>闭包</strong></p>
<p><span class="math display">\[
A^\star=A^0\cup A^1 \cup A^2 \cup \cdots
\]</span></p>
<p>由A上所有符号组成的所有串的集合.</p>
<p><strong>正闭包</strong></p>
<p><span class="math display">\[
A^{+} = A^1 \cup A^2 \cup A^3 \cup \cdots = A^\star - {\epsilon}
\]</span></p>
<p><strong>文法</strong></p>
<p>描述语言的语法结构规则</p>
<ul>
<li><strong>非终结符</strong>: 出现在规则的左部,
用"&lt;&gt;"括起来或用大写字母表示, 表示一定语法概念的词, 用<span
class="math inline">\(V_N\)</span>表示</li>
<li><strong>终结符</strong>: 语言中不可以再分割的字符串, 用<span
class="math inline">\(V_T\)</span>表示</li>
<li><strong>开始符号</strong>: 表示所定义的语法范畴的非终结符,
表示该文法中最大的一个语法成分 (?比如说一个句子)</li>
<li><strong>产生式</strong>: 是用来定义符号串之间关系的一组语法规则,
<span class="math inline">\(A\rightarrow \alpha\)</span></li>
<li><strong>推导</strong>: 推导是从开始符号开始,
通过产生式的右部取代左部, 最终产生语言的一个句子的过程.
<ul>
<li><strong>最左推导</strong>: 每次使用一个规则,
以其右部取代符号串最左的非终结符.</li>
</ul></li>
<li><strong>归约</strong>: 推导的逆过程, 从给定的源语言的一个句子开始,
通过规则的左部取代右部, 最终达到开始符号的过程.
<ul>
<li><strong>最左归约</strong>: 最常采用</li>
</ul></li>
<li><strong>句型</strong>: 从文法的开始符号<span
class="math inline">\(S\)</span>开始,
每步推导(包括0步推导)所得到的字符串<span
class="math inline">\(\alpha\)</span>. 记作<span
class="math inline">\(S\rightarrow^\star \alpha, where\ \alpha\in (V_N
\cup V_T)^\star\)</span>
<ul>
<li><strong>句子</strong>: 仅含终结符的句型, 若能归约为开始符号,
则该句子是正确的</li>
</ul></li>
<li><strong>语言</strong>: 语言是由开始符号<span
class="math inline">\(S\)</span>通过1步或1步以上推导所得的句子的集合,
记为<span
class="math inline">\(L(G)=\{\alpha|S\rightarrow^+\alpha,\alpha\in
V_T^*\}\)</span></li>
<li><strong>文法规则的递归定义</strong>:
非终结符的定义中包含了非终结符自身</li>
</ul>
<h2 id="文法与语言的形式定义">文法与语言的形式定义</h2>
<p>Chomsky对文法的定义: 文法G是一个四元组<span
class="math inline">\((V_N, V_T, P, S)\)</span>, 其中<span
class="math inline">\(P\)</span>是文法规则的集合, <span
class="math inline">\(S\)</span>是开始符号</p>
<p><strong>0型文法</strong></p>
<p>又称短语文法或者无限制文法. <span
class="math inline">\(P\)</span>中产生式<span
class="math inline">\(\alpha\rightarrow\beta,\alpha\in V^+=(V_N\cup
V_T)^+\)</span>, <span
class="math inline">\(\alpha\)</span>至少含有一个非终结符,<span
class="math inline">\(\beta\in V^\star\)</span>.</p>
<ul>
<li>对产生式限制最少</li>
<li>图灵机</li>
<li>可递归可枚举</li>
</ul>
<p><strong>1型文法</strong></p>
<p><span class="math inline">\(P\)</span>中产生式<span
class="math inline">\(\alpha\rightarrow\beta\)</span>, 除可能有<span
class="math inline">\(S\rightarrow \epsilon\)</span>外均有<span
class="math inline">\(|\beta|\geq|\alpha|\)</span>, 若有<span
class="math inline">\(S\rightarrow\epsilon\)</span>, 规定<span
class="math inline">\(S\)</span>不能出现在产生式的右部.</p>
<p>等价定义: <span class="math inline">\(P\)</span>中产生式<span
class="math inline">\(\alpha\rightarrow\beta\)</span>除了可能有<span
class="math inline">\(S\rightarrow\epsilon\)</span>外均有<span
class="math inline">\(\alpha S \beta \rightarrow \alpha \gamma \beta,
\alpha, \beta \in V^\star, A\in V^n, \gamma\in V^+\)</span>.</p>
<hr />
<p>对非终结符进行替换时, 必须考虑上下文, 并且一般不允许替换为<span
class="math inline">\(\epsilon\)</span>, 除非是开始符号产生<span
class="math inline">\(\epsilon\)</span>.</p>
<hr />
<p><strong>2型文法</strong></p>
<p><span class="math inline">\(P\)</span>中产生式具有形式<span
class="math inline">\(A\rightarrow\beta, A\in V_N, \beta\in
V^\star\)</span>. 要求产生式左边只有一个非终结符.</p>
<p>不必考虑上下文, 上下文无关文法.</p>
<p>识别2型文法的自动机称为下推自动机</p>
<p><strong>3型文法</strong></p>
<p><span class="math inline">\(P\)</span>中产生式具有形式<span
class="math inline">\(A\rightarrow \alpha B, A\rightarrow
\alpha\)</span>或者<span class="math inline">\(A \rightarrow B\alpha,
A\rightarrow \alpha, A,B\in V_N, \alpha\in V_T^\star\)</span>.
也称为正规文法, (左|右)线性文法, 识别3型文法的自动机称为有限自动机.</p>
<hr />
<p>词法分析和语法分析中对产生式的限制: 1)不产生<span
class="math inline">\(P\rightarrow P\)</span>,
2)产生式中出现的任何非终结符必须有用, 能经过若干步推导出终结符</p>
<hr />
<p><strong>一些例子</strong></p>
<p><strong>例1</strong> 语言<span
class="math inline">\(L=\{\omega|\omega\in(a,b)^\star\)</span>且<span
class="math inline">\(\omega\)</span>中含有个数相同的<span
class="math inline">\(a,b\}\)</span>, 构造生成该语言的文法:</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow\epsilon \\
  S&amp;\rightarrow aA\\
  S&amp;\rightarrow bB\\
  A&amp;\rightarrow aAA | bS\\
  B&amp;\rightarrow aS | bBB
\end{align*}
\]</span></p>
<p>解释: 要么以<span class="math inline">\(a\)</span>开头, 要么以<span
class="math inline">\(b\)</span>开头, 后面跟着符号串. 对于符号串<span
class="math inline">\(A\)</span>, 如果以<span
class="math inline">\(b\)</span>开头, 则后面跟着<span
class="math inline">\(ab\)</span>个数相等的符号串, 如果仍然以<span
class="math inline">\(a\)</span>开头, 此时后面必须还要至少出现两次<span
class="math inline">\(b\)</span>.</p>
<p>或者</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow\epsilon\\
  S&amp;\rightarrow aSbS\\
  S&amp;\rightarrow bSaS
\end{align*}
\]</span></p>
<p>解释: 若以<span class="math inline">\(a\)</span>开头,
则在字符串的某个位置必然出现一个<span class="math inline">\(b\)</span>,
而这两个<span class="math inline">\(a,b\)</span>中间是<span
class="math inline">\(ab\)</span>个数相等的的字符串, b后面也是<span
class="math inline">\(ab\)</span>个数相等的符号串.</p>
<p><strong>例2</strong> 设<span class="math inline">\(L=\{\omega |
\omega\in(0,1)^\star\)</span>且<span
class="math inline">\(1\)</span>的个数为偶数个<span
class="math inline">\(\}\)</span>, 构造生成该语言的文法:</p>
<p>可以先列出看一下:</p>
<p><span class="math display">\[
\omega\in\{\epsilon, 0, 11, 011, 101, 110,\cdots\}
\]</span></p>
<p>然后:</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow\epsilon\\
  S&amp;\rightarrow 0S\\
  S&amp;\rightarrow 1A\\
  A&amp;\rightarrow 1S | 0A
\end{align*}
\]</span></p>
<h2 id="文法的构造与简化">文法的构造与简化</h2>
<h3 id="简化">简化</h3>
<p>同一语言可以产生不同的文法, 选择产生式最少,
最符合语言特征的文法来描述; 有些产生式对推导不起作用, 包括:
<strong>推导中永远用不到, 永远导不出终结符的, 形如<span
class="math inline">\(P\rightarrow P\)</span>的...</strong></p>
<p><strong>一些例子</strong></p>
<p><strong>例1</strong> 简化文法:</p>
<p><span class="math display">\[
\begin{align*}
  S&amp;\rightarrow Be\\
  S&amp;\rightarrow Ee\\
  A&amp;\rightarrow Ae\\
  A&amp;\rightarrow e\\
  A&amp;\rightarrow A\\
  B&amp;\rightarrow Ce\\
  B&amp;\rightarrow Af\\
  C&amp;\rightarrow Cf\\
  D&amp;\rightarrow f
\end{align*}
\]</span></p>
<p>显然应该保留0236.</p>
<h3 id="构造">构造</h3>
<p><strong>构造无<span
class="math inline">\(\epsilon\)</span>产生式的上下文无关文法</strong></p>
<p>满足: <span class="math inline">\(P\)</span>中要么不含有<span
class="math inline">\(\epsilon\)</span>产生式, 要么只有<span
class="math inline">\(S\rightarrow\epsilon\)</span>, 且若<span
class="math inline">\(S\rightarrow\epsilon\)</span>, 则<span
class="math inline">\(S\)</span>不出现在任何产生式右部.</p>
<h1 id="语义分析与中间代码生成">语义分析与中间代码生成</h1>
<p><strong>在语法分析的过程中边分析边翻译,
翻译的结果是生成中间代码</strong></p>
<p><strong>语法制导翻译</strong>
在语法分析中调用语义翻译程序生成相应的中间代码,
使用CFG来引导对语言的翻译, 面向文法</p>
<ul>
<li>根据产生式右部符号进行翻译</li>
<li>依据语义子程序
<ul>
<li>语义子程序: 用于改变变量的值, 查填符号表, 发现源程序错误,
产生中间代码</li>
</ul></li>
</ul>
<p><span class="math display">\[
X \rightarrow \alpha \{语义子程序\}
\]</span></p>
<ul>
<li>具体做法: <strong>为每一个产生式配置一个语义子程序,
当语法分析进行归约或推导时调用相应的语义子程序</strong></li>
<li>注意: <strong>产生式中同一个符号出现多次, 需要区分,
加上角标</strong></li>
</ul>
<p><span class="math display">\[
E \rightarrow E_1 + E_2
\]</span></p>
<ul>
<li>语义值: <strong>需要为每个文法符号赋予不同的语义值</strong>, 如类型,
(符号表) 地址, 代码值 (不是数字), 并且
<strong>只有非终结符才有语义值</strong></li>
<li>语义栈: 各个符号的语义值放在语义栈中. 产生式进行归约时,
需对右部符号的语义值进行综合, 结果作为左部符号的语义值保存在语义栈中.
<strong>语义栈, 符号栈, 状态栈同步变化</strong></li>
</ul>
<p><strong>中间代码</strong> 转化为目标代码的中间生成的代码,
容易翻译</p>
<ul>
<li>形式
<ul>
<li>四元式: <span class="math inline">\(Operator, Op_1, Op_2,
Result\)</span>, 两个操作数和结果可以是用户自定义, 也可以是编译时变量.
变量采用的是符号表入口地址.</li>
<li>三元式: <span class="math inline">\(Operator, Op_1, Op_2\)</span>,
三元式本身就是结果, 以三元式的编号区别</li>
<li>逆波兰式 (后缀表示): <span class="math inline">\(Op_1, Op_2,
Operator\)</span>, 无括号, 从左到右扫描一遍</li>
<li>树形表示</li>
</ul></li>
</ul>
<h2 id="赋值语句-简单变量无数组-的翻译">赋值语句 (简单变量无数组)
的翻译</h2>
<p><strong>文法</strong>:</p>
<p>$$ A i = E \</p>
<p>E E + E | E * E | -E | (E) | i $$</p>
<p><strong>内置函数</strong>:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NEWTEMP  # 产生临时变量</span><br><span class="line">ENRTY(i)  # 获取变量i的符号表地址</span><br><span class="line">GEN(operator, op1, op2, result)  # 生成四元式中间代码</span><br></pre></td></tr></table></figure>
<p><strong>语义变量</strong>:</p>
<p><span class="math display">\[
E.PLACE
\]</span></p>
<ul>
<li>值是某个变量的符号表地址或临时变量的序号</li>
<li>分析过程需要就建立, 不需要就消亡</li>
</ul>
<p><strong>建立语法制导定义 (SDD)</strong>:</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>产生式</th>
<th>语义规则 (子程序)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(A \rightarrow i = E\)</span></td>
<td>{<span class="math inline">\(GEN(=, E.PLACE, NULL,
ENTRY(i))\)</span>}</td>
</tr>
<tr class="even">
<td><span class="math inline">\(E \rightarrow -E_1\)</span></td>
<td>{<span class="math inline">\(T = NEWTEMP; GEN(@, E_1.PLACE, NULL,
T); E.PLACE = T;\)</span>}</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(E \rightarrow E_1 * E_2\)</span></td>
<td>{<span class="math inline">\(T = NEWTEMP; GEN(*, E_1.PLACE,
E_2.PLACE, T); E.PLACE = T;\)</span>}</td>
</tr>
<tr class="even">
<td><span class="math inline">\(E \rightarrow E_1 + E_2\)</span></td>
<td>{<span class="math inline">\(T = NEWTEMP; GEN(+, E_1.PLACE,
E_2.PLACE, T); E.PLACE = T;\)</span>}</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(E \rightarrow (E_1)\)</span></td>
<td>{<span class="math inline">\(E.PLACE = E_1.PLACE\)</span>}</td>
</tr>
<tr class="even">
<td><span class="math inline">\(E \rightarrow i\)</span></td>
<td>{<span class="math inline">\(E.PLACE = ENTRY(i)\)</span>}</td>
</tr>
</tbody>
</table>
<h3 id="类型转换">类型转换</h3>
<p>处理混合运算, 如整型与实型运算, 最后的结果为实型</p>
<p><strong>语义变量</strong>:</p>
<p><span class="math display">\[
E.MODE
\]</span></p>
<p><strong>建立语法制导定义 (SDD)</strong>:</p>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th>产生式</th>
<th>语义规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(E \rightarrow E_1\ op\ E_2\)</span></td>
<td>{<span class="math inline">\(IF\ E_1.MODE = int\ AND\ E_2.MODE =
int\ THEN\ E.MODE = int\ ELSE\ E.MODE = real\)</span>}</td>
</tr>
</tbody>
</table>
<p>例如 <span class="math inline">\(X = Y + I * J\)</span>, 其中<span
class="math inline">\(X, Y\)</span>是实型的, <span
class="math inline">\(I, J\)</span>是整型的, 四元式为:</p>
<p><span class="math display">\[
(*_i, I, J, T_1) \\
(itr, T_1, NULL, T_2) \\
(+_r, Y, T_2, T_3) \\
(=, T_3, NULL, X)
\]</span></p>
<p>对运算符也要指出相应的类型.</p>
<h2 id="布尔表达式的翻译">布尔表达式的翻译</h2>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101</title>
    <url>/2022/07/09/CS/GAMES101/</url>
    <content><![CDATA[<p>"From GAMES101"</p>
<span id="more"></span>
<h1 id="transformation">Transformation</h1>
<h2 id="basic"><strong>Basic</strong></h2>
<h3 id="scale">Scale</h3>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{aligned}
    &amp;s_x\ \ &amp;0 \\
    &amp;0\ \ &amp;s_y
\end{aligned} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
\]</span></p>
<h3 id="rotation">Rotation</h3>
<p>Rotation:</p>
<p><span class="math display">\[
R_{\theta} =
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;cos\theta\ \ &amp;-sin\theta \\
    &amp;sin\theta\ \ &amp;cos\theta
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
\]</span></p>
<p>inverse rotation:</p>
<p><span class="math display">\[
R_{-\theta} =
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;cos\theta\ \ &amp;sin\theta \\
    &amp;-sin\theta\ \ &amp;cos\theta
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
= R_{\theta}^{-1}
= R^T
\]</span></p>
<p>3-D: Eular angle: rotation around axises. The rotation is similar to
2-D, but inverse for axis y.</p>
<p>For a general rotation around an axis vector <span
class="math inline">\(n\)</span>, Rodrigues' Rotation Formula:</p>
<p><span class="math display">\[
R(n, \alpha) = cos\alpha I + (1 - cos\alpha)n n^T + sin\alpha
\left [ \begin{matrix}
    &amp;0 &amp;-n_z &amp;n_y \\
    &amp;n_z &amp;0 &amp;-n_x \\
    &amp;-n_y &amp;n_x &amp;0
\end{matrix} \right ]
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\left [ \begin{matrix}
    &amp;0\ \ &amp;-n_z\ \ &amp;n_y \\
    &amp;n_z\ \ &amp;0\ \ &amp;-n_x \\
    &amp;-n_y\ \ &amp;n_x\ \ &amp;0
\end{matrix} \right ]
\]</span></p>
<p>是叉积算子, 物理含义为角速度</p>
<p>For an arbitrary axis, do a translation (following).</p>
<h3 id="homogeneous-coordinates">Homogeneous coordinates</h3>
<p><span class="math display">\[
x_1 = x + t_x \\
y_1 = y + t_y
\]</span></p>
<p>solution:</p>
<p><strong>point:</strong> <span class="math inline">\((x, y,
1)^T\)</span></p>
<p><strong>vector:</strong> <span class="math inline">\((x, y,
0)^T\)</span></p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime} \\
    w
\end{aligned} \right ]
=
\left [ \begin{aligned}
    &amp;1\ &amp;0\ &amp;t_x \\
    &amp;0\ &amp;1\ &amp;t_y \\
    &amp;0\ &amp;0\ &amp;1
\end{aligned} \right ]
\left [ \begin{aligned}
    x \\
    y \\
    1
\end{aligned} \right ]
=
\left [ \begin{aligned}
    x + t_x \\
    y + t_y \\
    1
\end{aligned} \right ]
\]</span></p>
<p>for a general form:</p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x \\
    y \\
    w
\end{aligned} \right ]
\]</span></p>
<p>is the same with (<span class="math inline">\(w\neq 0\)</span>)</p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x / w \\
    y / w \\
    1
\end{aligned} \right ]
\]</span></p>
<h3 id="affine">Affine</h3>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime}
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;a\ \ &amp;b \\
    &amp;c\ \ &amp;d
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y
\end{aligned} \right ]
+
\left [ \begin{aligned}
    t_x \\
    t_y
\end{aligned} \right ]
\]</span></p>
<p>is the same with</p>
<p><span class="math display">\[
\left [ \begin{aligned}
    x^{\prime} \\
    y^{\prime} \\
    w
\end{aligned} \right ]
=
\left [ \begin{matrix}
    &amp;a\ &amp;b\ &amp;t_x \\
    &amp;c\ &amp;d\ &amp;t_y \\
    &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\left [ \begin{aligned}
    x \\
    y \\
    1
\end{aligned} \right ]
\]</span></p>
<h2 id="viewing">Viewing</h2>
<p>MVP transformation (Model, View, Projection)</p>
<h3 id="view">view</h3>
<p>Define the camera:</p>
<ul>
<li>position <span class="math inline">\(e\)</span></li>
<li>gaze direction (look-at): <span
class="math inline">\(g\)</span></li>
<li>up direction: <span class="math inline">\(t\)</span></li>
</ul>
<p><strong>Method: Fix the camera: origin, look-at axis -z, look-up axis
y</strong> (将相机移动到一个规定位置上)</p>
<figure>
<img src="view1.png" alt="view" />
<figcaption aria-hidden="true">view</figcaption>
</figure>
<p>对应的变换, 先做平移, 再做旋转:</p>
<p><span class="math display">\[
M_{view} = R_{view}T_{view}
\]</span></p>
<p>其中平移:</p>
<p><span class="math display">\[
T_{view} =
\left [ \begin{matrix}
    &amp;1\ &amp;0\ &amp;0\ &amp;x_e \\
    &amp;0\ &amp;1\ &amp;0\ &amp;y_e \\
    &amp;0\ &amp;0\ &amp;1\ &amp;z_e \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ];
\]</span></p>
<p>旋转:</p>
<p><span class="math display">\[
R_{view}^{-1} =
\left [ \begin{matrix}
    &amp;x_{g\times t}\ &amp;x_t\ &amp;x_{-g}\ &amp;0 \\
    &amp;y_{g\times t}\ &amp;y_t\ &amp;y_{-g}\ &amp;0 \\
    &amp;z_{g\times t}\ &amp;z_t\ &amp;z_{-g}\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ],
R_{view} =
\left [ \begin{matrix}
    &amp;x_{g\times t}\ &amp;y_{g\times t}\ &amp;z_{g\times t}\ &amp;0
\\
    &amp;x_t\ &amp;y_t\ &amp;z_t\ &amp;0 \\
    &amp;x_{-g}\ &amp;y_{-g}\ &amp;z_{-g}\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\]</span></p>
<p>注意对所有物体变换.</p>
<h3 id="projection">projection</h3>
<figure>
<img src="projection.png" alt="projection" />
<figcaption aria-hidden="true">projection</figcaption>
</figure>
<p><strong>orthographic projection</strong></p>
<p>将模型 <span class="math inline">\([r, l]\times[b, t]\times[f,
n]\)</span> 转化为 <span class="math inline">\([-1, 1]\times[-1,
1]\times[-1, 1]\)</span></p>
<p><span class="math display">\[
M_{ortho} =
\left [ \begin{matrix}
    &amp;\frac{2}{r-l}\ &amp;0\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;\frac{2}{t-f}\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;\frac{2}{n-f}\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\left [ \begin{matrix}
    &amp;1\ &amp;0\ &amp;0\ &amp;-\frac{r+l}{2} \\
    &amp;0\ &amp;1\ &amp;0\ &amp;-\frac{b+t}{2} \\
    &amp;0\ &amp;0\ &amp;1\ &amp;-\frac{n+f}{2} \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\]</span></p>
<p><strong>perspective projection</strong></p>
<p>分两步进行: 先将棱锥变换为长方体; 再将长方体做正交投影.</p>
<p><strong>第一步</strong>: 保证远平面的中心不变, 远平面的 z 坐标不变,
近平面不变.</p>
<p>三角形相似:</p>
<p><span class="math display">\[
y^{\prime}=\frac{n}{z}y;\ x^{\prime}=\frac{n}{z}x
\]</span></p>
<p>设棱锥内任意一点 <span
class="math inline">\(P=(x_0,y_0,z_0,1)^T\)</span>, 经过挤压后变换为
<span
class="math inline">\(P^{\prime}=(x_0^{\prime},y_0^{\prime},z_0^{\prime},1)^T=(\frac{n}{z_0}x_0,\frac{n}{z_0}y_0,z_0^{\prime},1)^T=(nx_0,ny_0,z_0z_0^{\prime},z_0)^T\)</span>.
接下来确定 <span class="math inline">\(z_0^{\prime}\)</span>.</p>
<p>取近平面的中心点 <span class="math inline">\(O_1=(0,0,n,1)\)</span>
和远平面的中心点 <span class="math inline">\(O_2=(0,0,f,1)\)</span>,
变换后位置不变.</p>
<p><span class="math display">\[
O_1\Rightarrow O_1^{\prime}=(0,0,n^2,n)^T;\ O_2\Rightarrow
O_2^{\prime}=(0,0,f^2,f)
\]</span></p>
<p>从而确定矩阵:</p>
<p><span class="math display">\[
M_{perp\rightarrow ortho}
\left [ \begin{matrix}
    &amp;n\ &amp;0\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;n\ &amp;0\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;n+f\ &amp;-nf \\
    &amp;0\ &amp;0\ &amp;1\ &amp;0
\end{matrix} \right ]
\]</span></p>
<p><strong>第二步</strong>: 将变换后的长方体做正交投影 <span
class="math inline">\(M_{ortho}\)</span></p>
<p>因此透视投影为</p>
<p><span class="math display">\[
M_{perp} = M_{ortho}M_{perp\rightarrow ortho}
\]</span></p>
<p>可以代入一些特殊点发现一些现象:</p>
<p>例如将中轴的中点 <span class="math inline">\(P=(0,0,\frac{n+f}{2},
1)\)</span> 经过上述变换得 <span
class="math inline">\(P^{\prime}=(0,0,\frac{n^2+f^2}{n+f}, 1)\)</span>,
与此时的中轴中点 <span
class="math inline">\(Q^{\prime}=(0,0,\frac{n+f}{2},1)\)</span>
比较发现, <span class="math inline">\(\frac{n^2+f^2}{n+f} &gt;
\frac{n+f}{2}\)</span>, 即原来的中点应该更加 <strong>靠近</strong>
相机.</p>
<h1 id="resterization">Resterization</h1>
<h2 id="triangles">Triangles</h2>
<h3 id="some-definition">Some definition</h3>
<ul>
<li><strong>aspect ratio:</strong> width / height</li>
<li><strong>FOV, field of view:</strong></li>
</ul>
<figure>
<img src="raster1.png" alt="def" />
<figcaption aria-hidden="true">def</figcaption>
</figure>
<ul>
<li><strong>screen (raster)</strong>
<ul>
<li>an array of pixels</li>
<li>size of the pixels: resolution (分辨率)</li>
<li>a typical kind of raster display</li>
</ul></li>
</ul>
<p>将raster放置在坐标系中, 并以像素的 <strong>左下角</strong> 作为坐标,
其像素中心则需要再加上0.5. (虎书里以中心作为坐标)</p>
<p>假设显示区域为 <span class="math inline">\(width\times
height\)</span>, 则将 viewing 后的 <span
class="math inline">\([-1,1]^3\)</span> 变换为显示区域大小 <span
class="math inline">\(width\times height\)</span>, 即 <strong>视口变换
(view port)</strong>:</p>
<p><span class="math display">\[
M_{viewport}
\left [ \begin{matrix}
    &amp;\frac{width}{2}\ &amp;0\ &amp;0\ &amp;\frac{width}{2} \\
    &amp;0\ &amp;\frac{height}{2}\ &amp;0\ &amp;\frac{height}{2} \\
    &amp;0\ &amp;0\ &amp;1\ &amp;0 \\
    &amp;0\ &amp;0\ &amp;0\ &amp;1
\end{matrix} \right ]
\]</span></p>
<h3 id="triangles-1">Triangles</h3>
<p>将图像用三角形光栅</p>
<p>为什么是三角形?</p>
<ul>
<li>最基本多边形, 任意多边形可以拆成三角形</li>
<li>保证三角形是一个平面</li>
<li>内部和外部可以定义</li>
<li>内部插值</li>
</ul>
<h3 id="samlping">Samlping</h3>
<p>连续函数离散化</p>
<p><span class="math display">\[
Sampling (x) = \left\{
    \begin{matrix}
        1,\quad x\in triangle, \\
        0,\quad x\notin triangle
    \end{matrix}
    \right.
\]</span></p>
<p>其中 <span class="math inline">\(x\)</span>
是像素<strong>中心</strong></p>
<p>判断某个点是否在三角形内部: 设点 <span
class="math inline">\(P\)</span>, 三角形 <span
class="math inline">\(\triangle XYZ\)</span>, 分别用 <span
class="math inline">\(\vec{XY}, \vec{YZ}, \vec{ZX}\)</span> 与 <span
class="math inline">\(\vec{XP}, \vec{YP}, \vec{ZP}\)</span> 做外积,
若外积的结果方向一致, 则说明 <span class="math inline">\(P\)</span>
在三角形内部, 反之外部.</p>
<p><strong>Bounding Box:</strong> 最小的包围所考虑图形的长方体.
遍历时只遍历 Bounding Box 即可. 又称轴向包围盒 (AABB)</p>
<p>此外, 还可以找三角形内部的, 每一行的最小和最大坐标进行遍历.</p>
<p><strong>jaggies (锯齿)</strong></p>
<h2 id="antialiasing-and-z-buffering">Antialiasing and Z-Buffering</h2>
<p>Aliasing: artifacts to sampling</p>
<ul>
<li>Jagging (锯齿), sampling in space</li>
<li>Moire (摩尔纹), undersampling image</li>
<li>Wagon Wheel effect, sampling in time</li>
</ul>
<p>Reason: 信号变化太快, 采样慢</p>
<p>Antialiasing Idea: Blurring (Pre-Filtering) before sampling
(模糊处理)</p>
<figure>
<img src="sample1.png" alt="blur" />
<figcaption aria-hidden="true">blur</figcaption>
</figure>
<p>Aliasing 的来源: 相同采样频率采样不同函数, 得到的采样点相同.</p>
<figure>
<img src="sampel2.png" alt="aliasing" />
<figcaption aria-hidden="true">aliasing</figcaption>
</figure>
<p>大部分自然图像信号的信息集中在低频, 在变化剧烈处形成边界,
高频所代表的信息大部分是边界.</p>
<ul>
<li>低通滤波器: 大面积色块</li>
<li>高通滤波器: 边界</li>
<li>带通滤波器: 不明所以的东西</li>
</ul>
<p>注: 现实情况是<strong>非理想</strong>滤波.</p>
<p>另一个角度: <strong>滤波</strong> 相当于 <strong>卷积</strong> 或
<strong>平均</strong></p>
<h3 id="antialiasing">Antialiasing</h3>
<p>背景: 一般而言, 直接对原始图像进行三角形光栅化会出现明显的锯齿</p>
<p>减少锯齿的方法: 先对原始图像进行模糊处理, 再进行采样.</p>
<p>步骤: 1. <strong>模糊:</strong> 用某个低通滤波器 (卷积核)
对<strong>原始图像</strong>进行卷积, 例如可以选择 <span
class="math inline">\(1\times 1\)</span> 的低通滤波器,
卷积结果就是在每个像素的灰度平均值; 2. <strong>采样:</strong>
将模糊后的图像的每一个像素对像素中心进行采样</p>
<figure>
<img src="sample3.png" alt="antialiasing" />
<figcaption aria-hidden="true">antialiasing</figcaption>
</figure>
<p>新的问题:
<strong>如何计算光栅三角形在每一个像素里覆盖的区域</strong></p>
<p><strong>MSAA, Antialiasing by Supersampling</strong>:
将像素再进行划分, 划分为多个像素,
最后以子像素在父像素的百分比作为结果.</p>
<ul>
<li>近似 <strong>模糊</strong> 这一步</li>
<li>代价是更大计算量</li>
</ul>
<p>其他抗锯齿方法:</p>
<ul>
<li>FXAA (fast approximete AA)
<ul>
<li>先得到带锯齿的图像, 再进行图像比对找到边界, 并将锯齿去掉</li>
</ul></li>
<li>TAA (temperal AA)
<ul>
<li>复用上一帧提供的信息</li>
</ul></li>
</ul>
<p>其他概念:</p>
<ul>
<li>super resolution / super sampling
<ul>
<li>将低分辨率的图像恢复为高分辨率, 依然解决的是样本不够的问题</li>
<li>DLSS (Deep Learning Super Sampling)</li>
</ul></li>
</ul>
<h3 id="z-buffering">Z-Buffering</h3>
<p><strong>深度缓存</strong>: 解决可见性和遮挡.</p>
<p><strong>Painter's Algorithm</strong>: 将场景物品的深度由远及近排序,
先画最远的物品, 再画较近物品. 其中排序所需要的时间为 <span
class="math inline">\(O(n log n)\)</span></p>
<ul>
<li>问题: 深度如何定义, 相互覆盖如何处理, 深度关系有时候难定义.</li>
<li>因此画家算法一般不用</li>
</ul>
<p><strong>Z-Buffering Algorithm</strong>:
在每个像素中记录当前的最小深度</p>
<ul>
<li>frame buffer stores color value</li>
<li>z-buffer stores depth (e.i. <span
class="math inline">\(|z|\)</span>)</li>
</ul>
<figure>
<img src="zbuf1.png" alt="z-buffer" />
<figcaption aria-hidden="true">z-buffer</figcaption>
</figure>
<p>时间复杂度为 <span class="math inline">\(O(n)\)</span>,
但浮点数判断相等比较复杂</p>
<h3 id="summarize">Summarize</h3>
<figure>
<img src="sum1.png" alt="sum" />
<figcaption aria-hidden="true">sum</figcaption>
</figure>
<h1 id="shading">Shading</h1>
<p><strong>Def:</strong> darkening or coloring of an illustration or
diagram with parallel lines or a block of color.</p>
<ul>
<li>The process of <strong>applying a material</strong> to an object,
considering the interaction with light.</li>
<li>目前只考虑shading, 不考虑Shadow</li>
</ul>
<p><strong>Other terminologies:</strong></p>
<ul>
<li><strong>specular light 高光</strong></li>
<li><strong>diffuse reflection 漫反射</strong></li>
<li><strong>ambient light 间接光照</strong>: 简化为常量</li>
</ul>
<h2 id="blin-phong-reflection-model">Blin-Phong Reflection Model</h2>
<p>简单<strong>漫反射</strong>模型: 设物体表面法向量 <span
class="math inline">\(\vec{n}\)</span> 与光照的 <strong>反方向</strong>
<span class="math inline">\(\vec{l}\)</span> 夹角为 <span
class="math inline">\(\theta\)</span> 且为单位向量, 则</p>
<p><span class="math display">\[
cos \theta = \vec{l} \cdot \vec{n}
\]</span></p>
<p>物体表面接收的光强与 <span class="math inline">\(cos \theta\)</span>
成正比.</p>
<p>设光源为点光源, 传播过程不损失能量, 球面波传播. 则由能量守恒,
距离点光源 <span class="math inline">\(r\)</span> 的球面上一点的强度为
<span class="math inline">\(I/r^2\)</span>, 其中 <span
class="math inline">\(I\)</span> 表示单位球壳上的能量.</p>
<p>因此物体的不同点的光照强度可以表示为</p>
<p><span class="math display">\[
I_p = k_d\frac{I}{r^2}max\{0,\vec{l} \cdot \vec{n}\}
\]</span></p>
<p>其中取最大是考虑: 当光线逆向射过来后<strong>不考虑折射</strong>.</p>
<p>其中 <span class="math inline">\(k_d\)</span> 表示整体的颜色影响, 当
<span class="math inline">\(k_d=0\)</span> 时表示强度为 <span
class="math inline">\(0\)</span>, 此时全黑. 此外, 若是RGB, <span
class="math inline">\(k_d\)</span> 分别取值.</p>
<figure>
<img src="kd.png" alt="kd" />
<figcaption aria-hidden="true">kd</figcaption>
</figure>
<h1 id="geometry">Geometry</h1>
<h1 id="ray-tracing">Ray Tracing</h1>
<h1 id="animation-simulation">Animation / Simulation</h1>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>CG</tag>
        <tag>Lesson</tag>
      </tags>
  </entry>
  <entry>
    <title>人智导论复习</title>
    <url>/2023/01/05/ML/IntroductionToAI/</url>
    <content><![CDATA[<p>"复习课的主旨"</p>
<p>"去看GZQ的PPT"</p>
<span id="more"></span>
<h1 id="绪论">绪论</h1>
<h2 id="什么是人工智能-给出功能模块和方法">什么是人工智能,
给出功能模块和方法</h2>
<ul>
<li>理性的行动的系统
<ul>
<li>方法: 理性Agent方法: <strong>Agent</strong> 是某种能够行动的东西.
<strong>Rational Agent</strong> 可以通过自己的行动获得
<strong>最佳的结果</strong> 或者 在不确定的情况下获得
<strong>最佳期望</strong>, 功能有 <strong>能做正确的推论</strong>,
若没有能证明正确性的事情, 但是必须 <strong>有所行动</strong>.</li>
<li>部分完成理性行动的方法和推论过程无关 (如反射活动)</li>
<li>图灵测试</li>
<li>好处:
<ul>
<li>比"思维法则"方法通用, 正确的推论只是实现理性的方法之一</li>
<li>比人类思维更经得起科学的考验 (可以证伪)</li>
</ul></li>
</ul></li>
</ul>
<h1 id="智能化agent">智能化Agent</h1>
<h2 id="agent架构-理解agent的任务-环境-评价标准">Agent架构,
理解Agent的任务, 环境, 评价标准</h2>
<p><strong>Agent</strong></p>
<ul>
<li>通过传感器感知所处的环境, 通过执行器对环境产生作用</li>
<li>例子 (人类, 机器人, 软件等)</li>
</ul>
<figure>
<img src="agent1.png"
alt="agent的工作原理, 记住. 里面的&quot;?&quot;表示映射函数" />
<figcaption aria-hidden="true">agent的工作原理, 记住.
里面的"?"表示映射函数</figcaption>
</figure>
<p><strong>Agent和环境</strong></p>
<ul>
<li>感知信息: 任何时刻的感知输入</li>
<li>感知序列: 所有的输入数据的完整历史</li>
<li>Agent在任何时刻的行动选择, 取决于到该时刻为止的整个感知序列</li>
<li>Agent函数: 可以用列表表示, 也需要一些抽象的表示</li>
</ul>
<p><strong>性能度量</strong></p>
<ul>
<li>Agent成功程度的标准</li>
</ul>
<p><strong>理性的判断标准</strong></p>
<ul>
<li>PPT, 要记</li>
</ul>
<h2 id="agent的类型">Agent的类型</h2>
<p>不同的Agent区别在于: Agent函数不一样</p>
<ul>
<li><strong>先画图, 再解释</strong></li>
</ul>
<h3 id="简单反射型agent">简单反射型Agent</h3>
<p>可以建造一个通用的 <strong>条件-行动</strong> 规则解释器.
(不包含历史信息, 只根据当天的环境)</p>
<figure>
<img src="agent-type-1.png" alt="agent-type-1" />
<figcaption aria-hidden="true">agent-type-1</figcaption>
</figure>
<h3 id="基于模型的反射型agent">基于模型的反射型Agent</h3>
<p>包含历史信息, 状态信息.</p>
<figure>
<img src="agent-type-2.png" alt="agent-type-2" />
<figcaption aria-hidden="true">agent-type-2</figcaption>
</figure>
<h3 id="基于目标的agent">基于目标的Agent</h3>
<p>不仅需要采用行动, 还需要规定相应的目标.</p>
<figure>
<img src="agent-type-3.png" alt="agent-type-3" />
<figcaption aria-hidden="true">agent-type-3</figcaption>
</figure>
<p>判断执行的动作会不会使得自己离目标更近</p>
<h3 id="基于效用的agent">基于效用的Agent</h3>
<p>单靠目标难以在多数环境中产生更好的行为, 需要更快, 更安全,
更可靠等</p>
<ul>
<li>效用函数: 描述Agent与状态相关的偏好程度,
在目标不充分的情况下有助于理性决策
<ul>
<li>多目标: 加权</li>
<li>存在冲突目标: 折中</li>
</ul></li>
</ul>
<figure>
<img src="agent-type-4.png" alt="agent-type-4" />
<figcaption aria-hidden="true">agent-type-4</figcaption>
</figure>
<h3 id="学习agent">学习Agent</h3>
<ul>
<li>学习元件</li>
<li>执行元件</li>
<li>评价元件</li>
<li>问题产生器</li>
</ul>
<figure>
<img src="agent-type-5.png" alt="agent-type-5" />
<figcaption aria-hidden="true">agent-type-5</figcaption>
</figure>
<h1 id="逻辑agent">逻辑Agent</h1>
<ul>
<li>命题逻辑的语法</li>
<li>推理模式, 方法</li>
<li>怪兽世界的推理 (<span
class="math inline">\(R_1-R_{10}\)</span>的证明, <span
class="math inline">\(R_{11}-R_{15}\)</span>将句子转化成合取范式,
然后基于归结或反证法的证明)</li>
<li>理解推理规则和公理, 用于命题逻辑的推理</li>
<li>命题逻辑的连接符及语义</li>
</ul>
<h2 id="命题逻辑语法">命题逻辑语法</h2>
<figure>
<img src="logic-1.png" alt="logic-1" />
<figcaption aria-hidden="true">logic-1</figcaption>
</figure>
<h2 id="推理模式-推理方法">推理模式, 推理方法</h2>
<ul>
<li>画真值表 (不推荐, 繁琐)</li>
<li>运用公式法则 (重要, 要记)</li>
</ul>
<figure>
<img src="logic-2.png" alt="logic-2" />
<figcaption aria-hidden="true">logic-2</figcaption>
</figure>
<figure>
<img src="logic-3.png" alt="logic-3" />
<figcaption aria-hidden="true">logic-3</figcaption>
</figure>
<ul>
<li>归结 :star: 只能取一项进行归结, 不能同时取很多项,
只用于文字的析取式</li>
<li>合取范式: 文字析取式的合取形式, CNF, <strong>如何转化</strong></li>
</ul>
<h1 id="知识表示">知识表示</h1>
<ul>
<li>情景演算, 情景, 流, 前提条件公理 (可能性公理), 效应公理等概念
(背)</li>
<li>本体论, 类别, 对象, 举例说明 (背)</li>
</ul>
<p>讨论的是 <strong>如何表示世界的事实</strong>,
着重于在不同领域都会出现的通用概念, 如动作, 时间, 物理对象, 信念,
表示这样的抽象概念是 <strong>本体论工程(en?)</strong></p>
<h2 id="本体论工程">本体论工程</h2>
<p>以高某PPT为准</p>
<h2 id="类别和对象">类别和对象</h2>
<p>以高某PPT为准</p>
<h2 id="动作-情景-事件-流">动作, 情景, 事件, 流</h2>
<p>对动作结果的推理是基于知识的Agent运作的中心问题</p>
<h3 id="情景演算本体论">情景演算本体论</h3>
<figure>
<img src="情景演算.png" alt="情景演算" />
<figcaption aria-hidden="true">情景演算</figcaption>
</figure>
<p><strong>流 fluent</strong></p>
<ul>
<li>使情景从一个变换到下一个的函数和谓词, 如Agent的位置或怪兽的死活</li>
</ul>
<p>在定义谓词或函数时, 允许不受时间影响</p>
<h1 id="概率推理">概率推理</h1>
<ul>
<li>贝叶斯网络的定义, 语义</li>
<li>给定贝叶斯网络, 写出相应的联合概率分布</li>
<li>针对书中的盗贼警报任务, 理解贝叶斯网络的精确推理,
并能够在给定证据的情况下进行推理</li>
</ul>
<h2 id="贝叶斯网络的定义和语义">贝叶斯网络的定义和语义</h2>
<p>独立性, 条件独立性, 不确定域中的知识表示</p>
<ul>
<li>减少了所需定义的概率数目</li>
</ul>
<p>有向图, 结点代表概率信息</p>
<ul>
<li>随机变量组成的网络结点</li>
<li>有向边集合</li>
<li>每个结点有条件概率 <span class="math inline">\(P(X_i |
Parents(X_i))\)</span></li>
<li>无环</li>
</ul>
<h1 id="指定简单决策">指定简单决策</h1>
<ul>
<li>理解什么是偏好, 效用, 最大期望效用原则 (计算期望)</li>
<li>理解决策网络, 尤其是网络中的结点类型</li>
<li>给定网络, 计算不同动作的期望效用, 并选具有最大期望效用的动作</li>
</ul>
<h2
id="在不确定性环境下结合信度和愿望">在不确定性环境下结合信度和愿望</h2>
<figure>
<img src="expectation-1.png" alt="expectation-1" />
<figcaption aria-hidden="true">expectation-1</figcaption>
</figure>
]]></content>
  </entry>
  <entry>
    <title>Abording Information</title>
    <url>/2023/01/05/Life/Abording/</url>
    <content><![CDATA[<p>"讲座记录"</p>
<span id="more"></span>
<h1 id="useful-websites">Useful(?) Websites</h1>
<figure>
<img src="websites.png" alt="websites" />
<figcaption aria-hidden="true">websites</figcaption>
</figure>
<h1 id="the-british">The British</h1>
<figure>
<img src="british-level.png" alt="british-level" />
<figcaption aria-hidden="true">british-level</figcaption>
</figure>
<p>越早申请越好</p>
<h2 id="durham-university">Durham University</h2>
<h2 id="university-of-edinburgh">University of Edinburgh</h2>
<h2 id="herior-watt-university">Herior-Watt University</h2>
<h1 id="the-us">The US</h1>
<figure>
<img src="fee.png" alt="fee" />
<figcaption aria-hidden="true">fee</figcaption>
</figure>
<figure>
<img src="US-level.png" alt="US-level" />
<figcaption aria-hidden="true">US-level</figcaption>
</figure>
<p>申请直博免学费?</p>
<p>加拿大备选, 工资不高</p>
<p><img src="" /></p>
<p>套磁时会比较尴尬, 老师回面试说科研问题, 最好有实习, 专业方向的经历,
体现专业能力</p>
<h1 id="hong-kong">Hong Kong</h1>
<figure>
<img src="HongKong-level.png" alt="HongKong-level" />
<figcaption aria-hidden="true">HongKong-level</figcaption>
</figure>
<h1 id="singapore">Singapore</h1>
<figure>
<img src="Singapore.png" alt="Singapore-level" />
<figcaption aria-hidden="true">Singapore-level</figcaption>
</figure>
<h1 id="canada">Canada</h1>
<figure>
<img src="Canada-level.png" alt="Canada-level" />
<figcaption aria-hidden="true">Canada-level</figcaption>
</figure>
<h1 id="europe">Europe</h1>
<figure>
<img src="Europe-level.png" alt="Europe-level" />
<figcaption aria-hidden="true">Europe-level</figcaption>
</figure>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>Abording</tag>
      </tags>
  </entry>
  <entry>
    <title>Image Semantic Segmentation based on UNet</title>
    <url>/2022/08/21/ML/UNet/</url>
    <content><![CDATA[<p>"Semantic segmentation of images, use UNet model."</p>
<span id="more"></span>
<h1 id="abstract">Abstract</h1>
<p>In this project, we realize an basic UNet model and UNet++ model,
then we apply them on image semantic segmentation. We show our basic
theory of UNet and an improvement of it, and we provide main code of
this program. Finally, we give the result of segmentation images,
loss-curve and accuracy-curve on both training and validation set.</p>
<p>The copyright of this program is owned by our team mentioned on the
end of this blog.</p>
<h1 id="unet-structure">UNet Structure</h1>
<p>The <a href="https://arxiv.org/abs/1505.04597">paper</a> published in
2015 propose a noval network structure, whose shape is similar with the
captal "U". The idea comes from FCNN. U-Net is one of the classes of
"Encoder-Decoder" structure.</p>
<figure>
<img src="unet-structure.png" alt="U-Net Structure" />
<figcaption aria-hidden="true">U-Net Structure</figcaption>
</figure>
<p>The front half of the network is "encoder". The input image passes
covolutional kernel, and then passes the pooling layer (or other
dimension-decreasing layer). The opposite of that is the back part of
UNet, the "decoder". The input of decoder is a sequence of feature maps
with highly contracted pixels. The output of the decoder (or the whole
network) is an image with the same shape of input image, where each
pixel has its own class.</p>
<p>In this project, we decrease the number of convolutional layers so
that there are only two convolutional layers in each convolutional
kernel as the dataset includes images with shape <span
class="math inline">\(128\times 256\)</span>.</p>
<h2 id="operator-definitions">Operator Definitions</h2>
<p><strong>Convolutional Kernel:</strong></p>
<p>We define the basic convolutional kernel as follow:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.layer = nn.Sequential(</span><br><span class="line">    <span class="comment"># in_channel, out_channel, kernel_size, stride, padding</span></span><br><span class="line">    <span class="comment"># batch size * channel * height * weight</span></span><br><span class="line">    nn.Conv2d(C_in, C_out, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="number">1</span>),  <span class="comment"># 64 64 128 256</span></span><br><span class="line">    nn.BatchNorm2d(C_out),</span><br><span class="line">    nn.Dropout(<span class="number">0.2</span>),</span><br><span class="line">    nn.LeakyReLU(),</span><br><span class="line"></span><br><span class="line">    nn.Conv2d(C_out, C_out, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="number">1</span>),  <span class="comment"># 64 64 128 256</span></span><br><span class="line">    nn.BatchNorm2d(C_out),</span><br><span class="line">    nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    nn.LeakyReLU(),</span><br></pre></td></tr></table></figure>
<p>It includes two convolution operations.</p>
<p><strong>Down Sampling Kernel:</strong></p>
<p>As for downsampling kernel, we replace conditional pooling layer to
convolutional layer with stride equaling to 2, which means the shape
will be shrunk to <span class="math inline">\(\frac{1}{2}\)</span> while
remaining the same channels.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.Down = nn.Sequential(</span><br><span class="line">    nn.Conv2d(C, C, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="number">1</span>),  <span class="comment"># 64 64 64 128</span></span><br><span class="line">    nn.LeakyReLU()</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p><strong>Up Sampling Kernel:</strong></p>
<p>The basic structure of up-sampling contains only one convolutional
layer with <span class="math inline">\(1\times 1\)</span> convolutional
kernel size and half out-channel. The feature map should pass an
interpolation layer before getting into the convolutional layer.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, C</span>):</span><br><span class="line">    <span class="built_in">super</span>(UpSampling, self).__init__()</span><br><span class="line">    <span class="comment"># out-channel = 1/2 in-channel</span></span><br><span class="line">    self.Up = nn.Conv2d(C, C // <span class="number">2</span>, kernel_size=(<span class="number">1</span>, <span class="number">1</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, r</span>):</span><br><span class="line">    <span class="comment"># neighbor interpolation</span></span><br><span class="line">    up = F.interpolate(x, scale_factor=<span class="number">2</span>, mode=<span class="string">&quot;nearest&quot;</span>)</span><br><span class="line">    x = self.Up(up)</span><br><span class="line">    <span class="comment"># concatenate the feature map in encoder and </span></span><br><span class="line">    <span class="comment"># the feature map in corrsponding decoder layer, in channel dimension</span></span><br><span class="line">    res = torch.cat((x, r), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>The interpolation mode we choose is "nearest". The function
<code>torch.cat(dim=1)</code> is used to concatenate two feature maps in
channel dimension.</p>
<h2 id="network-definition">Network Definition</h2>
<p>Based on the operators defined above, we link these blocks together
like UNet structure.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">super</span>(UNet, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># down sampling</span></span><br><span class="line">    self.C1 = Conv(<span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line">    self.D1 = DownSampling(<span class="number">64</span>)</span><br><span class="line">    self.C2 = Conv(<span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">    self.D2 = DownSampling(<span class="number">128</span>)</span><br><span class="line">    self.C3 = Conv(<span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">    self.D3 = DownSampling(<span class="number">256</span>)</span><br><span class="line">    self.C4 = Conv(<span class="number">256</span>, <span class="number">512</span>)</span><br><span class="line">    self.D4 = DownSampling(<span class="number">512</span>)</span><br><span class="line">    self.C5 = Conv(<span class="number">512</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># up sampling</span></span><br><span class="line">    self.U1 = UpSampling(<span class="number">1024</span>)</span><br><span class="line">    self.C6 = Conv(<span class="number">1024</span>, <span class="number">512</span>)</span><br><span class="line">    self.U2 = UpSampling(<span class="number">512</span>)</span><br><span class="line">    self.C7 = Conv(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">    self.U3 = UpSampling(<span class="number">256</span>)</span><br><span class="line">    self.C8 = Conv(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">    self.U4 = UpSampling(<span class="number">128</span>)</span><br><span class="line">    self.C9 = Conv(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    self.C10 = torch.nn.Conv2d(<span class="number">64</span>, <span class="number">3</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="number">1</span>)</span><br><span class="line">    self.pred = torch.nn.Conv2d(<span class="number">3</span>, <span class="number">34</span>, kernel_size=(<span class="number">1</span>, <span class="number">1</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    self.Th = torch.nn.Sigmoid()</span><br></pre></td></tr></table></figure>
<p>Like U-Net mentioned in that paper, we designed 4 layer deep
network.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># part 1: down sampling, decreasing dimension</span></span><br><span class="line">        R1 = self.C1(x)</span><br><span class="line">        R2 = self.C2(self.D1(R1))</span><br><span class="line">        R3 = self.C3(self.D2(R2))</span><br><span class="line">        R4 = self.C4(self.D3(R3))</span><br><span class="line">        Y1 = self.C5(self.D4(R4))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># part 2: up sampling, connect priori knowledge</span></span><br><span class="line">        O1 = self.C6(self.U1(Y1, R4))</span><br><span class="line">        O2 = self.C7(self.U2(O1, R3))</span><br><span class="line">        O3 = self.C8(self.U3(O2, R2))</span><br><span class="line">        O4 = self.C9(self.U4(O3, R1))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># part 3: active function</span></span><br><span class="line">        <span class="keyword">return</span> self.Th(self.pred(self.C10(O4)))</span><br></pre></td></tr></table></figure>
<p>As you can see, the difference between U-Net and other networks
before U-Net is that U-Net conbines the former information from encoder
and current information from decoder.</p>
<h1 id="code">Code</h1>
<p>During the training process, we want to keep some information of loss
values and accuracy values on training set and validation set so that we
can analyze the variance.</p>
<p>In the function named <code>train()</code>, we take
<code>optimizer</code> and <code>loss</code> as two parameters used in
training process. The outputs of this function are loss and accuracy on
both training set and validation set. If we get the data about training
set and validation set, we can draw the curves. If both training and
validation loss values decrease during training process, we can conclude
that our model converges and does not overfit on training set.</p>
<p>The training code is shown as follow:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.model.train()</span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> self.train_loader:</span><br><span class="line">    batch_num += <span class="number">1</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    rgbs, segs = batch</span><br><span class="line">    s, _, m, n = segs.shape</span><br><span class="line">    segs = torch.reshape(segs, (s, m, n))</span><br><span class="line">    pred_segs = self.model(rgbs).to(self.device)</span><br><span class="line">    loss_val = loss(pred_segs, segs)</span><br><span class="line">    loss_val.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>
<p>The data collecting code can be written as follow:</p>
<p><strong>Statistic data of training set</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ... :</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">if</span> batch_num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            logging.info(<span class="string">f&quot;batch num <span class="subst">&#123;batch_num&#125;</span>, loss <span class="subst">&#123;loss_val&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># delete or add comments when needed</span></span><br><span class="line">        train_loss += loss_val</span><br><span class="line">        <span class="comment"># statistic valid classified samples</span></span><br><span class="line">        total_pix += s * m * n</span><br><span class="line">        idx = torch.argmax(pred_segs, dim=<span class="number">1</span>)</span><br><span class="line">        train_valid_pix += torch.eq(idx, segs).<span class="built_in">sum</span>().<span class="built_in">float</span>().item()</span><br><span class="line">torch.cuda.empty_cache()</span><br><span class="line">epoch_acc = train_valid_pix / total_pix</span><br><span class="line">train_epoch_loss.append(train_loss / batch_num)</span><br><span class="line">train_epoch_acc.append(epoch_acc)</span><br></pre></td></tr></table></figure>
<p><strong>Statistic data of validation set</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> valid_batch <span class="keyword">in</span> self.valid_loader:</span><br><span class="line">        valid_batch_num += <span class="number">1</span></span><br><span class="line">        rgbs, segs = valid_batch</span><br><span class="line">        s, _, m, n = segs.shape</span><br><span class="line">        segs = torch.reshape(segs, (s, m, n))</span><br><span class="line">        pred_segs = self.model(rgbs).to(self.device)</span><br><span class="line">        loss_val = loss(pred_segs, segs)</span><br><span class="line">        valid_loss += loss_val</span><br><span class="line">        valid_total_pix += s * m * n</span><br><span class="line">        idx = torch.argmax(pred_segs, dim=<span class="number">1</span>)</span><br><span class="line">        valid_valid_pix += torch.eq(idx, segs).<span class="built_in">sum</span>().<span class="built_in">float</span>().item()</span><br><span class="line">epoch_acc = valid_valid_pix / valid_total_pix</span><br><span class="line">valid_epoch_loss.append(valid_loss / valid_batch_num)</span><br><span class="line">valid_epoch_acc.append(epoch_acc)</span><br></pre></td></tr></table></figure>
<p>The point you should pay attention to is that you should use
<code>with torch.no_grad()</code> before you do some work that have no
relation with training process, otherwise your GPU memory will be full
or even overflow.</p>
<h1 id="result">Result</h1>
<p>After a long time training, we get the satisfying result with U-Net
model.</p>
<h2 id="former-model">Former Model</h2>
<p>The "former model" infers the U-Net model, and you will see we use
other upgraded model named "UNet++" which will be introduced later.</p>
<p>We output the segmentation results and their uncertainties.</p>
<figure>
<img src="pic1-unet.png" alt="picture 1 result-UNet" />
<figcaption aria-hidden="true">picture 1 result-UNet</figcaption>
</figure>
<h2 id="model-upgrade">Model Upgrade</h2>
<p>For some reasons, we try another U-Net-like model, Nested UNet,
namely UNet++. It has a nested convolutional blocks like a pyramid and
there is a chain passing connectivity between each convolutional block
every layer.</p>
<figure>
<img src="nested.png" alt="Neseted UNet" />
<figcaption aria-hidden="true">Neseted UNet</figcaption>
</figure>
<p>The black nodes are the same with U-Net model. The green nodes are
what Nested UNet newly added. Both green and blue lines are skip
pathways that pass connectivities from encoder to decoder.</p>
<p>The use of Nested UNet gives us a little improvement on final
results.</p>
<figure>
<img src="pic1-nested.png" alt="pictrue 1 result-Nested UNet" />
<figcaption aria-hidden="true">pictrue 1 result-Nested UNet</figcaption>
</figure>
<h1 id="analysis">Analysis</h1>
<h2 id="u-net">U-Net</h2>
<p>We analyze the loss value and accuracy on both training and
validation set:</p>
<figure>
<img src="unet_loss.png" alt="unet loss" />
<figcaption aria-hidden="true">unet loss</figcaption>
</figure>
<p>We find that after 100 epochs, the model has not convergenced yet,
but the loss on validation decreases to the bottom.</p>
<figure>
<img src="unet_acc.png" alt="unet accuracy" />
<figcaption aria-hidden="true">unet accuracy</figcaption>
</figure>
<p>From the accuracy curves, we find that both training set and
validation set have increasing accuracy, which means our model does not
overfit.</p>
<h2 id="nested-unet">Nested UNet</h2>
<p>Meanwhile, we analyze the loss and accuracy of Nested UNet model on
both training and validation set.</p>
<figure>
<img src="nested_loss.png" alt="nested loss" />
<figcaption aria-hidden="true">nested loss</figcaption>
</figure>
<p>We find that Nested UNet has a faster convergency speed than UNet. It
uses only about 60 epochs. But to our surprise, we find that Neseted
UNet overfit after about only 20 epochs because the validation loss does
not decrease anymore.</p>
<figure>
<img src="nested_acc.png" alt="nested accuracy" />
<figcaption aria-hidden="true">nested accuracy</figcaption>
</figure>
<p>The performance on validation accuracy stays the same with UNet
model.</p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Baby Blog</title>
    <url>/2022/01/11/Life/BabyBlog/</url>
    <content><![CDATA[<h2 id="finished-my-first-blog">Finished! My First Blog!</h2>
<p>After a long time deploying my blog webpage and a lot of other
borthering settings, I finally finished it! I mean, FINALLY!!!
:laughing: :laughing: :laughing:</p>
<span id="more"></span>
<h3 id="original-intention">Original Intention</h3>
<p>Can a programmer has no personal blog? I have seen many blogers
writing their own blogs no metter answering a question or just taking
notes from time to time on websites such as <a
href="https://zhihu.com">zhihu</a> and <a
href="https://csdn.net">csdn</a>, but among which I prefer is to
establish a personal website where I can put my blogs on.</p>
<p>So, at first I have no intention about what to do with my site, maybe
I just feel that it's really cool to have such a lovely home for oneself
to "lie down and rest".</p>
<p>But when it was finally established by myself, experencing a lot of
confusing problems and taking amount of time to debug, I must to say
that, I love here, and I believe I will take after it like taking after
a baby, a baby who are growing up. :blush:</p>
<h3 id="thanks">Thanks</h3>
<p>I would not finish my work without the help of JerryYang, whose
helpful blog is the guidance of mine (though there are still some
mistakes maybe? :dizzy_face:). Based on it, I have known some basic
command with Linux, Git and <a href="https://github.com">Github</a>,
which is also beneficial for my lessons next term. Except him I want to
link some videos there to thank for another ups from bilibili:</p>
<p><a
href="https://www.bilibili.com/video/BV1mU4y1j72n?from=search&amp;seid=13163723927059638874&amp;spm_id_from=333.337.0.0">using
hexo to start blog</a></p>
<p><a
href="https://www.bilibili.com/video/BV18z4y197J7?from=search&amp;seid=13163723927059638874&amp;spm_id_from=333.337.0.0">how
to writing blogs</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>今天又是码代码的一天呢</title>
    <url>/2022/10/12/Life/Code/</url>
    <content><![CDATA[<p>"正如标题所言, 今天又是写代码的一天呢"</p>
<p>"哈哈"</p>
<span id="more"></span>
<h1 id="年秋">2022年秋</h1>
<h2 id="disk上的矩阵乘法">Disk上的矩阵乘法</h2>
<hr />
<p>10/16</p>
<p>discription: 由于矩阵太大, 不能一次性load进内存, 希望研究缓存大小,
对矩阵乘法效率的影响.</p>
<p>lang: Cpp</p>
<p>project: 暂未完成</p>
<hr />
<p>本来以为挺简单的一个作业, 没想到这么复杂, 10%的时间在写矩阵乘法,
自以为是地写了个指定嵌套顺序的for循环,
然后发现难点在于文件的读取和写入.</p>
<p><strong>问题 1: 写入时覆盖</strong></p>
<p>由于缓存大小有限, 并且对于特定的for循环顺序,
矩阵可能需要以列的方式写入, 这时候如何定位指针的顺序?</p>
<p><strong>问题 2: 读取时返回</strong></p>
<p>意思是我需要的矩阵的绝对坐标小于此坐标在缓存上的相对坐标(即相对坐标小于0),
这时候需要返回去读取, 但是如果从头开始读取, miss hit 的数目会陡然增加,
如果从当前位置读取, 需要知道上一次指针的位置,
然而上一次的指针已经被更新了, 并且更新的时间不在同一个生命周期.</p>
<p><strong>问题 3: 以上两种情况有可能在读取和写入时都出现</strong></p>
<p><strong>问题 4: 写入时返回需要先读取再写入,
直到下标符合条件</strong></p>
<h2 id="外部快排">外部快排</h2>
<hr />
<p>10/9</p>
<p>discription: use interval heap to realize the priority double ended
queue (PDEQ); use PDEQ to do external sort.</p>
<p>lang: Cpp</p>
<p>project: <a
href="https://github.com/Andrew-Rey/Self-Study-For-Cpp/tree/Final-task/DataStructure/ExternalQuickSort">ExternalQuickSort</a></p>
<hr />
<p>说实话还是第一次写一个六百多行的代码.
虽然不知道用六百行实现一个简单的外部快速排序是否比较能令人接受,
但我还是从中学到了很多东西.</p>
<p><strong>使用STL</strong></p>
<p>以前一般是说说要用STL比较高效, 不过自己看了一些教程以后,
也一直没有什么用武之地, 所以很多东西经常会忘.
然后这份代码里就用了很多的诸如<code>std::deque</code>,
<code>std::vector</code>等一些简单的STL, 当然,
期间还用了一些<code>std::priority_queue</code>,
但是发现并不能实现自己的目标 (能以<span
class="math inline">\(O(1)\)</span>效率返回最大值和最小值),
所以就基于<code>std::deque</code>做了一个interval heap.</p>
<p><strong>官网DOC</strong></p>
<p>以前不太习惯在<a href="https://cplusplus.com/">这里</a>参考资料,
但是终于对网上那些复制粘贴的, 没有思考的blog忍无可忍了,
于是转身求助官网.</p>
<p><strong>CMake</strong></p>
<p>之前自己学了CMake, 这次终于用上了. yysy,
CLion的CMake及时更新还挺好的.</p>
<p><strong>Main</strong></p>
<p>说说主要内容.</p>
<p>这里主要是针对内存大小有限, 希望能对硬盘上的大量数据排序.</p>
<ul>
<li>人为定义宏来规定当前的内存大小 (只关心待排序的数据,
不考虑中间变量)</li>
<li>将内存划分为 Input, Small, Large 和 Middle 四个区. Middle
相当于快排里的pivot, 然后递归对Small和Large排序,
这里使用循环+栈的方式实现递归.</li>
<li>文件读写, 我认为的本项目最繁琐的操作之一. 因为当缓冲区满了以后,
再次写入时, 可能需要保留上一次写入的末尾位置,
所以我新定义了一个栈用来存末尾指针.</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>空间杂谈</title>
    <url>/2022/03/20/Math/%E7%A9%BA%E9%97%B4%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>"内积空间和度量空间有什么区别? Hilbert空间是什么?
它与线性空间的关系是什么?"</p>
<p>"我已经晕了."</p>
<span id="more"></span>
<h1 id="数域">数域</h1>
<p>\(P\)是包含0, 1的数集, 且对 \(P\)中任意两个数的加减乘除运算封闭, 则称
\(P\)是一个数域.</p>
<h1 id="线性空间">线性空间</h1>
<p>在数域的基础上, 我们提出线性空间的概念:</p>
<p>给定数域 \(P\) , 和集合 \(V\). 有如下映射: <span
class="math display">\[
+:V\times V\rightarrow V
\]</span> <span class="math display">\[
\cdot:P\times V\rightarrow V
\]</span> 且 (\(V, P, +, \)) 满足<strong>八条基本性质</strong>,
则\(V\)称为一个线性空间.</p>
<h1 id="赋范空间">赋范空间</h1>
<p><u>赋范空间是定义在线性空间之上的.</u></p>
<p>定义在数域 \(P\) 的线性空间 \(V\) 存在如下映射: <span
class="math display">\[
||\cdot||:  V\rightarrow R
\]</span> 且该映射满足: 正定, 齐次, 三角不等式. 则 \(V\) 是一个赋范空间,
其中映射 \(||||\) 称为范数.</p>
<h1 id="内积空间">内积空间</h1>
<p><u>内积空间是定义在线性空间之上的.</u></p>
<p>定义在数域 \(P\) 的线性空间 \(V\) 存在如下映射: <span
class="math display">\[
\cdot:  V\times V\rightarrow R
\]</span> 则 \(V\) 是一个内积空间.</p>
<p>定义了内积后, 我们可以讨论向量 (即线性空间的元素) 间的长度和夹角,
并进一步讨论正交性等.</p>
<p>注意: 内积本身具有自然定义的范数, 即内积可以诱导出范数, \(||x||=\),
因此内积空间含于赋范空间.</p>
<h1 id="度量空间">度量空间</h1>
<p>度量空间是某个具有距离函数的集合. 该函数定义的是集合内所有元素的距离,
即集合上的某种度量, 即:</p>
给定<strong>集合</strong>\(V\), 有映射: <span class="math display">\[
d:V\times V\rightarrow \mathbf{R}
\]</span> 满足:
<p>
[
<span class="math display">\[\begin{aligned}
&amp;d(x,y)\geq0\quad (d(x,y)=0\Leftrightarrow x=0,y=0)\\
&amp;d(x,y)=d(y,x)\\
&amp;d(x,y)\leq d(x,z)+d(z,y)
\end{aligned}\]</span>
]
</p>
<p>注意: 此处并未要求线性结构.</p>
<p><strong>注意: 赋范空间一定可以诱导出度量空间,
因此赋范空间含于度量空间</strong></p>
<h1 id="完备空间">完备空间</h1>
<p>完备空间又称 Cauchy 空间. <u>完备空间是定义在度量空间之上的.</u></p>
<p>若度量空间 \(M\) 中所有的柯西序列都收敛在 \(M\) 中的一点, 则 \(M\)
是一个完备空间.</p>
<h1 id="hilbert空间">Hilbert空间</h1>
<p>在<strong>内积空间</strong>的基础上增添<strong>完备性条件</strong>,
即得到<strong>Hilbert空间</strong>.</p>
<h1 id="总结">总结</h1>
<p>范数运算+向量空间=(线性)赋范空间</p>
<p>(线性)赋范空间 + 内积运算=内积空间</p>
<p>(线性)赋范空间 + 完备性 = Banach 空间</p>
<p>内积空间 + 完备性 = Hilbert 空间</p>
<p>内积空间 + 完备性 + 有限维 = Euclidean 空间</p>
<h1 id="references">References</h1>
<p>zhihu:</p>
<p>https://www.zhihu.com/question/332144499/answer/731866608</p>
<p>https://www.zhihu.com/question/42312263/answer/699451330</p>
<p>wikipedia:</p>
<p>https://en.wikipedia.org/wiki/Complete_metric_space</p>
<p>https://en.wikipedia.org/wiki/Metric_space</p>
<p>https://en.wikipedia.org/wiki/Cauchy_sequence</p>
<p>https://en.wikipedia.org/wiki/Cauchy_sequence</p>
<p>https://en.wikipedia.org/wiki/Cauchy_sequence</p>
<p>https://en.wikipedia.org/wiki/Normed_vector_space</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>WinterHoliday</title>
    <url>/2022/12/26/Life/WinterHoliday/</url>
    <content><![CDATA[<p>"计划是什么"</p>
<p>"墙上的风景 (即答"</p>
<span id="more"></span>
<h1 id="前言">前言</h1>
<p>首先寒假大概分成三大块吧: <strong>学习, 写代码, 生活</strong>.
方才一想, 发现寒假要做的事情还挺多的, 比如啥 <strong>编译原理</strong>,
然后由于提前回家, 考试推迟, 就导致还要
<strong>准备下学期初的考试</strong>, 然后大作业的话,
<strong>还有操作系统和数据库的两个大作业</strong>,
还有那个所谓的<strong>SRTP</strong>要做, 甚至还要
<strong>准备TOEFL和GRE</strong>, <strong>准备出国的一些事情</strong>,
接着毕竟已经快大四了, 还要去找一些比较好的点, 复现别人成果也好,
自己写代码也好, 都要有一些相应的积累, 另外作为一个计算机学生,
还要修一些必要的课程. 在这闲暇之余, 还希望每天能写一些文字,
整个假期要看一些电影, 要找同学玩, 要做菜.</p>
<h1 id="学习">学习</h1>
<h2 id="编译原理">编译原理</h2>
<p>这必然是最重要的一部分</p>
<ul>
<li>听网课 (主要看语义分析往后的内容), 看龙书 (整体浏览一遍)</li>
<li>写一个半成品的编译器 (具体要求都写到某个README里面去了)</li>
</ul>
<h2 id="每周必做">每周必做</h2>
<p>这里的内容的话, 又多又杂</p>
<ul>
<li>复习某些考试课程
<ul>
<li>主要是一些非计算机课程, 需要每周花一点时间来做, 包括
<strong>自动控制原理</strong>, <strong>近代物理 (热学)</strong>.
人智导论和数据库可以考前一两周的时候复习.</li>
</ul></li>
<li><strong>至少看一部电影</strong></li>
</ul>
<h2 id="每天必做">每天必做</h2>
<p>这里就继续规定一下合理的每天必做的事情</p>
<ul>
<li>写代码: 计算机学生每天写点代码不过分吧</li>
<li><del>矫情文字</del>打卡</li>
<li>看书 (为啥不写看啥啊, <del>因为好多书要看</del>)</li>
</ul>
<h2 id="计算机课程">计算机课程</h2>
<ul>
<li>算法</li>
<li>图形学</li>
</ul>
<h2 id="制定一些ddl">制定一些ddl</h2>
<ul>
<li>数据库最后的大作业听天由命 (毕竟我不是组长, 但我希望快点写完)</li>
<li>操作系统最后一个实验 (这东西你不会还想留到明年吧)</li>
<li>过年前把编译器写<span class="math inline">\(\frac{2}{3}\)</span>
(写完语义分析, 但理论要全学完)</li>
<li>开学前能不能把SRTP搞出个什么东西</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>Schedual</tag>
      </tags>
  </entry>
</search>
