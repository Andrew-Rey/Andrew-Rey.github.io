[{"title":"【算法】基本数据结构","url":"/2023/06/13/Algorithm/ds/","content":"“基本数据结构”\n\n 栈\n\nLIFO表\n\n\nC++数组模拟栈\n\nint st[N];// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标// 压栈 ：st[++*st] = var1;// 取栈顶 ：int u = st[*st];// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出if (*st) --*st;// 清空栈*st = 0;\n 队列\n\nFIFO表\n\n\nc++数组模拟队列\n\nint q[SIZE], ql = 1, qr;// 插入元素q[++qr] = x;// 删除元素ql++;// 访问队首q[qr];// 访问队尾q[ql];//清空队列ql = 1;qr = 0;\n\n双栈模拟队列：两个栈模拟一个队列，队尾的栈为F，队首的栈为S\n\npush：插入到栈F中\npop：如果S非空，让S弹栈；否则先把F的元素倒过来压入S中，然后让S弹栈\n\n\n 双端队列\n\n可以在队首/队尾插入或删除元素的队列。相当于是栈与队列功能的结合。具体地，双端队列支持的操作有 4 个\n\n在队首插入一个元素\n在队尾插入一个元素\n在队首删除一个元素\n在队尾删除一个元素\n\n\n 循环队列\n\n使用数组模拟队列会导致一个问题：随着时间的推移，整个队列会向数组的尾部移动，一旦到达数组的最末端，即使数组的前端还有空闲位置，再进行入队操作也会导致溢出（这种数组里实际有空闲位置而发生了上溢的现象被称为「假溢出」）。\n解决假溢出的办法是采用循环的方式来组织存放队列元素的数组，即将数组下标为 0 的位置看做是最后一个位置的后继。（数组下标为 x 的元素，它的后继为 (x + 1) % SIZE）。这样就形成了循环队列。\n来自OIWiki\n\n 链表\n 单向链表\nstruct Node &#123;  int value;  Node *next;&#125;;\n\n删除结点p\n实际上是删除p+1：将p+1的值赋给p，p的next指向p的next的next，删除p+1\n\n 双向链表\nstruct Node &#123;  int value;  Node *left;  Node *right;&#125;;\n 单向循环链表\n\n将单向链表的头尾相连接。注意： 插入数据时要判断原链表是否为空；为空则自身循环，不为空则正常插入\n\n为空则插入的数据node的指针和链表指针都指向自己\n不为空则和单向链表一致\n\n\n 双向循环链表\n\n插入数据时，注意要修改左右指针\n\n 异或链表\n\n本质上还是双向链表：利用按位异或的值，仅用一个指针的内存大小实现双向链表的功能\n\n在结点node中定义lr = left_addr ^ right_addr\n访问left：lr ^ right_addr\n访问right：lr ^ left_addr\n\n异或自反：A ^ B ^ B = A ^ (B ^ B) = A ^ 0 = A\n\n 哈希表\nkey→valuekey\\rightarrow value\nkey→value\n\n哈希函数：把key映射到索引空间，f(key)是一个可以作为数组下标的整数\n\n整数为key：使用整数作为key的时候，如果整数范围小，直接将key作为索引；若范围较大（10910^9109）则 一般把键值模一个较大的质数作为索引 f(x)=x mod Mf(x)=x\\ mod\\ Mf(x)=x mod M作为哈希函数\n字符串为key：先将字符串哈希，再将哈希结果作为key：可以把字符串当作长度为n的进制为127的数（x=s0∗1270+s1∗1271+⋯+sn∗127nx=s_0*127^0+s_1*127^1+\\cdots+s_n*127^nx=s0​∗1270+s1​∗1271+⋯+sn​∗127n），将得到的xxx对2642^{64}264取模（unsigned long long最大值）。\n\n容易冲突\n使用双哈希：选取两个大质数，当两个字符串的哈希值对两个大质数模相等时，才认为相等。\n\n\n\n\n 冲突\n\n拉链法：在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，则放到链表内部即可。如果索引的范围是1⋯M1\\cdots M1⋯M，哈希表的大小为NNN，则一次插入或查询的期望比较次数为O(NM)O(\\frac{N}{M})O(MN​)\n\n\n闭散列法：把所有记录直接存储在散列表中，如果冲突则以某种规则检查\n\n线性探查法：在d处冲突，则依次检查d+1，d+2.\n\n\n 并查集\n\n参考\n\n\n用于管理元素所属集合的数据结构，实现为一个森林，每棵树表示一个集合，节点表示对应集合中的元素\n\n合并：合并两个元素的所属集合\n查询：查询某个元素所属集合（查询根节点），用于判断两个元素是否在同一集合\n\n\n\n结构：一个数组，存储每个元素的父结点\n\n\n初始化：初始时，每个结点以自己作为父结点\n\nint fa[MAXN];inline void init(int n) &#123;    for (int i = 1; i &lt;= n; ++i)        fa[i] = i;&#125;\n\n**合并：**先找到两个结点的根节点，然后将某一个设置为根节点（下面的代码将j的父结点设置为i的父结点）\n\ninline void merge(int i, int j) &#123;    fa[find(i)] = find(j);&#125;\n\n**查询：**两个结点是否在同一个集合取决于根节点是否相同（递归往上查询）\n\nint find(int x) &#123;    if(fa[x] == x) return x;    else return find(fa[x]);&#125;\n\n 路径压缩\n\n由于构建以后的深度可能比较深，会影响查询的效率，因此可以考虑路径压缩，把属于该集合的元素直接连接到根结点。\n压缩这一步是在查询的时候顺便解决的\n\nsize_t dsu::find(size_t x) &#123; return pa[x] == x ? x : pa[x] = find(pa[x]); &#125;\n 启发式合并\n\n将节点较少或深度较少的树连接到另一棵\n\n 删除\n\n可以将其根节点设置为自己（为了保证删除的都是叶子结点，可以将其副本作为根节点）\n\n 移动\n\n将副本作为根节点\n\n 复杂度\n\n时间复杂度：O(α(n))O(\\alpha(n))O(α(n))，α\\alphaα是阿克曼函数反函数，增长极其缓慢\n\n\n空间复杂度：O(n)O(n)O(n)\n\n 带权并查集\n\n在并查集的边上定义某种权值、以及这种权值在路径压缩时产生的运算，从而解决更多的问题\n\n 应用\nOIWiki\n 堆\n 二叉堆\n\n\n完全二叉树\n父亲的权值不小于儿子的权值（大根堆）\n由堆性质，树根存的是最大值（getmax 操作就解决了）\n\n\n\n插入\n\n最下一层最右边的叶子之后插入\n向上调整：如果这个结点的权值大于它父亲的权值，就交换，重复此过程直到不满足或者到根\nO(log(n))O(log(n))O(log(n))\n\n\n\n删除\n\n删除根节点：考虑插入操作的逆过程，设法将根结点移到最后一个结点，然后直接删掉。通常采用的方法是，把根结点和最后一个结点直接交换\n向下调整：在该结点的儿子中，找一个最大的，与该结点交换，重复此过程直到底层\nO(log(n))O(log(n))O(log(n))\n\n\n// 向上调整void up(int x) &#123;  while (x &gt; 1 &amp;&amp; h[x] &gt; h[x / 2]) &#123;    swap(h[x], h[x / 2]);    x /= 2;  &#125;&#125;// 向下调整void down(int x) &#123;  while (x * 2 &lt;= n) &#123;    t = x * 2;    if (t + 1 &lt;= n &amp;&amp; h[t + 1] &gt; h[t]) t++;    if (h[t] &lt;= h[x]) break;    std::swap(h[x], h[t]);    x = t;  &#125;&#125;\n\n建堆\n\n向下调整：从叶子开始，逐个向下调整\nO(n)O(n)O(n)\n由于叶子节点不用调整，因此可以从n/2n/2n/2的地方开始调整\n\n\nvoid build_heap_2() &#123;  for (i = n; i &gt;= 1; i--) down(i);&#125;\n 配对堆\n\n\n支持插入，查询/删除最小值，合并，修改元素\n可并堆\n基于势能分析\n不能可持久化\n带权多叉树\n满足堆的性质：每个节点的值都小于或等于他的所有孩子（小根堆）\n不一定是完全的\nchild-sibling表示法\n\n\n\nstruct Node &#123;  T v;  // T为权值类型  Node *child, *sibling;  // child 指向该节点第一个儿子，sibling 指向该节点的下一个兄弟。  // 若该节点没有儿子/下个兄弟则指针指向 nullptr。&#125;;\n\nchild-sibling表示法：\n一个节点的所有儿子节点形成一个单向链表。每个节点储存第一个儿子的指针，即链表的头节点；和他的右兄弟的指针\n\n\n查询最小值：直接返回根节点（权值）\n\n\n合并\n\n找到两个根节点的较小者，将较大的根节点作为其孩子插入进去\n孩子链表按插入时间排序，最右边的节点最早成为父节点的孩子，最左边最近成为孩子\n\n\n\nNode* meld(Node* x, Node* y) &#123;  // 若有一个为空则直接返回另一个  if (x == nullptr) return y;  if (y == nullptr) return x;  if (x-&gt;v &gt; y-&gt;v) std::swap(x, y);  // swap后x为权值小的堆，y为权值大的堆  // 将y设为x的儿子  y-&gt;sibling = x-&gt;child;  x-&gt;child = y;  return x;  // 新的根节点为 x&#125;\n\n插入：把新元素视为一个配对堆即可\n\n\n删除最小值（根节点）\n\n把根节点的孩子们两两配对合并\n将新产生的森林从右向左（旧的向新的方向）合并\n\n\n","categories":["CS"],"tags":["CS","Algorithm","Data Structure"]},{"title":"【算法】快速傅里叶变换$FFT$","url":"/2022/04/06/Algorithm/fft/","content":"“对称，万变不离其中”\n\n 多项式乘积问题\n首先来思考这样的一个问题:\n\n Question 1\n你有两个多项式函数:\np(x)=2x3+x+1p(x)=2x^3+x+1\np(x)=2x3+x+1\nq(x)=x2+4x+5q(x)=x^2+4x+5\nq(x)=x2+4x+5\n应该如何计算它们的乘积?\n\n当然, 我不是说要用笔算的方式, 而是用计算机. 显然这个问题我们在小学二年级就写过的, 当初正在学习&quot;数据结构&quot;这门课, 如果没记错, 应该是用链表实现的.\n但是, 就算是用链表实现, 那不也是和手算一样的原理吗?\n\n将二者相乘\n分配律\n合并同类项\n\n例如上面那个例子:\n\n solution 1\n\\begin{align*}\n    r(x) &amp;= (2x^3+x+1)(x^2+4x+5) \\\\\n    &amp;= 2x^5+8x^4+10x^3+x^3+4x^2+5x+x^2+4x+5 \\\\\n    &amp;= 2x^5+8x^4+11x^3+5x^2+5x+5\n\\end{align*}\n\n\n(???是什么动力让我深夜在这里口算多项式乘法???)\n显然, 如果一个 n 次多项式乘上一个 m 次多项式, 在合并同类项前应该有 n×mn\\times mn×m 次多项式, 这谁顶得住? 对于正常人类而言显然顶不住, 对于计算机而言, 时间复杂度是O(n2)O(n^2)O(n2), 也是算比较大的开销了吧.\n咋办?\n 点表示法\n 开始\n有谁规定, 我多项式一定是用系数表示的?\n好家伙, 你这样说我就摸不着头脑了, 难道除了系数表示还有其他表示方法吗?\n首先, 多项式集合其实是构成了一个线性空间, 也就是说, 任意两个多项式进行线性运算 (加法和数乘) 后, 结果仍然是多项式. 事实上\n1,x,x2,…,xn,…{1, x, x^2, \\dots, x^n, \\dots}\n1,x,x2,…,xn,…\n构成了该空间的一组基, 将函数展开成 Taylor 级数便用了这组基作为基底, 基前面的系数也就是坐标.\n其次, 对于一个 n 次多项式而言, 只要我们确定了它的坐标, 就能唯一确定这个多项式. 现在的问题是不知道坐标, 如何确定多项式. 这里的巧妙之处就在于, 多项式函数是一个映射, 对于一个特定的 x, 总是能给出唯一一个值与之对应, 这不就是一个方程吗?\n我给你一个 x, 你输出一个值, 同时由于多项式系数全部未知, 这就是一个关于 n+1n+1n+1 个系数的方程\n显然, 我需要 n+1n+1n+1 个不同的点来唯一确定我的系数. 这就是所谓的点表示法. 这样一来, 我们将这 n+1n+1n+1 个方程写成矩阵形式:\n[p0p1⋮pn]=[1x0…x0n1x1…x1n⋮⋮⋮1xn…xnn][c0c1⋮cn]\\begin{bmatrix}\np_0 \\\\\np_1 \\\\\n\\vdots \\\\\np_n\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1\\quad &amp; x_0\\quad &amp; \\dots\\quad &amp; x_0^n \\\\\n1\\quad &amp; x_1\\quad &amp; \\dots\\quad &amp; x_1^n \\\\\n\\vdots\\quad &amp; \\vdots\\quad &amp; \\quad &amp; \\vdots \\\\\n1\\quad &amp; x_n\\quad &amp; \\dots\\quad &amp; x_n^n\n\\end{bmatrix}\n\\begin{bmatrix}\nc_0 \\\\\nc_1 \\\\\n\\vdots \\\\\nc_n\n\\end{bmatrix}\n⎣⎢⎢⎢⎢⎡​p0​p1​⋮pn​​⎦⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎡​11⋮1​x0​x1​⋮xn​​………​x0n​x1n​⋮xnn​​⎦⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎡​c0​c1​⋮cn​​⎦⎥⎥⎥⎥⎤​\n看到这里我终于理解了为什么在学高等代数时要突然讲一个范德蒙德(Vandermonde)行列式, 也就是这里的\n[1x0…x0n1x1…x1n⋮⋮⋮1xn…xnn]\\left[\n\\begin{aligned}\n1\\quad &amp; x_0\\quad &amp; \\dots\\quad &amp; x_0^n \\\\\n1\\quad &amp; x_1\\quad &amp; \\dots\\quad &amp; x_1^n \\\\\n\\vdots\\quad &amp; \\vdots\\quad &amp; \\quad &amp; \\vdots \\\\\n1\\quad &amp; x_n\\quad &amp; \\dots\\quad &amp; x_n^n\n\\end{aligned}\n\\right]\n⎣⎢⎢⎢⎢⎢⎢⎡​11⋮1​x0​x1​⋮xn​​………​x0n​x1n​⋮xnn​​⎦⎥⎥⎥⎥⎥⎥⎤​\n将上述矩阵定义为我们最喜欢的字母AAA.\n好, 既然这东西是范德蒙德行列式, 那我们可以知道它行列式∣A∣=∏0≤j&lt;i≤n(xi−xj)|A|=\\prod_{0\\leq j&lt; i\\leq n}(x_i-x_j)∣A∣=∏0≤j&lt;i≤n​(xi​−xj​)不为 0, 也就是说, 这个矩阵是可逆的, 也就是当我们取 n+1n+1n+1 个不同点时, 确实是可以使方程组有唯一解, 也就是 n+1n+1n+1 个点可以唯一表示一个 n 次多项式.\n 乘法\n问题来了, 如何做乘法?\n我们有 n 次多项式和 m 次多项式做乘法, 得到的是一个 n+mn+mn+m 次多项式, 那么我们只要找到 n+m+1n+m+1n+m+1 个点即可, 也就是只要在 n 次多项式和 m 次多项式中分别找 n+m+1n + m + 1n+m+1 个点, 这些点的横坐标 x 相等, 再将对应的函数值相乘即可.\n 进一步\n现在, 我们知道了如何用点表示多项式, 以及如何用点表示进行乘法运算. 但是仔细一想, 这种方法需要求解线性方程组, 这里的计算复杂度并不低. 也就是从系数表示法到点表示法的转化过程带来的计算复杂度还是很高的.\n有什么方法可以进行简化吗?\n先等一等, 我们先来梳理我们用点表示求多项式乘法的思路:\n\n MainIdea\n\n将 n 次多项式和 m 次多项式分别从系数表示转化为点表示\n对应点相乘\n将得到的 n+m+1n+m+1n+m+1 个点表示的多项式转化为系数表示\n\n\n 奇偶\n先来考虑简单的情况:\n\n Question 2\n多项式\np(x)=x2\np(x) = x^2\np(x)=x2\n和多项式\nq(x)=x3\nq(x)=x^3\nq(x)=x3\n用点表示法相乘\n\n那我们当然是按部就班地进行乘法啦~\n\n由于结果是 5 次多项式, 因此对p(x)p(x)p(x)取 5 个点, 对q(x)q(x)q(x)取 5 个点.\n\n取点, 说得轻巧, 做起来倒是挺犹豫的. 取什么样的点能满足要求呢? 或者得寸进尺地说, 什么样的点能让效率更高呢? 注意到二次函数是对称的, 那我们是不是只要取正的 2 个点, 就能知道负的 2 个点, 另外加一个原点?\n确实如此.\n那三次多项式呢? 照理来说, 我们同样也是只要取一半的点就能知道另一半点的值(这里的&quot;一半&quot;针对正负而言), 只不过要在函数值上添加负号, 何必呢? 还不如干脆 提出一个 x, 然后不也变成了二次函数?\n事实上, 一般而言, 我们要用点表示法表示多项式, 可以用如下方法:\n\n Method1\np(x)=∑i=1ncixi=Pe(x)+Po(x)=Pe1(x)+xPe2(x)p(x)=\\sum_{i=1}^n c_ix^i=P_e(x)+P_o(x)=P_{e1}(x)+xP_{e2}(x)\np(x)=i=1∑n​ci​xi=Pe​(x)+Po​(x)=Pe1​(x)+xPe2​(x)\n其中, Pei(x)P_{ei}(x)Pei​(x)表示只含偶次的多项式函数, Po(x)P_o(x)Po​(x)表示只含奇次的多项式.\n\n这样, 我们只要在非负轴上取值就可以确定整个多项式, 取点的个数是 原来的一半.\n甚至, 这里形成了一个 递归 算法: 分解后的Pei(x)P_{ei}(x)Pei​(x)不也是一个关于 x 的多项式吗?! 那我继续啊, 把Pei(x)P_{ei}(x)Pei​(x)继续分解啊, 大事化小, 小事化了.\n等等!\n我们的Pei(x)P_{ei}(x)Pei​(x)其实是Pei(x2)P_{ei}(x^2)Pei​(x2), 这里每个x2x^2x2都是非负的啊. 未来我们只能在非负轴取值了, 也就是说, 分解为偶次多项式后, 递归停止了.\n完蛋.\n 复数域分解\n“山重水复疑无路, 柳暗花明又一村”\n看到标题就已经知道要怎么做了. 既然在实数域上无法继续分解Pei(x2)P_{ei}(x^2)Pei​(x2), 那为何不去复数域呢?\n在复数域上我们可以快乐地进行递归.\n如何个快乐法呢? 我们来细品:\n\n 偶次多项式在复平面上的根\n为什么突然变成了 求根?\n从第二节中&quot;奇偶&quot;, 我们可以选取对称的点, 来减少选取点的个数(即原来的一半). 接着我们把任意 n 次多项式分解成两个偶次多项式, 偶次多项式的好处在于容易选取对称的点. 但是由于在实数范围内, 在对偶次多项式进行递归时会发生中断, 于是我们扩展至复数域讨论分解.\n方便起见: 对于x0x^0x0, 我们取x=1x=1x=1作为特征点, 对于x2x^2x2, 我们取x=1,x=−1,x=0x=1, x=-1, x=0x=1,x=−1,x=0作为三个特征点, 那对于x4x^4x4, 我们应该怎样取点, 抛开x=0x=0x=0不谈, 令x4=1x^4=1x4=1, 由 代数基本定理, 该方程在复数域上有 4 个 根, 对于其它偶次多项式我们以此类推.\n就这样, 我们找到了一个简单的方法寻找所有需要的点, 进行递归.\n 单位根\n写到这里, 我也感觉有点吃力, 关键是为什么一定就取了令x2k=1x^{2k}=1x2k=1呢?\n虽然但是, 确实是所谓的&quot;方便起见&quot;, 这是因为, 取了&quot;1&quot;, 我们可以在复平面上的单位圆上讨论这个问题.\n在小学二年级我们就知道, xn=1x^{n}=1xn=1的根可以用我们熟悉的ω\\omegaω的幂来表示, 即\nω=e2kπni(k=0,1,…,n−1)\\omega = e^{\\frac{2k\\pi}{n}i}\\qquad(k=0,1,\\dots,n-1)\nω=en2kπ​i(k=0,1,…,n−1)\n这些nnn个点在复平面单位圆上 对称分布. 每递归一次, 单位根的数量减少一半, 但保持对称性不变.\n确实方便.\n\n 快速傅里叶变换(FFT)\n终于能正式地介绍世界上最美丽的算法了: 快速傅里叶变换(FFT). FFT解决的是多项式从系数表示到点表示的过程中, 计算复杂度的问题.\n 框架\n分解:\np(x)=∑k=0nckxk=Pe1(x2)+xPe2(x2):=[ω0,ω1,…,ωn]p(x)=\\sum_{k=0}^nc_kx^k=P_{e1}(x^2)+xP_{e2}(x^2):=[ \\omega^0, \\omega^1, \\dots, \\omega^n] \np(x)=k=0∑n​ck​xk=Pe1​(x2)+xPe2​(x2):=[ω0,ω1,…,ωn]\n递归:\nP_e1(x2)=P′_e1(x4)+xP′_e2(x4):=[ω0,ω1,…,ωn−1]P\\_{e1}(x^2) = P^{\\prime}\\_{e1}(x^4)+xP^{\\prime}\\_{e2}(x^4):=[\\omega^0, \\omega^1, \\dots, \\omega^{n-1}] \nP_e1(x2)=P′_e1(x4)+xP′_e2(x4):=[ω0,ω1,…,ωn−1]\nP_e2(x2)=P′_e1(x4)+xP′_e2(x4):=[ω0,ω1,…,ωn−1]P\\_{e2}(x^2) = P^{\\prime}\\_{e1}(x^4)+xP^{\\prime}\\_{e2}(x^4):=[\\omega^0, \\omega^1, \\dots, \\omega^{n-1}] \nP_e2(x2)=P′_e1(x4)+xP′_e2(x4):=[ω0,ω1,…,ωn−1]\n加和:\nP(ωj)=P_e1(ωj)+ωjP_e2(ωj)P(\\omega^j)=P\\_{e1}(\\omega^{j})+\\omega^jP\\_{e2}(\\omega^j) \nP(ωj)=P_e1(ωj)+ωjP_e2(ωj)\nP(ωj+n/2)=P_e1(ωj+n/2)+ωj+n/2P_e2(ωj+n/2)P(\\omega^{j+n/2})=P\\_{e1}(\\omega^{j+n/2})+\\omega^{j+n/2}P\\_{e2}(\\omega^{j+n/2}) \nP(ωj+n/2)=P_e1(ωj+n/2)+ωj+n/2P_e2(ωj+n/2)\nj∈[0,1,…,n/2+1]j\\in[0,1,\\dots, n/2+1]j∈[0,1,…,n/2+1]\n返回p(x)p(x)p(x)\n时间复杂度为: O(nlog2n)O(nlog_2n)O(nlog2​n)\n 一些数学\n\n[p0p1⋮pn]=[1x0…x0n1x1…x1n⋮⋮⋮1xn…xnn][c0c1⋮cn]\\left[\n\\begin{aligned}\np_0 \\\\\np_1 \\\\\n\\vdots \\\\\np_n\n\\end{aligned}\\right]\n=\n\\left[\n\\begin{aligned}\n1\\quad &amp; x_0\\quad &amp; \\dots\\quad &amp; x_0^n \\\\\n1\\quad &amp; x_1\\quad &amp; \\dots\\quad &amp; x_1^n \\\\\n\\vdots\\quad &amp; \\vdots\\quad &amp; \\quad &amp; \\vdots \\\\\n1\\quad &amp; x_n\\quad &amp; \\dots\\quad &amp; x_n^n\n\\end{aligned}\n\\right]\n\\left[\n\\begin{aligned}\nc_0 \\\\\nc_1 \\\\\n\\vdots \\\\\nc_n\n\\end{aligned}\\right] \n⎣⎢⎢⎢⎢⎢⎢⎡​p0​p1​⋮pn​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎡​11⋮1​x0​x1​⋮xn​​………​x0n​x1n​⋮xnn​​⎦⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​c0​c1​⋮cn​​⎦⎥⎥⎥⎥⎥⎥⎤​\n我们在复数域上考虑, 令\nxk=ωk,where  ω=e2kπnx_k=\\omega^k,\\quad where\\ \\ \\omega=e^{\\frac{2k\\pi}{n}}\nxk​=ωk,where  ω=en2kπ​\n(这是因为, 我们希望多项式在复数域上考虑时, 我们可以在单位圆周上讨论. 其中xkx_kxk​表示我们取的第 k 个点, 刚好与 ωk\\omega^kωk是对应的.)\n则线性方程组可以化为:\n[p0p1⋮pn]=[[c]111…11ωω2…ωn1ω2ω4…ω2n⋮⋮⋮⋮1ωnω2n…ωn×n][c0c1⋮cn]\\left[\n\\begin{aligned}\np_0 \\\\\np_1 \\\\\n\\vdots \\\\\np_n\n\\end{aligned}\\right]\n=\n\\left[\n\\begin{aligned}[c]\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp; \\dots\\quad &amp; 1 \\\\\n1\\quad      &amp; \\omega\\quad   &amp; \\omega^2\\quad          &amp; \\dots\\quad &amp; \\omega^n \\\\\n1\\quad      &amp; \\omega^2\\quad &amp; \\omega^4\\quad          &amp; \\dots\\quad &amp; \\omega^{2n} \\\\\n\\vdots\\quad &amp; \\vdots\\quad   &amp; \\vdots\\quad       &amp;            &amp; \\vdots \\\\\n1\\quad      &amp; \\omega^n\\quad &amp; \\omega^{2n}\\quad  &amp; \\dots\\quad &amp; \\omega^{n\\times n}\n\\end{aligned}\n\\right]\n\\left[\n\\begin{aligned}\nc_0 \\\\\nc_1 \\\\\n\\vdots \\\\\nc_n\n\\end{aligned}\\right] \n⎣⎢⎢⎢⎢⎢⎢⎡​p0​p1​⋮pn​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​[c]111⋮1​1ωω2⋮ωn​1ω2ω4⋮ω2n​…………​1ωnω2n⋮ωn×n​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​c0​c1​⋮cn​​⎦⎥⎥⎥⎥⎥⎥⎤​\n其中\n[[c]111…11ωω2…ωn1ω2ω4…ω2n⋮⋮⋮⋮1ωnω2n…ωn×n] \\left[\n\\begin{aligned}[c]\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp; \\dots\\quad &amp; 1 \\\\\n1\\quad      &amp; \\omega\\quad   &amp; \\omega^2\\quad          &amp; \\dots\\quad &amp; \\omega^n \\\\\n1\\quad      &amp; \\omega^2\\quad &amp; \\omega^4\\quad          &amp; \\dots\\quad &amp; \\omega^{2n} \\\\\n\\vdots\\quad &amp; \\vdots\\quad   &amp; \\vdots\\quad       &amp;            &amp; \\vdots \\\\\n1\\quad      &amp; \\omega^n\\quad &amp; \\omega^{2n}\\quad  &amp; \\dots\\quad &amp; \\omega^{n\\times n}\n\\end{aligned}\n\\right] \n⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​[c]111⋮1​1ωω2⋮ωn​1ω2ω4⋮ω2n​…………​1ωnω2n⋮ωn×n​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​\n称为**离散傅里叶变换矩阵(DFT)**显然该矩阵是 对称的 且 可逆, 其逆矩阵为:\n1n[[c]111…11ω−1ω−2…ω−n1ω−2ω−4…ω−2n⋮⋮⋮⋮1ω−nω−2n…ω−n×n]\\frac{1}{n}\n \\left[\n\\begin{aligned}[c]\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp; \\dots\\quad &amp; 1 \\\\\n1\\quad      &amp; \\omega^{-1}\\quad   &amp; \\omega^{-2}\\quad          &amp; \\dots\\quad &amp; \\omega^{-n} \\\\\n1\\quad      &amp; \\omega^{-2}\\quad &amp; \\omega^{-4}\\quad          &amp; \\dots\\quad &amp; \\omega^{-2n} \\\\\n\\vdots\\quad &amp; \\vdots\\quad   &amp; \\vdots\\quad       &amp;            &amp; \\vdots \\\\\n1\\quad      &amp; \\omega^{-n}\\quad &amp; \\omega^{-2n}\\quad  &amp; \\dots\\quad &amp; \\omega^{-n\\times n}\n\\end{aligned}\n\\right]   \nn1​⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​[c]111⋮1​1ω−1ω−2⋮ω−n​1ω−2ω−4⋮ω−2n​…………​1ω−nω−2n⋮ω−n×n​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​\n并且, 该逆矩阵看起来和原矩阵 一模一样!\n.\n\n 结束了?\n当我们乐呵呵地把FFT转化为代码时, 开心的分解多项式, 然后选点, 相乘, 等等! 你还没告诉我, 怎么从点表示转化回系数表示呢!\n这就是FFT对称的魅力了. 由点求系数, 不过是矩阵求逆的过程:\n[c0c1⋮cn]=[[c]111…11ωω2…ωn1ω2ω4…ω2n⋮⋮⋮⋮1ωnω2n…ωn×n]−1[p0p1⋮pn]=1n[[c]111…11ω−1ω−2…ω−n1ω−2ω−4…ω−2n⋮⋮⋮⋮1ω−nω−2n…ω−n×n][p0p1⋮pn]\\left[\n\\begin{aligned}\nc_0 \\\\\nc_1 \\\\\n\\vdots \\\\\nc_n\n\\end{aligned}\\right]\n=\n\\left[\n\\begin{aligned}[c]\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp; \\dots\\quad &amp; 1 \\\\\n1\\quad      &amp; \\omega\\quad   &amp; \\omega^2\\quad          &amp; \\dots\\quad &amp; \\omega^n \\\\\n1\\quad      &amp; \\omega^2\\quad &amp; \\omega^4\\quad          &amp; \\dots\\quad &amp; \\omega^{2n} \\\\\n\\vdots\\quad &amp; \\vdots\\quad   &amp; \\vdots\\quad       &amp;            &amp; \\vdots \\\\\n1\\quad      &amp; \\omega^n\\quad &amp; \\omega^{2n}\\quad  &amp; \\dots\\quad &amp; \\omega^{n\\times n}\n\\end{aligned}\n\\right]^{-1}\n\\left[\n\\begin{aligned}\np_0 \\\\\np_1 \\\\\n\\vdots \\\\\np_n\n\\end{aligned}\\right] \\\\\n=\\frac{1}{n}\n \\left[\n\\begin{aligned}[c]\n1\\quad      &amp; 1\\quad        &amp; 1\\quad                 &amp; \\dots\\quad &amp; 1 \\\\\n1\\quad      &amp; \\omega^{-1}\\quad   &amp; \\omega^{-2}\\quad          &amp; \\dots\\quad &amp; \\omega^{-n} \\\\\n1\\quad      &amp; \\omega^{-2}\\quad &amp; \\omega^{-4}\\quad          &amp; \\dots\\quad &amp; \\omega^{-2n} \\\\\n\\vdots\\quad &amp; \\vdots\\quad   &amp; \\vdots\\quad       &amp;            &amp; \\vdots \\\\\n1\\quad      &amp; \\omega^{-n}\\quad &amp; \\omega^{-2n}\\quad  &amp; \\dots\\quad &amp; \\omega^{-n\\times n}\n\\end{aligned}\n\\right] \n\\left[\n\\begin{aligned}\np_0 \\\\\np_1 \\\\\n\\vdots \\\\\np_n\n\\end{aligned}\\right] \n⎣⎢⎢⎢⎢⎢⎢⎡​c0​c1​⋮cn​​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​[c]111⋮1​1ωω2⋮ωn​1ω2ω4⋮ω2n​…………​1ωnω2n⋮ωn×n​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​−1⎣⎢⎢⎢⎢⎢⎢⎡​p0​p1​⋮pn​​⎦⎥⎥⎥⎥⎥⎥⎤​=n1​⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​[c]111⋮1​1ω−1ω−2⋮ω−n​1ω−2ω−4⋮ω−2n​…………​1ω−nω−2n⋮ω−n×n​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​p0​p1​⋮pn​​⎦⎥⎥⎥⎥⎥⎥⎤​\n显然, 由于DFT和DFT逆矩阵具有相似的形式, 我们完全可以用同一个函数完成快速傅里叶的正反变换!\n","categories":["Algorithm"],"tags":["CS","Algorithm"]},{"title":"【C++编程】类模板","url":"/2023/02/28/CS/class-template/","content":"“C++17类模板”\n\n\n编译器用于创建类的模板: 自动生成类\n\n标准库\n类模板不是类, 是创建类的一种方式\n\n\n\n实例\n\n编译器从类模板中生成的类, 在第一次使用模板类型声明变量是, 会创建类模板的一个实例, 以后定义同类型的变量时, 会使用已创建的第一个实例. 在创建类模板时, 也可以不同时声明变量.\n数据的组织 独立于 对象类型\n\n\n 类模板的定义\ntemplate&lt;typename T1, typename T2, Type Arg1&gt;class ClassName &#123;    // template class definition&#125;;\n\n模板参数\n\n类型参数 typename\n\n实参总是类型: int, float…\n\n\n非类型参数 Type\n\n实参是整数类型的字面量: 200, 10…\n整数常量表达式\n指向对象的指针或引用, 函数指针或空指针\n\n\n模板\n\n实参是类模板的一个实例\n\n\n\n\n\n在模板定义中, 不需要使用完整的ID, 例如构造函数\nClassName&lt;T1&gt;();可以写成ClassName();\n不过在模板体的外部标识模板, 则必须使用模板ID (即在模板类外定义模板中的成员函数时需要显式写出ID)\n\n一个例子\ntemplate&lt;typename T1&gt;class PythonList &#123;private:    int len_;    int size_;    T1* elements_;public:    explicit PythonList&lt;T1&gt;(size_t list_len);    PythonList&lt;T1&gt;(const PythonList&lt;T1&gt;&amp; python_list);    ~PythonList();    T1&amp; operator[](size_t index);    const T1&amp; operator[](size_t index) const;    PythonList&lt;T1&gt;&amp; operator=(const PythonList&lt;T1&gt;&amp; rhs_list);    size_t get_len() const &#123; return len_; &#125;    void allocate_double();&#125;;\n 类模板成员函数的定义\n\n若在模板类的内部定义, 实则为 内联\n\n\n如何理解该语法\n\n类模板的成员函数的外部定义本身就是函数模板, 即使成员函数不依赖类型参数.\n若函数没有在类内定义, 则它需要一个模板定义.\n定义函数模板中的参数列表必须与类模板参数列表相同.\n\n\n例如\n// 析构函数template &lt;typename T1&gt;PythonList&lt;T1&gt;::~PythonList&lt;T1&gt;() &#123;    delete [] elements_;&#125;// 构造函数template &lt;typename T1&gt;PythonList&lt;T1&gt;::PythonList(size_t list_len)    : len_(list_len), size_(FOLD * list_len), elements_(new T1(list_len)) &#123;&#125;template &lt;typename T1&gt;PythonList&lt;T1&gt;::PythonList(const PythonList&lt;T1&gt; &amp;python_list)    : PythonList&#123;python_list.len_&#125; &#123;  for (size_t i&#123;&#125;; i &lt; len_; ++i) &#123;    elements_[i] = python_list.elements_[i];  &#125;&#125;// 下标运算符template &lt;typename T1&gt; T1 &amp;PythonList&lt;T1&gt;::operator[](size_t index) &#123;  if (index &gt;= len_) &#123;    throw std::out_of_range&#123;&quot;Index out of range: &quot; + std::to_string(index)&#125;;  &#125;  return elements_[index];&#125;template &lt;typename T1&gt;const T1 &amp;PythonList&lt;T1&gt;::operator[](size_t index) const &#123;  if (index &gt;= len_) &#123;    throw std::out_of_range&#123;&quot;Index out of range: &quot; + std::to_string(index)&#125;;  &#125;  return elements_[index];&#125;// 赋值运算符template &lt;typename T1&gt;PythonList&lt;T1&gt; PythonList&lt;T1&gt;::operator=(const PythonList&lt;T1&gt;&amp; rhs_list) &#123;    if (&amp;rhs_list != this) &#123;        delete [] elements_;        len_ = rhs_list.len_;        size_ = rhs_list.size_;        elements_ = new T1[len_];        for (size_t i &#123;&#125;; i &lt; size_; ++i) &#123;            elements_[i] = rhs_list.elements_[i];        &#125;    &#125;    return *this;&#125;\n\n第一行说明该函数为模板函数; 在限定成员函数时, 作用域需要带上模板ID\n有时候需要提供自己的拷贝构造(或析构), 因为涉及到动态内存分配时, 默认拷贝构造(或析构)有可能会出现负面效应\n在赋值重载时, 需要 检查左右操作数是否相等, 否则会释放this指向的对象后再进行复制.\n\n 代码重复\n\n在上述的定义中, const的重载和非const的重载模板函数代码重复, 代码重复不利于后续的维护\n\n对抗重复的方法: 函数, 模板, 基类\n\n\n传统方法: 用const实现非const\ntemplate &lt;typename T1&gt;T1&amp; PythonList&lt;T1&gt;::operator[](size_t index) &#123;    return const_cast&lt;T1&amp;&gt;(static_cast&lt;const PythonList&lt;T1&gt;&amp;&gt;(*this) [index]);&#125;\nC++17: std::as_const()(utility头文件)\ntemplate &lt;typename T1&gt;T1&amp; PythonList&lt;T1&gt;::operator[](size_t index) &#123;    return const_cast&lt;T1&amp;&gt;(std::as_const(*this)[index]);&#125;\n 异常安全性\n\n在赋值运算符重载的时候, 由于使用了new, 可能会出现std::bad_alloc异常\n在elements_[i] = rhs_list.elements_[i];可能会出现关于类型T1的赋值异常\n\n\n当声明了noexcept后, 表示代码内部不发生异常, 使得编译器能做更多的优化, 例如大部分析构都隐式声明了noexcept cppreference noexcept\n\n\n在以上的赋值运算符中使用 复制后交换\n\n 定义模板类注意\n\n\n成员函数模板与类模板的定义放在同一个文件中: 当编译器生成类模板时, 需要去使用函数模板, 所以在使用模板的源文件中, 这些成员函数的定义必须可用.\n\n\n 类模板实例化\nPythonList&lt;double&gt; data &#123;10&#125;;\n\n编译器只编译程序使用的成员函数, 不会为某个模板参数的实例而一次性编译整个类: 例如上述代码编译后的类中只有构造函数和析构函数.\n\n\n声明对象类型的指针 不会 创建模板实例: PythonList&lt;std::string&gt;* data_p;\n\n 非类型的类模板参数\n\n主要用于定义指定容器有效的值, 如数组的维数\n\n非类型参数只能是整数类型 (size_t, long), 枚举类型, 对象的指针或引用, 函数的指针或引用, 类成员的指针\n当作常量\n\n\ntemplate&lt;typename T1, size_t size&gt;class ClassName &#123;    // definition&#125;;// 还有一些比较无语的template&lt;typename T1, T1 value&gt; ... // 此时T1只能是模板的非类型参数所允许的类型\n\n注意\n只有模板参数完全相同的情况下, 编译器才不会再次编译模板类; 任意一个不同, 编译器都会认为是不同的类, 后果是代码膨胀\n\n解决方法 (待定)\n\n\n 模板参数的默认值\n\n与函数的默认参数类似\n\n如果某个模板参数有默认值, 则后续的参数也必须有默认值\n如果某个模板参数的实参被省略, 则后续的所有实参也必须省略\n不需要在成员函数的模板中指定默认值\n\n\ntemplate&lt;typename T1 = int, int value = 10&gt; ...\n 模板的显式实例化\ntemplate class ClassName&lt;T1, 10, ...&gt;\n\n编译器会从模板中实例化所有的成员函数, 无论是否调用\n\n 类模板特化\n模板的使用中有时候只对 某些类型 有用, 而不支持其他类型; 因此使用 特化 来处理某些特殊情况.\n例如整型变量的相等和浮点型的比较并不相同, 这时可以使用模板的特化来处理.\n\n对于类模板中的成员函数:\n\n如果成员函数是在类模板的外部定义的, 而不是在类模板体中定义的, 则可以提供函数模板的特化\n\n\n全特化\n即规定模板实现的所有模板参数\ntemplate&lt;&gt;class PythonList&lt;const char*&gt;&#123;&#125;;\n\n特化的定义必须放在原有的定义或声明后面. 因为指定了所有参数, 所以是 全特化\n\n偏特化\n即只规定模板参数列表中的一部分模板参数\ntemplate&lt;Type value&gt;class PythonList&lt;const char*, value&gt; &#123;&#125;;\n\ntemplate后的参数列表包含的是为这个模板特化的实例所指定的参数, 即实例化时需要指定value\n模板名后面的尖括号指定原有类模板定义中的参数如何特化. 该参数列表必须与原来未特化的类模板个数相同\n\n\n指针类型的偏特化\n例如下面代码: template的第一个参数仍是T1, 但模板名后面可以跟着T*\n\ntemplate&lt;typename T1, Type value&gt;class ClassName&lt;T1*, value&gt; &#123;&#125;;\n\n特化的选择\n当匹配给定特化的每个实参匹配多个特化时, 编译器会选择 最特殊 的一个特化.\n\n特殊是指有多个匹配, 如果符合A特化, 也符合B特化, 但反过来不行时, 则A比B更特殊 (A含于B)\n\n\n 在类模板中使用static_assert()\nstatic_assert()接受两个参数, 第一个参数为false时, 输出第二个参数指定的消息. 第一个实参使用type_traits.h中的模板\n\n 类模板的友元\n对于友元函数和友元类的情况与一般情况相同\n\n模板友元\n\n类模板的参数列表一般包含定义友元模板的所有参数\n如果类模板的一些参数在友元模板中没有, 则友元模板的实例会用于类模板的几个实例\n普通类若有友元模板, 则友元的每一个实例都是这个类的友元\n\n\n","categories":["CS"],"tags":["CS","C++"]},{"title":"【C++】CMake Tutorial","url":"/2022/08/10/CS/cmake/","content":"CMake version: 3.x\n\n Command Line\n# (configure step) create build dir, and generate build/Makefile -&gt; generate Makefilecmake -B build# (build step) invoke building system and build the project in different OS -&gt; generate executable filecmake --build build -j4# invoke building system to execute target &quot;install&quot;cmake --build build --target install# define configure variables, only use in configure step# use -D# set build type in configure step, the value will remain when invoked the second time unless delete build dircmake -B build -DCMAKE_BUILD_TYPE=Release# Specify generator (generator: generate build system build rule from CMakeLists.txt)# use -G# generator Ninja, faster than Unix Makefile, generate *.ninjacmake -B build -G Ninja\n CMakeLists.txt\nadd source file\n(1). single file: main.cpp\nadd_executable(main main.cpp)\nor\nadd_executable(main)target_sources(main PUBLIC main.cpp)\n(2). multiple files: main.cpp | other.cpp | other.h\nadd_executable(main)target_sources(main PUBLIC main.cpp other.cpp)\nor set a new variable\nadd_executable(main)set(sources main.cpp other.cpp other.h)  # other.h can deletetarget_sources(main PUBLIC $&#123;sources&#125;)\nor use GLOB to search all files in current dir\nadd_executable(main)file(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)  # add CONFIGURE_DEPENDS to detect any change when next buildtarget_sources(main PUBLIC $&#123;sources&#125;)\nwhen we have a dir structure:\nmylib  +----*.cpp  +----*.h*.cpp*.h\nno need to write all files:\n# add all file in current dir and mylib diradd_executable(main)aux_source_directory(. sources)aux_source_directory(mylib sources)target_sources(main PUBLIC $&#123;sources&#125;)\nor use GLOB_RECURSE to find all files recursely:\nadd_executable(main)file(GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h)target_sources(main PUBLIC $&#123;sources&#125;)\nERROR: use GLOB_RECURSE will include *.cpp files in build dir.\nsolution: Add all source files in a dir named src\n Configure variables\nCMAKE_BUILD_TYPE: type of build, Release, Debug, MinSizeRel and RelWithDebInfo, defualt: none (debug).\nset(CMAKE_BUILD_TYPE Release)\nset default build type as Release to reach high performance: in the first three lines:\nif (NOT CMAKE_BUILD_TYPE)    set(CMAKE_BUILD_TYPE Release)endif()\n# Specify version of cmakecmake_minimum_required(VERSION 3.22)# set c++ standard# don&#x27;t modify CMAKE_CXX_FLAGS to add -std=c++17set(CMAKE_CXX_STANDARD 17)# if use the needed CXX standard defined.set(CMAKE_CXX_STANDARD_REQUIRED ON)  # OFF default# prevent features GCC onlyset(CMAKE_CXX_EXTENSIONS OFF)# set project infoproject(project_name LANGUAGES language_list(such as C CXX ASM...))\n Linkable library\nadd_executable(main mian.cpp mylib.cpp)\nor generate a static library\nadd_library(mylib STATIC mylib.cpp)  # create libmylib.aadd_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\nor generate dynamic lib\nadd_library(mylib SHARED mylib.cpp)add_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\nor use object lib, no *.a file, let CMake remember which objects files are created\nadd_library(mylib OBJECT mylib.cpp)add_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\n静态库问题: GCC会自行剔除没有引用符号的对象, 此时使用对象库避免, 从而不会自动剔除没引用到的对象文件, 绕开编译器不统一问题. 动态库也可以避免剔除没引用的对象文件, 但引入了运行时链接的麻烦.\n# no specify variable in add_library()set(BUILD_SHARED_LIBS ON)  # default OFFadd_library(mylib mylib.cpp)\nHINT 静态库常常被认为直接链接到可执行文件上. 因此在动态库中不要链接静态库. 很呆. 地址会变. 当然解决方法是: 要么转化为对象库, 要么让静态库变成地址无关的代码PIC\n# set global propertyset(CMAKE_POSITION_INDEPENDENT_CODE ON)add_library(otherlib STATIC otherlib.cpp)add_library(mylib SHARED mylib.cpp)target_link_libraries(mylib PUBLIC otherlib)add_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)\nor set local property\n# set local propertyadd_library(otherlib STATIC otherlib.cpp)set_property(TARGET otherlib PROPERTY POSITION_INDEPENDENT_CODE ON)add_library(mylib SHARED mylib.cpp)target_link_libraries(mylib PUBLIC otherlib)add_execuable(main main.cpp)target_link_libraries(main PUBLIC mylib)\n Attributes of objects\n设置单属性: set_property(TARGET ... PROPERTY ...);\n设置多属性: set_target_properties(file_name PROPERTIES properties_list)\nHINT: 以上命令在add_executable后有效.\n设置全局属性 (改变属性的默认值): set(CMAKE_XXX), 在add_executable前设置.\n\n如果需要在Windows下面使用动态库 (Windows对动态链接不友好), 则需要在定义和声明添加:\nDeffinition:\n#include &lt;cstdio&gt;#ifdef _MSC_VER__declspec(dllexport)#endifvoid sayy_hello()&#123;&#125;\nDeclaration:\n#pragma once#ifdef _MSC_VER__declspec(dllimport)#endifvoid say_hello();\n然后CMakeLists.txt这样写:\n# In Main dircmake_minimum_required(VERSION 3.22)add_subdirectory(mylib)  # add sub moduleadd_executable(main main.cpp)target_link_libraries(main PUBLIC mylib)# In sub module diradd_library(mylib SHARED mylib.cpp mylib.h)\n然后Windows极有可能会报错: 运行时找不到dll; 原因是dll和exe不在同一目录 (Windows只会查找exe所在目录和PATH).\n\n把dll添加到PATH环境变量\n或者dll和dll其他的所有依赖dll, 全部拷贝到exe同一目录\n\n这是因为CMake把main放在build下, 而mylib放在build/mylib/mylib.dll\n\n因此重定向输出路径, 改变mylib属性, 让.dll文件输出到 PROJECT_BINARY_DIR 里面.\nset_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_(DEBUG | RELEASE | NONE) | ARCHIVE_OUTPUT_DIRECTORY | LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_BINARY_DIR&#125;)\n Externel library\nIn Linux: feel free to link externel libraries. (/usr/lib/…) But Windows can’t. Linux can also include head file directly (/usr/include/…).\nHINT: CMake 的分隔符永远是 “/”, 即使是Windows, CMake会自动转化.\nMore general method:\nfind_package(package_name REQUIRED)\n没听懂, 以后补, 以后也不想补.\n Variables and Outputs\noutput some log infomation when running cmake -B build, used for debugging.\nmessage(&quot;log info&quot;)\nmessage(STATUS &quot;status info&quot;)  # -- prefix\nmessage(WARNING &quot;warning info&quot;)  # yellow\nmessage(SEND_ERROR &quot;error info&quot;)  # send error log but continue to runmessage(FATAL_ERROR &quot;error info&quot;)  # print error and stop running\n Variable and Cache\n重复执行cmake -B build: 第一次较慢, 将环境的检测存入缓存, 第二次以及以后直接查看缓存内容. 因此某些错误可以通过删除 ./build/CMakeCache.txt解决. 当然也可以删了整个build文件夹重新编译, 慢一点而已.\n","categories":["CS"],"tags":["C++","Programming"]},{"title":"【操作系统】Overview","url":"/2023/05/17/CS/os-1/","content":"“计算机三大浪漫之一”\n\n 什么是操作系统\n\nA body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)\n\n 操作系统是如何从一开始变成这样的\n三个线索\n\n计算机（硬件）\n程序（软件）\n操作系统（管理软件的软件）\n\n对单一计算机硬件系统作出抽象、支撑程序执行的软件系统（狭义）\n\n\n\n\n1940s：第一台计算机\n\n计算机系统 = 状态机\n标准的Mealy型数字电路（ENIAC-1946-2-14）\n\n延迟线存储器\n图灵机\n没有操作系统（运行程序需要接线，对，物理意义的接线）\n\n\n\n1950s：更快更小的逻辑门，磁芯内存，IO设备（1953年出现中断）\n1957：Fortran\n\n操作系统的概念开始形成：管理多个程序依次排队运行的库函数和调度器，需求是多用户排队共享计算机\n\n操作（operate）任务（jobs）的系统（system）\n批处理系统 = 程序的自动切换（换卡）+ 库函数API\nDISK Operating System (DOS)：开始出现设备，文件，任务等对象和API\n\n\n\n1960s：集成电路，总线开始出现，更大的内存（支持把多个程序一起放在内存里）\n\n能同时载入多个程序到内存且灵活调度它们的管理程序，包括程序可以调用的API\n有了进程（progress）的概念\n进程执行IO时，将CPU让给其他进程：在多个地址空间隔离的程序之间切换\n\n既然操作系统可以实现程序的切换，不如让它们能够定时切换\n\n基于中断机制：使程序在执行时，异步地插入函数调用，由操作系统决定（调度策略）是否应该切换到另一个程序执行\nMultics(MIT,1965):现代操作系统诞生\n\n1970s+：集成电路空前发展，PC，CISC, 中断，IO，异常，MMU，网络，PASCAL, C\n\n分时系统成熟，UNIX（单用户系统）诞生和完善\n1973：管道（对象），信号API，grep（应用程序）\n1983：BSD socket（对象）\n1984：procfs（对象）\nUNIX衍生家族：1BSD, GNU, MacOS, Minix, Windows, Linux0.01…\n\n\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Program","url":"/2023/05/17/CS/os-2/","content":"“计算机的三大浪漫之一”\n\n 什么是程序\n\n源代码视角\n\n程序也是状态机（数字系统是状态机，程序运行在数字系统上）\nC程序也是状态机 应该落实到可执行的语句\n\n状态 = 栈 + 堆（stack frame的列表，每个frame有PC，全局变量）\n初始状态：main函数执行的第一条语句，全局变量初始化\n迁移：执行一条简单语句（top stack frame的PC的语句），PC++\n函数调用：将栈帧压栈\n函数返回：将栈帧出栈\n\n\n\n\n\n二进制视角\n\n还是状态机，状态 = 内存M + 寄存器R\n操作系统上的程序：所有的指令都只能做计算。这些指令无法使程序停下来。(M,R)-&gt;(M’,R’)，纯计算\n调用操作系统syscall：把（M,R）完全交给操作系统，任其修改，OS可以自己决定返回（M’,R’），可以实现与操作系统中其他对象的交互：读写文件/操作系统状态，改变进程（运行中的状态机）状态（创建进程，销毁自己）\n程序是计算 + syscall\n\n\n\n如何在程序的两个视角之间切换\n\n编译器Compiler：源代码S（状态机） -&gt; 二进制代码C（状态机），C = compile(S)\n正确的编译（优化）：S与C的可观测行为严格一致（S中不可优化的内容在C中必须一致，包括system calls, volatile, variable loads/stores, termination）。Trivially正确的实现：直接翻译/解释执行S的语义\n\n\n\n操作系统中的一般程序\n\n程序 = 计算 -&gt; system -&gt; 计算 -&gt; …\n操作系统收编了所有的软硬件资源，只能用操作系统的允许方式访问系统的对象（能够管理多个状态机）\n【面试题】二进制程序状态机的第一条指令是什么（一个简单的Hello World C程序执行的第一条指令在哪里。）：用gdb -&gt; starti，或者查看进程信息info proc &#123;mappings&#125;（因为它也是状态机，所以有OS给的初始状态）（如果想改的话就去改elf二进制文件）\n【面试题】main函数在执行前、中、后发生了哪些操作系统的API调用。用trace（linux里面的工具是strace）可以查看system call，当然第一句是execve。本质上所有的程序和HelloWorld类似：\n\n被OS加载：通过另一个进程执行execve设置为初始状态\n状态机执行：进程管理（fork, execve, exit, …），文件/设备管理（open, close, read, write, …），存储管理（mmap, brk, …）\n直到 _exit(exit_group)退出\n\n\n\n\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Multi-prossesor","url":"/2023/05/23/CS/os-3/","content":"“计算机的三大浪漫之一”\n\n 多处理器编程\n\n并发 concurrent: existing, happening, or done at the same time. In computer science, concurrency refers to the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome\n\n有共享内存的执行流\n\n执行流有独立的堆栈和寄存器\n共享所有的内存（指针可以互相引用）\n从状态机视角：每个执行流有独立的stack frames链表，但是共享全局变量和堆。处理器每次选择其中一个执行流执行（状态转移为被执行的执行流以及相应的内存发生改变，其余执行流不变）\n\n\n最早的并发程序：系统调用的代码（操作系统）\n\njyy的线程库，编译时要加上-lpthread\n\n创建一个线程：\n\n入口函数是fn的线程，立即开始执行\n语义：在状态机中新增stack frame链表并初始化为fn(tid)\n\nvoid create(void *fn) &#123;  assert(tptr - tpool &lt; NTHREAD);  *tptr = (struct thread) &#123;    .id = tptr - tpool + 1,    .status = T_LIVE,    .entry = fn,  &#125;;  pthread_create(&amp;(tptr-&gt;thread), NULL, wrapper, tptr);  ++tptr;&#125;\n等待线程结束：\n\n等待所有运行线程的fn返回\n在有其他线程未执行完时死循环，否则返回（while(other threads not return);）\n\nvoid join() &#123;  for (int i = 0; i &lt; NTHREAD; i++) &#123;    struct thread *t = &amp;tpool[i];    if (t-&gt;status == T_LIVE) &#123;      pthread_join(t-&gt;thread, NULL);      t-&gt;status = T_DEAD;    &#125;  &#125;&#125;\n\n如何理解【等待】\n当某一个状态执行的线程 T1执行join后，后续每一个状态：若处理器选择执行 T1，则回到当前原状态，直到所有其他进程都返回了。\n\n\n操作系统会自动把不同的线程放在不同的处理器上面，后台运行发现CPU的使用率超过100%\n\n\n证明线程会共享内存\n\n可以设置全局变量\n\n如果内存是共享的，某个线程改变全局变量时，其他线程都能看到\n\n\n创建多个线程，线程内去修改或查看全局变量\n\n\n\n证明线程可以有独立的堆栈\n\n__thread 可以将变量声明为 thread local 的，线程内部可见\n\n\n\n查看创建线程的系统调用\n\nstrace\nclone是用于创建线程的系统调用\n\n\n\n原子性：一段代码执行独占整个计算机系统\n\n单处理器多线程：线程运行时可能被中断，切换到另一个线程执行\n多处理器多线程：线程并行执行\n\n\n\n实现原子化\n\n唔…不理解\n\n\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Concurrency Program","url":"/2023/05/23/CS/os-4/","content":"“计算机的三大浪漫之一”\n\n 如何理解并发程序的执行\n\n也就是画状态机：把所有可能状态都画出来\n\n\n互斥mutual exclusion： 保证两个代码不能同时执行一段代码\n\n假设基本操作为读写原子的，如何实现共享内存上的互斥\n\n处理器不是原子地处理load和store的\n\n\nPeterson算法（谦让）\n\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Synchronization","url":"/2023/06/11/CS/os-5-1/","content":"“如何在多处理器上协同多个线程完成任务”\n\n 线程同步\n 生产者消费者问题\n\n问题描述\n\n（括号问题形式）两个程序producer和consumer，producer打印左括号， consumer打印右括号，打印的括号序列满足 嵌套深度不超过n，等到有空位再打印左括号，等到能匹配才能打印右括号\n\n\n\n互斥锁解法\n\n#include &quot;thread.h&quot;#include &quot;thread-sync.h&quot;int n, count = 0;mutex_t lk = MUTEX_INIT();// 先上锁，检查缓冲区是否已满：// 如果满了，则解锁，并重新检查，直到不满足条件；// 如果没有满，则用1个资源填充缓冲区，打印，释放锁。void Tproduce() &#123;  while (1) &#123;retry:    mutex_lock(&amp;lk);    if (count == n) &#123;      mutex_unlock(&amp;lk);      goto retry;    &#125;    count++;    printf(&quot;(&quot;);    mutex_unlock(&amp;lk);  &#125;&#125;void Tconsume() &#123;  while (1) &#123;retry:    mutex_lock(&amp;lk);    if (count == 0) &#123;      mutex_unlock(&amp;lk);      goto retry;    &#125;    count--;    printf(&quot;)&quot;);    mutex_unlock(&amp;lk);  &#125;&#125;int main(int argc, char *argv[]) &#123;  assert(argc == 2);  n = atoi(argv[1]);  setbuf(stdout, NULL);  for (int i = 0; i &lt; 8; i++) &#123;    create(Tproduce);    create(Tconsume);  &#125;&#125;\n\n条件变量\n\n互斥锁是独占的：每个线程都试图去观察缓冲区的资源（锁在争抢的时候不是自旋的，但还是会不断检查缓冲区，浪费CPU资源）\n希望在不满足条件时能够“睡眠”：mutex_unlock_and_sleep(&amp;lk)，直到条件可以被满足时，别的线程将自己唤醒wakeup()，并且唤醒后立即获得一把锁\nwait(cv,mutex)：调用时保证已经获得了mutex，释放mutex、进入睡眠\nsignal/notify(cv)：由于此时条件变量cv已经获得了一把锁，如果有线程在等待cv，则唤醒 其中一个 线程\nbroadcast/notifyAll(cv)：唤醒全部等待cv的线程\n\n\n\n一个错误例子：当consumer用signal从等待队列中唤醒某个进程时，可能唤醒的还是consumer\n\n解决办法1：用两个条件变量分别表示唤醒producer还是consumer\n解决办法2：将if改为while：当条件不满足时等待锁，被唤醒后 会首先检查当前条件是否被满足，因此跳出while后条件一定满足；将signal改为broadcast：当某个线程条件被满足时，通知所有的线程\n\n\n// 先上锁，检查缓冲区是否满：// 若满，则睡眠等待，直到被唤醒；// 若不满，则打印，唤醒cv，释放锁void Tproduce() &#123;  mutex_lock(&amp;lk);  if (count == n) cond_wait(&amp;cv, &amp;lk);  printf(&quot;(&quot;); count++; cond_signal(&amp;cv);  mutex_unlock(&amp;lk);&#125;void Tconsume() &#123;  mutex_lock(&amp;lk);  if (count == 0) cond_wait(&amp;cv, &amp;lk);  printf(&quot;)&quot;); count--; cond_signal(&amp;cv);  mutex_unlock(&amp;lk);&#125;\n\n条件变量同步万能模板\n\n// 需要等待条件满足时mutex_lock(&amp;mutex);while (!cond) &#123;  wait(&amp;cv, &amp;mutex);&#125;assert(cond);// ...// 互斥锁保证了在此期间条件 cond 总是成立// ...mutex_unlock(&amp;mutex);// 其他线程条件可能被满足时broadcast(&amp;cv);\n\njob queue的实现\n\n\n信号量\n\n 哲学家吃饭问题\n\n问题描述\n\n哲学家有时思考有时吃饭，吃饭时必须左右手都拿到筷子才能吃饭，当筷子被别人占有时需要等待，如何同步\n\n\n\n万能的信号量：每个线程自己管理自己（分布式同步）\n\nmutex_lock(&amp;mutex);// 检查是否两根筷子都没人拿while (!(avail[lhs] &amp;&amp; avail[rhs])) &#123;  wait(&amp;cv, &amp;mutex);&#125;// 在锁保护的时候自己拿起两根筷子avail[lhs] = avail[rhs] = false;mutex_unlock(&amp;mutex);// 吃饭// 吃完在锁保护的时候放下筷子mutex_lock(&amp;mutex);avail[lhs] = avail[rhs] = true;// 告诉别人吃完了broadcast(&amp;cv);// 释放锁mutex_unlock(&amp;mutex);\n\n让一个人集中管理筷子-转化为PC问题（master-slave）\n\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】HPC & HRI","url":"/2023/06/12/CS/os-5-2/","content":"“什么样的任务是需要并行/并发的？它们应该如何实现？”\n\n 如何写并发程序\n 高性能计算\n\n高性能计算HPC\n\n“A technology that harnesses the power of supercomputers or computer clusters to solve complex problems requiring massive computation.” (IBM)\n\n\n\n主要挑战\n\n计算任务如何分解：计算图需要容易并行化，机器-线程两级任务分解\n\n生产者-消费者解决一切，MPI\nParallel and distribution computation: numerical methods\n\n\n线程间如何通信\n\n通信不仅发生在节点/线程间，还发生在任何共享内存访问\n\n\n\n\n 数据中心\n\n数据中心\n\n以数据（存储）为中心\n主要挑战PAC：数据要保持一致(Consistency)，服务要时刻保持可用(Availability)，容忍机器离线(Partition tolerance)\n\n\n\nkey-value storage\n\n线程\n协程（coroutines）：多个可以保存/恢复的执行流；比线程更轻量（完全没有系统调用，也就没有操作系统的状态）\n\n\n\n线程存在的问题：每个线程会占用相当可观的OS资源（linux kernel线程8Kb）\n协程存在的问题：当一个协程block的时候，其它协都会阻塞\n\n\nGo语言\n\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【操作系统】Mutual Exclusion","url":"/2023/06/11/CS/os-5/","content":"“计算机的三大浪漫之一”\n\n 在共享内存上实现互斥\n假设：存在load和store，前者表示只能load看当前变量的值，并且不做任何其他操作；后者表示只能store，不能同时去读\n 自旋锁spin lock\n原子指令lock，在汇编指令的前面加上lock前缀。\n如下面的代码：原子地改变addr的值。\nint xchg(volatile int *addr, int newval)&#123;    int result;    asm volatile(&quot;lock xchg %0, %1&quot;: &quot;+m&quot;(*addr), &quot;=a&quot;(result) : &quot;1&quot;(newval));    return result;&#125;\n有stdatomic.h（C++）\n\n自旋协议\n前提是硬件支持原子操作（原子地读写）\n\n有两把锁，一把公用的锁（A），每个线程有一把私有的锁（Bn）\n当某个线程需要访问公用资源的时候，交换公有和私有的锁（此时交换操作是原子的）\n交换后其他线程发现公用的锁不是预期值，即使与私有的锁交换，也无法进入临界区\n直到线程退出临界区将公用的锁返回\n每一个线程内部都有循环判断锁的值的代码\n\n\nint table = YES;void lock() &#123;retry:  int got = xchg(&amp;table, NOPE);  if (got == NOPE) // spin    goto retry;  assert(got == YES);&#125;void unlock() &#123;  xchg(&amp;table, YES)&#125;\nint locked = 0;void lock() &#123; while (xchg(&amp;locked, 1)) ; &#125;void unlock() &#123; xchg(&amp;locked, 0); &#125;\n\n其中xchg函数是硬件支持的原子操作（见上方）\n\n\n操作系统内部保证所有带有lock的指令可以顺序执行，保证执行某个带有lock的指令时，前面所有共享内存是可见的\n\n\nRISC-V的Load-Reserved/Store-Conditional\n\nLR：标记，对共享变量的标记，当共享变量被改变时，标记消失\nSC：当标记还在的时候才可以写入\n\n\n 互斥锁Mutex Lock\n\n自旋锁的缺陷\n\n性能问题0：共享变量会触发处理器间的缓存同步，延迟增加\n性能问题1：除了进入临界区的线程，其他处理器的线程都在空转；争抢锁的处理器越多，利用率越低\n性能问题2：获得自旋锁的线程可能被OS系统切换出去，实现100%的资源浪费（好耶！\n\n自旋锁的使用场景：操作系统内核的并发数据结构（短临界区）\n\n临界区几乎不拥堵\n持有自旋锁时禁止执行流切换\n\n\n\n实现长临界区的互斥\n\n由于C代码只能做计算，所以让操作系统来实现\n\n\n// 试图获得 lk，但如果失败，就切换到其他线程syscall(SYSCALL_lock,&amp;lk);// 释放 lk，如果有等待锁的线程就唤醒syscall(SYSCALL_unlock, &amp;lk);\n\nOS用自旋锁确保自己读写锁的过程是原子的\n\n Futex=Spin+Mutex(Fast Userspace Mutex)\n(关于自旋锁的一些分析（有关fast path &amp; slow path）)[https://jyywiki.cn/OS/2022/slides/5.slides#/4/1]\nfutex可以保证绝大多数情况下不进入内核\n","categories":["CS"],"tags":["CS","OS","NJU"]},{"title":"【第一篇博客】Hello World","url":"/2022/01/11/Life/first/","content":" Finished! My First Blog!\nAfter a long time deploying my blog webpage and a lot of other borthering settings, I finally finished it! I mean, FINALLY!!! 😆 😆 😆\n\n Original Intention\nCan a programmer has no personal blog? I have seen many blogers writing their own blogs no metter answering a question or just taking notes from time to time on websites such as zhihu and csdn, but among which I prefer is to establish a personal website where I can put my blogs on.\nSo, at first I have no intention about what to do with my site, maybe I just feel that it’s really cool to have such a lovely home for oneself to “lie down and rest”.\nBut when it was finally established by myself, experencing a lot of confusing problems and taking amount of time to debug, I must to say that, I love here, and I believe I will take after it like taking after a baby, a baby who are growing up. 😊\n Thanks\nI would not finish my work without the help of JerryYang, whose helpful blog is the guidance of mine (though there are still some mistakes maybe? 😵). Based on it, I have known some basic command with Linux, Git and Github, which is also beneficial for my lessons next term. Except him I want to link some videos there to thank for another ups from bilibili:\nusing hexo to start blog\nhow to writing blogs\n","categories":["Life"],"tags":["Blog","Life"]},{"title":"【深度学习】Image Semantic Segmentation based on UNet","url":"/2022/08/21/ML/UNet/","content":"“Semantic segmentation of images, use UNet model.”\n\n Abstract\nIn this project, we realize an basic UNet model and UNet++ model, then we apply them on image semantic segmentation. We show our basic theory of UNet and an improvement of it, and we provide main code of this program. Finally, we give the result of segmentation images, loss-curve and accuracy-curve on both training and validation set.\nThe copyright of this program is owned by our team mentioned on the end of this blog.\n UNet Structure\nThe paper published in 2015 propose a noval network structure, whose shape is similar with the captal “U”. The idea comes from FCNN. U-Net is one of the classes of “Encoder-Decoder” structure.\n\nThe front half of the network is “encoder”. The input image passes covolutional kernel, and then passes the pooling layer (or other dimension-decreasing layer). The opposite of that is the back part of UNet, the “decoder”. The input of decoder is a sequence of feature maps with highly contracted pixels. The output of the decoder (or the whole network) is an image with the same shape of input image, where each pixel has its own class.\nIn this project, we decrease the number of convolutional layers so that there are only two convolutional layers in each convolutional kernel as the dataset includes images with shape 128×256128\\times 256128×256.\n Operator Definitions\nConvolutional Kernel:\nWe define the basic convolutional kernel as follow:\nself.layer = nn.Sequential(    # in_channel, out_channel, kernel_size, stride, padding    # batch size * channel * height * weight    nn.Conv2d(C_in, C_out, kernel_size=(3, 3), stride=(1, 1), padding=1),  # 64 64 128 256    nn.BatchNorm2d(C_out),    nn.Dropout(0.2),    nn.LeakyReLU(),    nn.Conv2d(C_out, C_out, kernel_size=(3, 3), stride=(1, 1), padding=1),  # 64 64 128 256    nn.BatchNorm2d(C_out),    nn.Dropout(0.5),    nn.LeakyReLU(),\nIt includes two convolution operations.\nDown Sampling Kernel:\nAs for downsampling kernel, we replace conditional pooling layer to convolutional layer with stride equaling to 2, which means the shape will be shrunk to 12\\frac{1}{2}21​ while remaining the same channels.\nself.Down = nn.Sequential(    nn.Conv2d(C, C, kernel_size=(3, 3), stride=(2, 2), padding=1),  # 64 64 64 128    nn.LeakyReLU()        )\nUp Sampling Kernel:\nThe basic structure of up-sampling contains only one convolutional layer with 1×11\\times 11×1 convolutional kernel size and half out-channel. The feature map should pass an interpolation layer before getting into the convolutional layer.\ndef __init__(self, C):    super(UpSampling, self).__init__()    # out-channel = 1/2 in-channel    self.Up = nn.Conv2d(C, C // 2, kernel_size=(1, 1), stride=(1, 1))    def forward(self, x, r):    # neighbor interpolation    up = F.interpolate(x, scale_factor=2, mode=&quot;nearest&quot;)    x = self.Up(up)    # concatenate the feature map in encoder and     # the feature map in corrsponding decoder layer, in channel dimension    res = torch.cat((x, r), 1)    return res\nThe interpolation mode we choose is “nearest”. The function torch.cat(dim=1) is used to concatenate two feature maps in channel dimension.\n Network Definition\nBased on the operators defined above, we link these blocks together like UNet structure.\ndef __init__(self):    super(UNet, self).__init__()    # down sampling    self.C1 = Conv(3, 64)    self.D1 = DownSampling(64)    self.C2 = Conv(64, 128)    self.D2 = DownSampling(128)    self.C3 = Conv(128, 256)    self.D3 = DownSampling(256)    self.C4 = Conv(256, 512)    self.D4 = DownSampling(512)    self.C5 = Conv(512, 1024)    # up sampling    self.U1 = UpSampling(1024)    self.C6 = Conv(1024, 512)    self.U2 = UpSampling(512)    self.C7 = Conv(512, 256)    self.U3 = UpSampling(256)    self.C8 = Conv(256, 128)    self.U4 = UpSampling(128)    self.C9 = Conv(128, 64)    self.C10 = torch.nn.Conv2d(64, 3, kernel_size=(3, 3), stride=(1, 1), padding=1)    self.pred = torch.nn.Conv2d(3, 34, kernel_size=(1, 1), stride=(1, 1))    self.Th = torch.nn.Sigmoid()\nLike U-Net mentioned in that paper, we designed 4 layer deep network.\ndef forward(self, x):        # part 1: down sampling, decreasing dimension        R1 = self.C1(x)        R2 = self.C2(self.D1(R1))        R3 = self.C3(self.D2(R2))        R4 = self.C4(self.D3(R3))        Y1 = self.C5(self.D4(R4))        # part 2: up sampling, connect priori knowledge        O1 = self.C6(self.U1(Y1, R4))        O2 = self.C7(self.U2(O1, R3))        O3 = self.C8(self.U3(O2, R2))        O4 = self.C9(self.U4(O3, R1))        # part 3: active function        return self.Th(self.pred(self.C10(O4)))\nAs you can see, the difference between U-Net and other networks before U-Net is that U-Net conbines the former information from encoder and current information from decoder.\n Code\nDuring the training process, we want to keep some information of loss values and accuracy values on training set and validation set so that we can analyze the variance.\nIn the function named train(), we take optimizer and loss as two parameters used in training process. The outputs of this function are loss and accuracy on both training set and validation set. If we get the data about training set and validation set, we can draw the curves. If both training and validation loss values decrease during training process, we can conclude that our model converges and does not overfit on training set.\nThe training code is shown as follow:\nself.model.train()for batch in self.train_loader:    batch_num += 1    optimizer.zero_grad()    rgbs, segs = batch    s, _, m, n = segs.shape    segs = torch.reshape(segs, (s, m, n))    pred_segs = self.model(rgbs).to(self.device)    loss_val = loss(pred_segs, segs)    loss_val.backward()    optimizer.step()\nThe data collecting code can be written as follow:\nStatistic data of training set\nfor ... :    with torch.no_grad():        if batch_num % 5 == 0:            logging.info(f&quot;batch num &#123;batch_num&#125;, loss &#123;loss_val&#125;&quot;)        # delete or add comments when needed        train_loss += loss_val        # statistic valid classified samples        total_pix += s * m * n        idx = torch.argmax(pred_segs, dim=1)        train_valid_pix += torch.eq(idx, segs).sum().float().item()torch.cuda.empty_cache()epoch_acc = train_valid_pix / total_pixtrain_epoch_loss.append(train_loss / batch_num)train_epoch_acc.append(epoch_acc)\nStatistic data of validation set\nself.model.eval()with torch.no_grad():    for valid_batch in self.valid_loader:        valid_batch_num += 1        rgbs, segs = valid_batch        s, _, m, n = segs.shape        segs = torch.reshape(segs, (s, m, n))        pred_segs = self.model(rgbs).to(self.device)        loss_val = loss(pred_segs, segs)        valid_loss += loss_val        valid_total_pix += s * m * n        idx = torch.argmax(pred_segs, dim=1)        valid_valid_pix += torch.eq(idx, segs).sum().float().item()epoch_acc = valid_valid_pix / valid_total_pixvalid_epoch_loss.append(valid_loss / valid_batch_num)valid_epoch_acc.append(epoch_acc)\nThe point you should pay attention to is that you should use with torch.no_grad() before you do some work that have no relation with training process, otherwise your GPU memory will be full or even overflow.\n Result\nAfter a long time training, we get the satisfying result with U-Net model.\n Former Model\nThe “former model” infers the U-Net model, and you will see we use other upgraded model named “UNet++” which will be introduced later.\nWe output the segmentation results and their uncertainties.\n\n Model Upgrade\nFor some reasons, we try another U-Net-like model, Nested UNet, namely UNet++. It has a nested convolutional blocks like a pyramid and there is a chain passing connectivity between each convolutional block every layer.\n\nThe black nodes are the same with U-Net model. The green nodes are what Nested UNet newly added. Both green and blue lines are skip pathways that pass connectivities from encoder to decoder.\nThe use of Nested UNet gives us a little improvement on final results.\n\n Analysis\n U-Net\nWe analyze the loss value and accuracy on both training and validation set:\n\nWe find that after 100 epochs, the model has not convergenced yet, but the loss on validation decreases to the bottom.\n\nFrom the accuracy curves, we find that both training set and validation set have increasing accuracy, which means our model does not overfit.\n Nested UNet\nMeanwhile, we analyze the loss and accuracy of Nested UNet model on both training and validation set.\n\nWe find that Nested UNet has a faster convergency speed than UNet. It uses only about 60 epochs. But to our surprise, we find that Neseted UNet overfit after about only 20 epochs because the validation loss does not decrease anymore.\n\nThe performance on validation accuracy stays the same with UNet model.\n","categories":["ML"],"tags":["CS","Deep Learning"]},{"title":"【数学杂记】空间","url":"/2022/03/20/Math/space/","content":"“内积空间和度量空间有什么区别? Hilbert空间是什么? 它与线性空间的关系是什么?”\n“我已经晕了.”\n\n 数域\n\\(P\\)是包含0, 1的数集, 且对 \\(P\\)中任意两个数的加减乘除运算封闭, 则称 \\(P\\)是一个数域.\n 线性空间\n在数域的基础上, 我们提出线性空间的概念:\n给定数域 \\(P\\) , 和集合 \\(V\\). 有如下映射:\n+:V×V→V+:V\\times V\\rightarrow V\n+:V×V→V\n⋅:P×V→V\\cdot:P\\times V\\rightarrow V\n⋅:P×V→V\n且 (\\(V, P, +, \\cdot\\)) 满足八条基本性质, 则\\(V\\)称为一个线性空间.\n 赋范空间\n赋范空间是定义在线性空间之上的.\n定义在数域 \\(P\\) 的线性空间 \\(V\\) 存在如下映射:\n∣∣⋅∣∣:V→R||\\cdot||:  V\\rightarrow R\n∣∣⋅∣∣:V→R\n且该映射满足: 正定, 齐次, 三角不等式. 则 \\(V\\) 是一个赋范空间, 其中映射 \\(||\\cdot||\\) 称为范数.\n 内积空间\n内积空间是定义在线性空间之上的.\n定义在数域 \\(P\\) 的线性空间 \\(V\\) 存在如下映射:\n⋅:V×V→R\\cdot:  V\\times V\\rightarrow R\n⋅:V×V→R\n则 \\(V\\) 是一个内积空间.\n定义了内积后, 我们可以讨论向量 (即线性空间的元素) 间的长度和夹角, 并进一步讨论正交性等.\n注意: 内积本身具有自然定义的范数, 即内积可以诱导出范数, \\(||x||=\\sqrt{(x,x)}\\), 因此内积空间含于赋范空间.\n 度量空间\n度量空间是某个具有距离函数的集合. 该函数定义的是集合内所有元素的距离, 即集合上的某种度量, 即:\n给定集合\\(V\\), 有映射:\nd:V×V→Rd:V\\times V\\rightarrow \\mathbf{R}\nd:V×V→R\n满足:\n\\[\n\\begin{aligned}\n&d(x,y)\\geq0\\quad (d(x,y)=0\\Leftrightarrow x=0,y=0)\\\\\n&d(x,y)=d(y,x)\\\\\n&d(x,y)\\leq d(x,z)+d(z,y)\n\\end{aligned}\n\\]\n注意: 此处并未要求线性结构.\n注意: 赋范空间一定可以诱导出度量空间, 因此赋范空间含于度量空间\n 完备空间\n完备空间又称 Cauchy 空间. 完备空间是定义在度量空间之上的.\n若度量空间 \\(M\\) 中所有的柯西序列都收敛在 \\(M\\) 中的一点, 则 \\(M\\) 是一个完备空间.\n Hilbert空间\n在内积空间的基础上增添完备性条件, 即得到Hilbert空间.\n 总结\n范数运算+向量空间=(线性)赋范空间\n(线性)赋范空间 + 内积运算=内积空间\n(线性)赋范空间 + 完备性 = Banach 空间\n内积空间 + 完备性 = Hilbert 空间\n内积空间 + 完备性 + 有限维 = Euclidean 空间\n References\nzhihu:\nhttps://www.zhihu.com/question/332144499/answer/731866608\nhttps://www.zhihu.com/question/42312263/answer/699451330\nwikipedia:\nhttps://en.wikipedia.org/wiki/Complete_metric_space\nhttps://en.wikipedia.org/wiki/Metric_space\nhttps://en.wikipedia.org/wiki/Cauchy_sequence\nhttps://en.wikipedia.org/wiki/Cauchy_sequence\nhttps://en.wikipedia.org/wiki/Cauchy_sequence\nhttps://en.wikipedia.org/wiki/Normed_vector_space\n","categories":["Math"],"tags":["Math"]}]